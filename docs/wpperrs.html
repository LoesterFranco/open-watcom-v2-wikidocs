<HEAD>
<TITLE> Open Watcom 2.0 C++ Diagnostic Messages </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- 0 -
<DD><A HREF="#000_internal_compiler_error">000 internal compiler error</A>
<BR><A HREF="#001_assignment_of_constant_found_in_boolean_expression">001 assignment of constant found in boolean expression</A>
<BR><A HREF="#002_constant_out_of_rangeS_truncated">002 constant out of range; truncated</A>
<BR><A HREF="#003_missing_return_value">003 missing return value</A>
<BR><A HREF="#004_base_class___T__does_not_have_a_virtual_destructor">004 base class '%T' does not have a virtual destructor</A>
<BR><A HREF="#005_pointer_or_reference_truncated">005 pointer or reference truncated</A>
<BR><A HREF="#006_syntax_errorS_probable_cause__missing__S_">006 syntax error; probable cause:&nbsp; missing ';'</A>
<BR><A HREF="#007___array__may_not_produce_intended_result">007 '&amp;array' may not produce intended result</A>
<BR><A HREF="#008_returning_address_of_function_argument_or_of_auto_or_register_variable">008 returning address of function argument or of auto or register variable</A>
<BR><A HREF="#009_option_requires_a_file_name">009 option requires a file name</A>
<BR><A HREF="#010_asm_directive_ignored">010 asm directive ignored</A>
<BR><A HREF="#011_all_members_are_private">011 all members are private</A>
<BR><A HREF="#012_template_argument_cannot_be_type___T_">012 template argument cannot be type '%T'</A>
<BR><A HREF="#013_unreachable_code">013 unreachable code</A>
<BR><A HREF="#014_no_reference_to_symbol___S_">014 no reference to symbol '%S'</A>
<BR><A HREF="#015_nested_comment_found_in_comment_started_on_line__u">015 nested comment found in comment started on line %u</A>
<BR><A HREF="#016_template_argument_list_cannot_be_empty">016 template argument list cannot be empty</A>
<BR><A HREF="#017_label___s__has_not_been_referenced_by_a_goto">017 label '%s' has not been referenced by a goto</A>
<BR><A HREF="#018_no_reference_to_anonymous_union_member___S_">018 no reference to anonymous union member '%S'</A>
<BR><A HREF="#019__break__may_only_appear_in_a_for__do__while__or_switch_statement">019 'break' may only appear in a for, do, while, or switch statement</A>
<BR><A HREF="#020__case__may_only_appear_in_a_switch_statement">020 'case' may only appear in a switch statement</A>
<BR><A HREF="#021__continue__may_only_appear_in_a_for__do__or_while_statement">021 'continue' may only appear in a for, do, or while statement</A>
<BR><A HREF="#022__default__may_only_appear_in_a_switch_statement">022 'default' may only appear in a switch statement</A>
<BR><A HREF="#023_misplaced_____or_missing_earlier____">023 misplaced '}' or missing earlier '{'</A>
<BR><A HREF="#024_misplaced__elif_directive">024 misplaced #elif directive</A>
<BR><A HREF="#025_misplaced__else_directive">025 misplaced #else directive</A>
<BR><A HREF="#026_misplaced__endif_directive">026 misplaced #endif directive</A>
<BR><A HREF="#027_only_one__default__per_switch_statement_is_allowed">027 only one 'default' per switch statement is allowed</A>
<BR><A HREF="#028_expecting___s__but_found___s_">028 expecting '%s' but found '%s'</A>
<BR><A HREF="#029_symbol___N__has_not_been_declared">029 symbol '%N' has not been declared</A>
<BR><A HREF="#030_left_expression_must_be_a_function_or_a_function_pointer">030 left expression must be a function or a function pointer</A>
<BR><A HREF="#031_operand_must_be_an_lvalue">031 operand must be an lvalue</A>
<BR><A HREF="#032_label___s__already_defined">032 label '%s' already defined</A>
<BR><A HREF="#033_label___s__is_not_defined_in_function">033 label '%s' is not defined in function</A>
<BR><A HREF="#034_dimension_cannot_be_zero">034 dimension cannot be zero</A>
<BR><A HREF="#035_dimension_cannot_be_negative">035 dimension cannot be negative</A>
<BR><A HREF="#036_dimensions_of_multiMdimension_array_must_be_specified">036 dimensions of multi-dimension array must be specified</A>
<BR><A HREF="#037_invalid_storage_class_for_function">037 invalid storage class for function</A>
<BR><A HREF="#038_expression_must_have_pointer_type">038 expression must have pointer type</A>
<BR><A HREF="#039_cannot_take_address_of_an_rvalue">039 cannot take address of an rvalue</A>
<BR><A HREF="#040_expression_for_____must_be_a_class__struct_or_union">040 expression for '.' must be a class, struct or union</A>
<BR><A HREF="#041_expression_for__MY__must_be_pointer_to_class__struct_or_union">041 expression for '-&gt;' must be pointer to class, struct or union</A>
<BR><A HREF="#042_symbol___S__already_defined">042 symbol '%S' already defined</A>
<BR><A HREF="#043_static_function___S__has_not_been_defined">043 static function '%S' has not been defined</A>
<BR><A HREF="#044_expecting_label_for_goto_statement">044 expecting label for goto statement</A>
<BR><A HREF="#045_duplicate_case_value___s__found">045 duplicate case value '%s' found</A>
<BR><A HREF="#046_bitMfield_width_is_too_large">046 bit-field width is too large</A>
<BR><A HREF="#047_width_of_a_named_bitMfield_must_not_be_zero">047 width of a named bit-field must not be zero</A>
<BR><A HREF="#048_bitMfield_width_must_be_positive">048 bit-field width must be positive</A>
<BR><A HREF="#049_bitMfield_base_type_must_be_an_integral_type">049 bit-field base type must be an integral type</A>
<BR><A HREF="#050_subscript_on_nonMarray">050 subscript on non-array</A>
<BR><A HREF="#051_incomplete_comment">051 incomplete comment</A>
<BR><A HREF="#052_argument_for___must_be_a_macro_parm">052 argument for # must be a macro parm</A>
<BR><A HREF="#053_unknown_preprocessing_directive____s_">053 unknown preprocessing directive '#%s'</A>
<BR><A HREF="#054_invalid__include_directive">054 invalid #include directive</A>
<BR><A HREF="#055_not_enough_parameters_given_for_macro___s_">055 not enough parameters given for macro '%s'</A>
<BR><A HREF="#056_not_expecting_a_return_value">056 not expecting a return value</A>
<BR><A HREF="#057_cannot_take_address_of_a_bitMfield">057 cannot take address of a bit-field</A>
<BR><A HREF="#058_expression_must_be_a_constant">058 expression must be a constant</A>
<BR><A HREF="#059_unable_to_open___s_">059 unable to open '%s'</A>
<BR><A HREF="#060_too_many_parameters_given_for_macro___s_">060 too many parameters given for macro '%s'</A>
<BR><A HREF="#061_cannot_use___based_or___far16_pointers_in_this_context">061 cannot use __based or __far16 pointers in this context</A>
<BR><A HREF="#062_only_one_type_is_allowed_in_declaration_specifiers">062 only one type is allowed in declaration specifiers</A>
<BR><A HREF="#063_out_of_memory">063 out of memory</A>
<BR><A HREF="#064_invalid_character_constant">064 invalid character constant</A>
<BR><A HREF="#065_taking_address_of_variable_with_storage_class__register_">065 taking address of variable with storage class 'register'</A>
<BR><A HREF="#066__delete__expression_size_is_not_allowed">066 'delete' expression size is not allowed</A>
<BR><A HREF="#067_ending___missing_for_string_literal">067 ending &quot; missing for string literal</A>
<BR><A HREF="#068_invalid_option">068 invalid option</A>
<BR><A HREF="#069_invalid_optimization_option">069 invalid optimization option</A>
<BR><A HREF="#070_invalid_memory_model">070 invalid memory model</A>
<BR><A HREF="#071_expression_must_be_integral">071 expression must be integral</A>
<BR><A HREF="#072_expression_must_be_arithmetic">072 expression must be arithmetic</A>
<BR><A HREF="#073_statement_required_after_label">073 statement required after label</A>
<BR><A HREF="#074_statement_required_after__do_">074 statement required after 'do'</A>
<BR><A HREF="#075_statement_required_after__case_">075 statement required after 'case'</A>
<BR><A HREF="#076_statement_required_after__default_">076 statement required after 'default'</A>
<BR><A HREF="#077_missing_matching__endif_directive">077 missing matching #endif directive</A>
<BR><A HREF="#078_invalid_macro_definition__missing__R_">078 invalid macro definition, missing ')'</A>
<BR><A HREF="#079_missing__R__for_expansion_of___s__macro">079 missing ')' for expansion of '%s' macro</A>
<BR><A HREF="#080__s">080 %s</A>
<BR><A HREF="#081_cannot_define_an_array_of_functions">081 cannot define an array of functions</A>
<BR><A HREF="#082_function_cannot_return_an_array">082 function cannot return an array</A>
<BR><A HREF="#083_function_cannot_return_a_function">083 function cannot return a function</A>
<BR><A HREF="#084_function_templates_can_only_have_type_arguments">084 function templates can only have type arguments</A>
<BR><A HREF="#085_maximum_class_size_has_been_exceeded">085 maximum class size has been exceeded</A>
<BR><A HREF="#086_definition_of_macro___s__not_identical_to_previous_definition">086 definition of macro '%s' not identical to previous definition</A>
<BR><A HREF="#087_initialization_of___S__must_be_in_file_scope">087 initialization of '%S' must be in file scope</A>
<BR><A HREF="#088_default_argument_for___S__declared_outside_of_class_definition">088 default argument for '%S' declared outside of class definition</A>
<BR><A HREF="#089____must_not_be_at_start_or_end_of_replacement_tokens">089 ## must not be at start or end of replacement tokens</A>
<BR><A HREF="#090_invalid_floatingMpoint_constant">090 invalid floating-point constant</A>
<BR><A HREF="#091__sizeof__is_not_allowed_for_a_bitMfield">091 'sizeof' is not allowed for a bit-field</A>
<BR><A HREF="#092_option_requires_a_path">092 option requires a path</A>
<BR><A HREF="#093_must_use__va_start__macro_inside_function_with_variable_arguments">093 must use 'va_start' macro inside function with variable arguments</A>
<BR><A HREF="#094_TTTFATALTTT__s">094 ***FATAL*** %s</A>
<BR><A HREF="#095_internal_compiler_error__d">095 internal compiler error %d</A>
<BR><A HREF="#096_argument_number__d_M_invalid_register_in__pragma">096 argument number %d - invalid register in #pragma</A>
<BR><A HREF="#097_procedure___s__has_invalid_return_register_in__pragma">097 procedure '%s' has invalid return register in #pragma</A>
<BR><A HREF="#098_illegal_register_modified_by___s___pragma">098 illegal register modified by '%s' #pragma</A>
<BR><A HREF="#099_file_must_contain_at_least_one_external_definition">099 file must contain at least one external definition</A>
<DT>- 1 -
<DD><A HREF="#100_out_of_macro_space">100 out of macro space</A>
<BR><A HREF="#101_keyboard_interrupt_detected">101 keyboard interrupt detected</A>
<BR><A HREF="#102_duplicate_macro_parameter___s_">102 duplicate macro parameter '%s'</A>
<BR><A HREF="#103_unable_to_open_work_file__error_code_E__d">103 unable to open work file:&nbsp; error code = %d</A>
<BR><A HREF="#104_write_error_on_work_file__error_code_E__d">104 write error on work file:&nbsp; error code = %d</A>
<BR><A HREF="#105_read_error_on_work_file__error_code_E__d">105 read error on work file:&nbsp; error code = %d</A>
<BR><A HREF="#106_token_too_longS_truncated">106 token too long; truncated</A>
<BR><A HREF="#107_filename_required_on_command_line">107 filename required on command line</A>
<BR><A HREF="#108_command_line_contains_more_than_one_file_to_compile">108 command line contains more than one file to compile</A>
<BR><A HREF="#109_virtual_member_functions_are_not_allowed_in_a_union">109 virtual member functions are not allowed in a union</A>
<BR><A HREF="#110_union_cannot_be_used_as_a_base_class">110 union cannot be used as a base class</A>
<BR><A HREF="#111_union_cannot_have_a_base_class">111 union cannot have a base class</A>
<BR><A HREF="#112_cannot_inherit_an_undefined_base_class___T_">112 cannot inherit an undefined base class '%T'</A>
<BR><A HREF="#113_repeated_direct_base_class_will_cause_ambiguities">113 repeated direct base class will cause ambiguities</A>
<BR><A HREF="#114_templates_may_only_be_declared_in_namespace_scope">114 templates may only be declared in namespace scope</A>
<BR><A HREF="#115_linkages_may_only_be_declared_in_file_scope">115 linkages may only be declared in file scope</A>
<BR><A HREF="#116_unknown_linkage___s_">116 unknown linkage '%s'</A>
<BR><A HREF="#117_too_many_storage_class_specifiers">117 too many storage class specifiers</A>
<BR><A HREF="#118_nameless_declaration_is_not_allowed">118 nameless declaration is not allowed</A>
<BR><A HREF="#119_illegal_combination_of_type_specifiers">119 illegal combination of type specifiers</A>
<BR><A HREF="#120_illegal_combination_of_type_qualifiers">120 illegal combination of type qualifiers</A>
<BR><A HREF="#121_syntax_error">121 syntax error</A>
<BR><A HREF="#122_parser_stack_corrupted">122 parser stack corrupted</A>
<BR><A HREF="#123_template_declarations_cannot_be_nested_within_each_other">123 template declarations cannot be nested within each other</A>
<BR><A HREF="#124_expression_is_too_complicated">124 expression is too complicated</A>
<BR><A HREF="#125_invalid_redefinition_of_the_typedef_name___S_">125 invalid redefinition of the typedef name '%S'</A>
<BR><A HREF="#126_class___T__has_already_been_defined">126 class '%T' has already been defined</A>
<BR><A HREF="#127__sizeof__is_not_allowed_for_an_undefined_type">127 'sizeof' is not allowed for an undefined type</A>
<BR><A HREF="#128_initializer_for_variable___S__cannot_be_bypassed">128 initializer for variable '%S' cannot be bypassed</A>
<BR><A HREF="#129_division_by_zero_in_a_constant_expression">129 division by zero in a constant expression</A>
<BR><A HREF="#130_arithmetic_overflow_in_a_constant_expression">130 arithmetic overflow in a constant expression</A>
<BR><A HREF="#131_not_enough_memory_to_fully_optimize_procedure___s_">131 not enough memory to fully optimize procedure '%s'</A>
<BR><A HREF="#132_not_enough_memory_to_maintain_full_peephole">132 not enough memory to maintain full peephole</A>
<BR><A HREF="#133_too_many_errors__compilation_aborted">133 too many errors:&nbsp; compilation aborted</A>
<BR><A HREF="#134_too_many_parm_sets">134 too many parm sets</A>
<BR><A HREF="#135__friend____virtual__or__inline__modifiers_may_only_be_used_on_functions">135 'friend', 'virtual' or 'inline' modifiers may only be used on functions</A>
<BR><A HREF="#136_more_than_one_calling_convention_has_been_specified">136 more than one calling convention has been specified</A>
<BR><A HREF="#137_pure_member_function_constant_must_be__0_">137 pure member function constant must be '0'</A>
<BR><A HREF="#138_based_modifier_has_been_repeated">138 based modifier has been repeated</A>
<BR><A HREF="#139_enumeration_variable_is_not_assigned_a_constant_from_its_enumeration">139 enumeration variable is not assigned a constant from its enumeration</A>
<BR><A HREF="#140_bitMfield_declaration_cannot_have_a_storage_class_specifier">140 bit-field declaration cannot have a storage class specifier</A>
<BR><A HREF="#141_bitMfield_declaration_must_have_a_base_type_specified">141 bit-field declaration must have a base type specified</A>
<BR><A HREF="#142_illegal_qualification_of_a_bitMfield_declaration">142 illegal qualification of a bit-field declaration</A>
<BR><A HREF="#143_duplicate_base_qualifier">143 duplicate base qualifier</A>
<BR><A HREF="#144_only_one_access_specifier_is_allowed">144 only one access specifier is allowed</A>
<BR><A HREF="#145_unexpected_type_qualifier_found">145 unexpected type qualifier found</A>
<BR><A HREF="#146_unexpected_storage_class_specifier_found">146 unexpected storage class specifier found</A>
<BR><A HREF="#147_access_to___S__is_not_allowed_because_it_is_ambiguous">147 access to '%S' is not allowed because it is ambiguous</A>
<BR><A HREF="#148_access_to_private_member___S__is_not_allowed">148 access to private member '%S' is not allowed</A>
<BR><A HREF="#149_access_to_protected_member___S__is_not_allowed">149 access to protected member '%S' is not allowed</A>
<BR><A HREF="#150_operation_does_not_allow_both_operands_to_be_pointers">150 operation does not allow both operands to be pointers</A>
<BR><A HREF="#151_operand_is_neither_a_pointer_nor_an_arithmetic_type">151 operand is neither a pointer nor an arithmetic type</A>
<BR><A HREF="#152_left_operand_is_neither_a_pointer_nor_an_arithmetic_type">152 left operand is neither a pointer nor an arithmetic type</A>
<BR><A HREF="#153_right_operand_is_neither_a_pointer_nor_an_arithmetic_type">153 right operand is neither a pointer nor an arithmetic type</A>
<BR><A HREF="#154_cannot_subtract_a_pointer_from_an_arithmetic_operand">154 cannot subtract a pointer from an arithmetic operand</A>
<BR><A HREF="#155_left_expression_must_be_arithmetic">155 left expression must be arithmetic</A>
<BR><A HREF="#156_right_expression_must_be_arithmetic">156 right expression must be arithmetic</A>
<BR><A HREF="#157_left_expression_must_be_integral">157 left expression must be integral</A>
<BR><A HREF="#158_right_expression_must_be_integral">158 right expression must be integral</A>
<BR><A HREF="#159_cannot_assign_a_pointer_value_to_an_arithmetic_item">159 cannot assign a pointer value to an arithmetic item</A>
<BR><A HREF="#160_attempt_to_destroy_a_far_object_when_the_data_model_is_near">160 attempt to destroy a far object when the data model is near</A>
<BR><A HREF="#161_attempt_to_call_member_function_for_far_object_when_the_data_model_is_near">161 attempt to call member function for far object when the data model is near</A>
<BR><A HREF="#162_template_type_argument_cannot_have_a_default_argument">162 template type argument cannot have a default argument</A>
<BR><A HREF="#163_attempt_to_delete_a_far_object_when_the_data_model_is_near">163 attempt to delete a far object when the data model is near</A>
<BR><A HREF="#164_first_operand_is_not_a_class__struct_or_union">164 first operand is not a class, struct or union</A>
<BR><A HREF="#165_syntax_error__class_template_cannot_be_processed">165 syntax error:&nbsp; class template cannot be processed</A>
<BR><A HREF="#166_cannot_convert_right_pointer_to_type_of_left_operand">166 cannot convert right pointer to type of left operand</A>
<BR><A HREF="#167_left_operand_must_be_an_lvalue">167 left operand must be an lvalue</A>
<BR><A HREF="#168_static_data_members_are_not_allowed_in_an_union">168 static data members are not allowed in an union</A>
<BR><A HREF="#169_invalid_storage_class_for_a_member">169 invalid storage class for a member</A>
<BR><A HREF="#170_declaration_is_too_complicated">170 declaration is too complicated</A>
<BR><A HREF="#171_exception_declaration_is_too_complicated">171 exception declaration is too complicated</A>
<BR><A HREF="#172_floatingMpoint_constant_too_large_to_represent">172 floating-point constant too large to represent</A>
<BR><A HREF="#173_floatingMpoint_constant_too_small_to_represent">173 floating-point constant too small to represent</A>
<BR><A HREF="#174_class_template___M__cannot_be_overloaded">174 class template '%M' cannot be overloaded</A>
<BR><A HREF="#175_range_of_enum_constants_cannot_be_represented">175 range of enum constants cannot be represented</A>
<BR><A HREF="#176___S__cannot_be_in_the_same_scope_as_a_class_template">176 '%S' cannot be in the same scope as a class template</A>
<BR><A HREF="#177_invalid_storage_class_in_file_scope">177 invalid storage class in file scope</A>
<BR><A HREF="#178_const_object_must_be_initialized">178 const object must be initialized</A>
<BR><A HREF="#179_declaration_cannot_be_in_the_same_scope_as_class_template___S_">179 declaration cannot be in the same scope as class template '%S'</A>
<BR><A HREF="#180_template_arguments_must_be_named">180 template arguments must be named</A>
<BR><A HREF="#181_class_template___M__is_already_defined">181 class template '%M' is already defined</A>
<BR><A HREF="#182_invalid_storage_class_for_an_argument">182 invalid storage class for an argument</A>
<BR><A HREF="#183_unions_cannot_have_members_with_constructors">183 unions cannot have members with constructors</A>
<BR><A HREF="#184_statement_is_too_complicated">184 statement is too complicated</A>
<BR><A HREF="#185___s__is_not_the_name_of_a_class_or_namespace">185 '%s' is not the name of a class or namespace</A>
<BR><A HREF="#186_attempt_to_modify_a_constant_value">186 attempt to modify a constant value</A>
<BR><A HREF="#187__offsetof__is_not_allowed_for_a_bitMfield">187 'offsetof' is not allowed for a bit-field</A>
<BR><A HREF="#188_base_class_is_inherited_with_private_access">188 base class is inherited with private access</A>
<BR><A HREF="#189_overloaded_function_cannot_be_selected_for_arguments_used_in_call">189 overloaded function cannot be selected for arguments used in call</A>
<BR><A HREF="#190_base_operator_operands_must_be_____segment__Y_pointer__">190 base operator operands must be &quot; __segment :&gt; pointer &quot;</A>
<BR><A HREF="#191_expression_must_be_a_pointer_or_a_zero_constant">191 expression must be a pointer or a zero constant</A>
<BR><A HREF="#192_left_expression_pointer_type_cannot_be_incremented_or_decremented">192 left expression pointer type cannot be incremented or decremented</A>
<BR><A HREF="#193_right_expression_pointer_type_cannot_be_incremented_or_decremented">193 right expression pointer type cannot be incremented or decremented</A>
<BR><A HREF="#194_expression_pointer_type_cannot_be_incremented_or_decremented">194 expression pointer type cannot be incremented or decremented</A>
<BR><A HREF="#195__sizeof__is_not_allowed_for_a_function">195 'sizeof' is not allowed for a function</A>
<BR><A HREF="#196__sizeof__is_not_allowed_for_type_void">196 'sizeof' is not allowed for type void</A>
<BR><A HREF="#197_type_cannot_be_defined_in_this_context">197 type cannot be defined in this context</A>
<BR><A HREF="#198_expression_cannot_be_used_as_a_class_template_parameter">198 expression cannot be used as a class template parameter</A>
<BR><A HREF="#199_premature_endMofMfile_encountered_during_compilation">199 premature end-of-file encountered during compilation</A>
<DT>- 2 -
<DD><A HREF="#200_duplicate_case_value___s__after_conversion_to_type_of_switch_expression">200 duplicate case value '%s' after conversion to type of switch expression</A>
<BR><A HREF="#201_declaration_statement_follows_an_if_statement">201 declaration statement follows an if statement</A>
<BR><A HREF="#202_declaration_statement_follows_an_else_statement">202 declaration statement follows an else statement</A>
<BR><A HREF="#203_declaration_statement_follows_a_switch_statement">203 declaration statement follows a switch statement</A>
<BR><A HREF="#204__this__pointer_is_not_defined">204 'this' pointer is not defined</A>
<BR><A HREF="#205_declaration_statement_cannot_follow_a_while_statement">205 declaration statement cannot follow a while statement</A>
<BR><A HREF="#206_declaration_statement_cannot_follow_a_do_statement">206 declaration statement cannot follow a do statement</A>
<BR><A HREF="#207_declaration_statement_cannot_follow_a_for_statement">207 declaration statement cannot follow a for statement</A>
<BR><A HREF="#208_pointer_to_virtual_base_class_converted_to_pointer_to_derived_class">208 pointer to virtual base class converted to pointer to derived class</A>
<BR><A HREF="#209_cannot_use_far_pointer_in_this_context">209 cannot use far pointer in this context</A>
<BR><A HREF="#210_returning_reference_to_function_argument_or_to_auto_or_register_variable">210 returning reference to function argument or to auto or register variable</A>
<BR><A HREF="#211__pragma_attributes_for___S__may_be_inconsistent">211 #pragma attributes for '%S' may be inconsistent</A>
<BR><A HREF="#212_function_arguments_cannot_be_of_type_void">212 function arguments cannot be of type void</A>
<BR><A HREF="#213_class_template___M__requires_more_parameters_for_instantiation">213 class template '%M' requires more parameters for instantiation</A>
<BR><A HREF="#214_class_template___M__requires_fewer_parameters_for_instantiation">214 class template '%M' requires fewer parameters for instantiation</A>
<BR><A HREF="#215_no_declared__operator_new__has_arguments_that_match">215 no declared 'operator new' has arguments that match</A>
<BR><A HREF="#216_wide_character_string_concatenated_with_a_simple_character_string">216 wide character string concatenated with a simple character string</A>
<BR><A HREF="#217__offsetof__is_not_allowed_for_a_static_member">217 'offsetof' is not allowed for a static member</A>
<BR><A HREF="#218_cannot_define_an_array_of_void">218 cannot define an array of void</A>
<BR><A HREF="#219_cannot_define_an_array_of_references">219 cannot define an array of references</A>
<BR><A HREF="#220_cannot_define_a_reference_to_void">220 cannot define a reference to void</A>
<BR><A HREF="#221_cannot_define_a_reference_to_another_reference">221 cannot define a reference to another reference</A>
<BR><A HREF="#222_cannot_define_a_pointer_to_a_reference">222 cannot define a pointer to a reference</A>
<BR><A HREF="#223_cannot_initialize_array_with__operator_new_">223 cannot initialize array with 'operator new'</A>
<BR><A HREF="#224___N__is_a_variable_of_type_void">224 '%N' is a variable of type void</A>
<BR><A HREF="#225_cannot_define_a_member_pointer_to_a_reference">225 cannot define a member pointer to a reference</A>
<BR><A HREF="#226_function___S__is_not_distinct">226 function '%S' is not distinct</A>
<BR><A HREF="#227_overloaded_function_is_ambiguous_for_arguments_used_in_call">227 overloaded function is ambiguous for arguments used in call</A>
<BR><A HREF="#228_declared__operator_new__is_ambiguous_for_arguments_used">228 declared 'operator new' is ambiguous for arguments used</A>
<BR><A HREF="#229_function___S__has_already_been_defined">229 function '%S' has already been defined</A>
<BR><A HREF="#230_expression_on_left_is_an_array">230 expression on left is an array</A>
<BR><A HREF="#231_userMdefined_conversion_has_a_return_type">231 user-defined conversion has a return type</A>
<BR><A HREF="#232_userMdefined_conversion_must_be_a_function">232 user-defined conversion must be a function</A>
<BR><A HREF="#233_userMdefined_conversion_has_an_argument_list">233 user-defined conversion has an argument list</A>
<BR><A HREF="#234_destructor_cannot_have_a_return_type">234 destructor cannot have a return type</A>
<BR><A HREF="#235_destructor_must_be_a_function">235 destructor must be a function</A>
<BR><A HREF="#236_destructor_has_an_argument_list">236 destructor has an argument list</A>
<BR><A HREF="#237___N__must_be_a_function">237 '%N' must be a function</A>
<BR><A HREF="#238___N__is_not_a_function">238 '%N' is not a function</A>
<BR><A HREF="#239_nested_type_class___s__has_not_been_declared">239 nested type class '%s' has not been declared</A>
<BR><A HREF="#240_enum___s__has_not_been_declared">240 enum '%s' has not been declared</A>
<BR><A HREF="#241_class_or_namespace___s__has_not_been_declared">241 class or namespace '%s' has not been declared</A>
<BR><A HREF="#242_only_one_initializer_argument_allowed">242 only one initializer argument allowed</A>
<BR><A HREF="#243_default_arguments_are_not_part_of_a_function_s_type">243 default arguments are not part of a function's type</A>
<BR><A HREF="#244_missing_default_arguments">244 missing default arguments</A>
<BR><A HREF="#245_overloaded_operator_cannot_have_default_arguments">245 overloaded operator cannot have default arguments</A>
<BR><A HREF="#246_left_expression_is_not_a_pointer_to_a_constant_object">246 left expression is not a pointer to a constant object</A>
<BR><A HREF="#247_cannot_redefine_default_argument_for___S_">247 cannot redefine default argument for '%S'</A>
<BR><A HREF="#248_using_default_arguments_would_be_overload_ambiguous_with___S_">248 using default arguments would be overload ambiguous with '%S'</A>
<BR><A HREF="#249_using_default_arguments_would_be_overload_ambiguous_with___S__using_default_arguments">249 using default arguments would be overload ambiguous with '%S' using default arguments</A>
<BR><A HREF="#250_missing_default_argument_for___S_">250 missing default argument for '%S'</A>
<BR><A HREF="#251_enum_references_must_have_an_identifier">251 enum references must have an identifier</A>
<BR><A HREF="#252_class_declaration_has_not_been_seen_for____s_">252 class declaration has not been seen for '%s'</A>
<BR><A HREF="#253______qualifier_cannot_be_used_in_this_context">253 '::' qualifier cannot be used in this context</A>
<BR><A HREF="#254___S__has_not_been_declared_as_a_member">254 '%S' has not been declared as a member</A>
<BR><A HREF="#255_default_argument_expression_cannot_use_function_argument___S_">255 default argument expression cannot use function argument '%S'</A>
<BR><A HREF="#256_default_argument_expression_cannot_use_local_variable___S_">256 default argument expression cannot use local variable '%S'</A>
<BR><A HREF="#257_access_declarations_may_only_be__public__or__protected_">257 access declarations may only be 'public' or 'protected'</A>
<BR><A HREF="#258_cannot_declare_both_a_function_and_variable_of_the_same_name_L__N_R">258 cannot declare both a function and variable of the same name ('%N')</A>
<BR><A HREF="#259_class_in_access_declaration_L__T_R_must_be_a_direct_base_class">259 class in access declaration ('%T') must be a direct base class</A>
<BR><A HREF="#260_overloaded_functions_L__N_R_do_not_have_the_same_access">260 overloaded functions ('%N') do not have the same access</A>
<BR><A HREF="#261_cannot_grant_access_to___N_">261 cannot grant access to '%N'</A>
<BR><A HREF="#262_cannot_reduce_access_to___N_">262 cannot reduce access to '%N'</A>
<BR><A HREF="#263_nested_class___N__has_not_been_defined">263 nested class '%N' has not been defined</A>
<BR><A HREF="#264_userMdefined_conversion_must_be_a_nonMstatic_member_function">264 user-defined conversion must be a non-static member function</A>
<BR><A HREF="#265_destructor_must_be_a_nonMstatic_member_function">265 destructor must be a non-static member function</A>
<BR><A HREF="#266___N__must_be_a_nonMstatic_member_function">266 '%N' must be a non-static member function</A>
<BR><A HREF="#267___N__must_have_one_argument">267 '%N' must have one argument</A>
<BR><A HREF="#268___N__must_have_two_arguments">268 '%N' must have two arguments</A>
<BR><A HREF="#269___N__must_have_either_one_argument_or_two_arguments">269 '%N' must have either one argument or two arguments</A>
<BR><A HREF="#270___N__must_have_at_least_one_argument">270 '%N' must have at least one argument</A>
<BR><A HREF="#271___N__must_have_a_return_type_of_void">271 '%N' must have a return type of void</A>
<BR><A HREF="#272___N__must_have_a_return_type_of_pointer_to_void">272 '%N' must have a return type of pointer to void</A>
<BR><A HREF="#273_the_first_argument_of___N__must_be_of_type_size_t">273 the first argument of '%N' must be of type size_t</A>
<BR><A HREF="#274_the_first_argument_of___N__must_be_of_type_pointer_to_void">274 the first argument of '%N' must be of type pointer to void</A>
<BR><A HREF="#275_the_second_argument_of___N__must_be_of_type_size_t">275 the second argument of '%N' must be of type size_t</A>
<BR><A HREF="#276_the_second_argument_of__operator_PP__or__operator_MM__must_be_int">276 the second argument of 'operator ++' or 'operator --' must be int</A>
<BR><A HREF="#277_return_type_of___S__must_allow_the__MY__operator_to_be_applied">277 return type of '%S' must allow the '-&gt;' operator to be applied</A>
<BR><A HREF="#278___N__must_take_at_least_one_argument_of_a_classDenum_or_a_reference_to_a_classDenum">278 '%N' must take at least one argument of a class/enum or a reference to a class/enum</A>
<BR><A HREF="#279_too_many_initializers">279 too many initializers</A>
<BR><A HREF="#280_too_many_initializers_for_character_string">280 too many initializers for character string</A>
<BR><A HREF="#281_expecting___s__but_found_expression">281 expecting '%s' but found expression</A>
<BR><A HREF="#282_anonymous_structDunion_member___N__cannot_be_declared_in_this_class">282 anonymous struct/union member '%N' cannot be declared in this class</A>
<BR><A HREF="#283_unexpected___s__during_initialization">283 unexpected '%s' during initialization</A>
<BR><A HREF="#284_nested_type___N__cannot_be_declared_in_this_class">284 nested type '%N' cannot be declared in this class</A>
<BR><A HREF="#285_enumerator___N__cannot_be_declared_in_this_class">285 enumerator '%N' cannot be declared in this class</A>
<BR><A HREF="#286_static_member___N__cannot_be_declared_in_this_class">286 static member '%N' cannot be declared in this class</A>
<BR><A HREF="#287_constructor_cannot_have_a_return_type">287 constructor cannot have a return type</A>
<BR><A HREF="#288_constructor_cannot_be_a_static_member">288 constructor cannot be a static member</A>
<BR><A HREF="#289_invalid_copy_constructor_argument_list_Lcauses_infinite_recursionR">289 invalid copy constructor argument list (causes infinite recursion)</A>
<BR><A HREF="#290_constructor_cannot_be_declared_const_or_volatile">290 constructor cannot be declared const or volatile</A>
<BR><A HREF="#291_constructor_cannot_be_virtual">291 constructor cannot be virtual</A>
<BR><A HREF="#292_types_do_not_match_in_simple_type_destructor">292 types do not match in simple type destructor</A>
<BR><A HREF="#293_overloaded_operator_is_ambiguous_for_operands_used">293 overloaded operator is ambiguous for operands used</A>
<BR><A HREF="#294_feature_not_implemented">294 feature not implemented</A>
<BR><A HREF="#295_invalid_friend_declaration">295 invalid friend declaration</A>
<BR><A HREF="#296_friend_declarations_may_only_be_declared_in_a_class">296 friend declarations may only be declared in a class</A>
<BR><A HREF="#297_class_friend_declaration_needs__class__or__struct__keyword">297 class friend declaration needs 'class' or 'struct' keyword</A>
<BR><A HREF="#298_class_friend_declarations_cannot_contain_a_class_definition">298 class friend declarations cannot contain a class definition</A>
<BR><A HREF="#299___T__has_already_been_declared_as_a_friend">299 '%T' has already been declared as a friend</A>
<DT>- 3 -
<DD><A HREF="#300_function___S__has_already_been_declared_as_a_friend">300 function '%S' has already been declared as a friend</A>
<BR><A HREF="#301__friend____virtual__or__inline__modifiers_are_not_part_of_a_function_s_type">301 'friend', 'virtual' or 'inline' modifiers are not part of a function's type</A>
<BR><A HREF="#302_cannot_assign_right_expression_to_element_on_left">302 cannot assign right expression to element on left</A>
<BR><A HREF="#303_constructor_is_ambiguous_for_operands_used">303 constructor is ambiguous for operands used</A>
<BR><A HREF="#304_class___s__has_not_been_defined">304 class '%s' has not been defined</A>
<BR><A HREF="#305_all_bitMfields_in_a_union_must_be_named">305 all bit-fields in a union must be named</A>
<BR><A HREF="#306_cannot_convert_expression_to_type_of_cast">306 cannot convert expression to type of cast</A>
<BR><A HREF="#307_conversion_ambiguity__UexpressionV_to_Ucast_typeV">307 conversion ambiguity:&nbsp; [expression] to [cast type]</A>
<BR><A HREF="#308_an_anonymous_class_without_a_declarator_is_useless">308 an anonymous class without a declarator is useless</A>
<BR><A HREF="#309_global_anonymous_union_must_be_declared_static">309 global anonymous union must be declared static</A>
<BR><A HREF="#310_anonymous_structDunion_cannot_have_storage_class_in_this_context">310 anonymous struct/union cannot have storage class in this context</A>
<BR><A HREF="#311_union_contains_a_protected_member">311 union contains a protected member</A>
<BR><A HREF="#312_anonymous_structDunion_contains_a_private_member___S_">312 anonymous struct/union contains a private member '%S'</A>
<BR><A HREF="#313_anonymous_structDunion_contains_a_function_member___S_">313 anonymous struct/union contains a function member '%S'</A>
<BR><A HREF="#314_anonymous_structDunion_contains_a_typedef_member___S_">314 anonymous struct/union contains a typedef member '%S'</A>
<BR><A HREF="#315_anonymous_structDunion_contains_an_enumeration_member___S_">315 anonymous struct/union contains an enumeration member '%S'</A>
<BR><A HREF="#316_anonymous_structDunion_member___s__is_not_distinct_in_enclosing_scope">316 anonymous struct/union member '%s' is not distinct in enclosing scope</A>
<BR><A HREF="#317_unions_cannot_have_members_with_destructors">317 unions cannot have members with destructors</A>
<BR><A HREF="#318_unions_cannot_have_members_with_userMdefined_assignment_operators">318 unions cannot have members with user-defined assignment operators</A>
<BR><A HREF="#319_anonymous_structDunion_cannot_have_any_friends">319 anonymous struct/union cannot have any friends</A>
<BR><A HREF="#320_specific_versions_of_template_classes_can_only_be_defined_in_file_scope">320 specific versions of template classes can only be defined in file scope</A>
<BR><A HREF="#321_anonymous_union_in_a_function_may_only_be_static_or_auto">321 anonymous union in a function may only be static or auto</A>
<BR><A HREF="#322_static_data_members_are_not_allowed_in_a_local_class">322 static data members are not allowed in a local class</A>
<BR><A HREF="#323_conversion_ambiguity__Ureturn_valueV_to_Ureturn_type_of_functionV">323 conversion ambiguity:&nbsp; [return value] to [return type of function]</A>
<BR><A HREF="#324_conversion_of_return_value_is_impossible">324 conversion of return value is impossible</A>
<BR><A HREF="#325_function_cannot_return_a_pointer_based_on___self">325 function cannot return a pointer based on __self</A>
<BR><A HREF="#326_defining___S__is_not_possible_because_its_type_has_unknown_size">326 defining '%S' is not possible because its type has unknown size</A>
<BR><A HREF="#327_typedef_cannot_be_initialized">327 typedef cannot be initialized</A>
<BR><A HREF="#328_storage_class_of___S__conflicts_with_previous_declaration">328 storage class of '%S' conflicts with previous declaration</A>
<BR><A HREF="#329_modifiers_of___S__conflict_with_previous_declaration">329 modifiers of '%S' conflict with previous declaration</A>
<BR><A HREF="#330_function_cannot_be_initialized">330 function cannot be initialized</A>
<BR><A HREF="#331_access_permission_of_nested_class___T__conflicts_with_previous_declaration">331 access permission of nested class '%T' conflicts with previous declaration</A>
<BR><A HREF="#332_TTT_FATAL_TTT_internal_error_in_front_end">332 *** FATAL *** internal error in front end</A>
<BR><A HREF="#333_cannot_convert_argument_to_type_specified_in_function_prototype">333 cannot convert argument to type specified in function prototype</A>
<BR><A HREF="#334_conversion_ambiguity__UargumentV_to_Uargument_type_in_prototypeV">334 conversion ambiguity:&nbsp; [argument] to [argument type in prototype]</A>
<BR><A HREF="#335_cannot_be_based_on_based_pointer___S_">335 cannot be based on based pointer '%S'</A>
<BR><A HREF="#336_declaration_specifiers_are_required_to_declare___N_">336 declaration specifiers are required to declare '%N'</A>
<BR><A HREF="#337_static_function_declared_in_block_scope">337 static function declared in block scope</A>
<BR><A HREF="#338_cannot_define_a___based_reference">338 cannot define a __based reference</A>
<BR><A HREF="#339_conversion_ambiguity__conversion_to_common_pointer_type">339 conversion ambiguity:&nbsp; conversion to common pointer type</A>
<BR><A HREF="#340_cannot_construct_object_from_argumentLsR">340 cannot construct object from argument(s)</A>
<BR><A HREF="#341_number_of_arguments_for_function___S__is_incorrect">341 number of arguments for function '%S' is incorrect</A>
<BR><A HREF="#342_private_base_class_accessed_to_convert_cast_expression">342 private base class accessed to convert cast expression</A>
<BR><A HREF="#343_private_base_class_accessed_to_convert_return_expression">343 private base class accessed to convert return expression</A>
<BR><A HREF="#344_cannot_subtract_pointers_to_different_objects">344 cannot subtract pointers to different objects</A>
<BR><A HREF="#345_private_base_class_accessed_to_convert_to_common_pointer_type">345 private base class accessed to convert to common pointer type</A>
<BR><A HREF="#346_protected_base_class_accessed_to_convert_cast_expression">346 protected base class accessed to convert cast expression</A>
<BR><A HREF="#347_protected_base_class_accessed_to_convert_return_expression">347 protected base class accessed to convert return expression</A>
<BR><A HREF="#348_cannot_define_a_member_pointer_with_a_memory_model_modifier">348 cannot define a member pointer with a memory model modifier</A>
<BR><A HREF="#349_protected_base_class_accessed_to_convert_to_common_pointer_type">349 protected base class accessed to convert to common pointer type</A>
<BR><A HREF="#350_nonMtype_parameter_supplied_for_a_type_argument">350 non-type parameter supplied for a type argument</A>
<BR><A HREF="#351_type_parameter_supplied_for_a_nonMtype_argument">351 type parameter supplied for a non-type argument</A>
<BR><A HREF="#352_cannot_access_enclosing_function_s_auto_variable___S_">352 cannot access enclosing function's auto variable '%S'</A>
<BR><A HREF="#353_cannot_initialize_pointer_to_nonMconstant_with_a_pointer_to_constant">353 cannot initialize pointer to non-constant with a pointer to constant</A>
<BR><A HREF="#354_pointer_expression_is_always_YE_0">354 pointer expression is always &gt;= 0</A>
<BR><A HREF="#355_pointer_expression_is_never_X_0">355 pointer expression is never &lt; 0</A>
<BR><A HREF="#356_type_cannot_be_used_in_this_context">356 type cannot be used in this context</A>
<BR><A HREF="#357_virtual_function_may_only_be_declared_in_a_class">357 virtual function may only be declared in a class</A>
<BR><A HREF="#358___T__referenced_as_a_union">358 '%T' referenced as a union</A>
<BR><A HREF="#359_union___T__referenced_as_a_class">359 union '%T' referenced as a class</A>
<BR><A HREF="#360_typedef___N__defined_without_an_explicit_type">360 typedef '%N' defined without an explicit type</A>
<BR><A HREF="#361_member_function_was_not_defined_in_its_class">361 member function was not defined in its class</A>
<BR><A HREF="#362_local_class_can_only_have_its_containing_function_as_a_friend">362 local class can only have its containing function as a friend</A>
<BR><A HREF="#363_local_class_cannot_have___S__as_a_friend">363 local class cannot have '%S' as a friend</A>
<BR><A HREF="#364_adjacent_YE__XE__Y__X_operators">364 adjacent &gt;=, &lt;=, &gt;, &lt; operators</A>
<BR><A HREF="#365_cannot_access_enclosing_function_s_argument___S_">365 cannot access enclosing function's argument '%S'</A>
<BR><A HREF="#366_support_for_switch___s__is_not_implemented">366 support for switch '%s' is not implemented</A>
<BR><A HREF="#367_conditional_expression_in_if_statement_is_always_true">367 conditional expression in if statement is always true</A>
<BR><A HREF="#368_conditional_expression_in_if_statement_is_always_false">368 conditional expression in if statement is always false</A>
<BR><A HREF="#369_selection_expression_in_switch_statement_is_a_constant_value">369 selection expression in switch statement is a constant value</A>
<BR><A HREF="#370_constructor_is_required_for_a_class_with_a_const_member">370 constructor is required for a class with a const member</A>
<BR><A HREF="#371_constructor_is_required_for_a_class_with_a_reference_member">371 constructor is required for a class with a reference member</A>
<BR><A HREF="#372_inline_member_friend_function___S__is_not_allowed">372 inline member friend function '%S' is not allowed</A>
<BR><A HREF="#373_invalid_modifier_for_auto_variable">373 invalid modifier for auto variable</A>
<BR><A HREF="#374_object_Lor_object_pointerR_required_to_access_nonMstatic_data_member">374 object (or object pointer) required to access non-static data member</A>
<BR><A HREF="#375_userMdefined_conversion_has_not_been_declared">375 user-defined conversion has not been declared</A>
<BR><A HREF="#376_virtual_function_must_be_a_nonMstatic_member_function">376 virtual function must be a non-static member function</A>
<BR><A HREF="#377_protected_base_class_accessed_to_convert_argument_expression">377 protected base class accessed to convert argument expression</A>
<BR><A HREF="#378_private_base_class_accessed_to_convert_argument_expression">378 private base class accessed to convert argument expression</A>
<BR><A HREF="#379_delete_expression_will_invoke_a_nonMvirtual_destructor">379 delete expression will invoke a non-virtual destructor</A>
<BR><A HREF="#380__offsetof__is_not_allowed_for_a_function">380 'offsetof' is not allowed for a function</A>
<BR><A HREF="#381__offsetof__is_not_allowed_for_an_enumeration">381 'offsetof' is not allowed for an enumeration</A>
<BR><A HREF="#382_could_not_initialize_for_code_generation">382 could not initialize for code generation</A>
<BR><A HREF="#383__offsetof__is_not_allowed_for_an_undefined_type">383 'offsetof' is not allowed for an undefined type</A>
<BR><A HREF="#384_attempt_to_override_virtual_function___S__with_a_different_return_type">384 attempt to override virtual function '%S' with a different return type</A>
<BR><A HREF="#385_attempt_to_overload_function___S__with_a_different_return_type">385 attempt to overload function '%S' with a different return type</A>
<BR><A HREF="#386_attempt_to_use_pointer_to_undefined_class">386 attempt to use pointer to undefined class</A>
<BR><A HREF="#387_expression_is_useful_only_for_its_side_effects">387 expression is useful only for its side effects</A>
<BR><A HREF="#388_integral_constant_will_be_truncated_during_assignment_or_initialization">388 integral constant will be truncated during assignment or initialization</A>
<BR><A HREF="#389_integral_value_may_be_truncated_during_assignment_or_initialization">389 integral value may be truncated during assignment or initialization</A>
<BR><A HREF="#390_cannot_generate_default_constructor_to_initialize___T__since_constructors_were_declared">390 cannot generate default constructor to initialize '%T' since constructors were declared</A>
<BR><A HREF="#391_assignment_found_in_boolean_expression">391 assignment found in boolean expression</A>
<BR><A HREF="#392_definition____F_">392 definition:&nbsp; '%F'</A>
<BR><A HREF="#393_included_from__sL_uR">393 included from %s(%u)</A>
<BR><A HREF="#394_reference_object_must_be_initialized">394 reference object must be initialized</A>
<BR><A HREF="#395_option_requires_an_identifier">395 option requires an identifier</A>
<BR><A HREF="#396__main__cannot_be_overloaded">396 'main' cannot be overloaded</A>
<BR><A HREF="#397__new__expression_cannot_allocate_a_void">397 'new' expression cannot allocate a void</A>
<BR><A HREF="#398__new__expression_cannot_allocate_a_function">398 'new' expression cannot allocate a function</A>
<BR><A HREF="#399__new__expression_allocates_a_const_or_volatile_object">399 'new' expression allocates a const or volatile object</A>
<DT>- 4 -
<DD><A HREF="#400_cannot_convert_right_expression_for_initialization">400 cannot convert right expression for initialization</A>
<BR><A HREF="#401_conversion_ambiguity__Uinitialization_expressionV_to_Utype_of_objectV">401 conversion ambiguity:&nbsp; [initialization expression] to [type of object]</A>
<BR><A HREF="#402_class_template___S__has_already_been_declared_as_a_friend">402 class template '%S' has already been declared as a friend</A>
<BR><A HREF="#403_private_base_class_accessed_to_convert_initialization_expression">403 private base class accessed to convert initialization expression</A>
<BR><A HREF="#404_protected_base_class_accessed_to_convert_initialization_expression">404 protected base class accessed to convert initialization expression</A>
<BR><A HREF="#405_cannot_return_a_pointer_or_reference_to_a_constant_object">405 cannot return a pointer or reference to a constant object</A>
<BR><A HREF="#406_cannot_pass_a_pointer_or_reference_to_a_constant_object">406 cannot pass a pointer or reference to a constant object</A>
<BR><A HREF="#407_class_templates_must_be_named">407 class templates must be named</A>
<BR><A HREF="#408_function_templates_can_only_name_functions">408 function templates can only name functions</A>
<BR><A HREF="#409_template_argument___S__is_not_used_in_the_function_argument_list">409 template argument '%S' is not used in the function argument list</A>
<BR><A HREF="#410_destructor_cannot_be_declared_const_or_volatile">410 destructor cannot be declared const or volatile</A>
<BR><A HREF="#411_static_member_function_cannot_be_declared_const_or_volatile">411 static member function cannot be declared const or volatile</A>
<BR><A HREF="#412_only_member_functions_can_be_declared_const_or_volatile">412 only member functions can be declared const or volatile</A>
<BR><A HREF="#413__const__or__volatile__modifiers_are_not_part_of_a_function_s_type">413 'const' or 'volatile' modifiers are not part of a function's type</A>
<BR><A HREF="#414_type_cannot_be_defined_in_an_argument">414 type cannot be defined in an argument</A>
<BR><A HREF="#415_type_cannot_be_defined_in_return_type">415 type cannot be defined in return type</A>
<BR><A HREF="#416_data_members_cannot_be_initialized_inside_a_class_definition">416 data members cannot be initialized inside a class definition</A>
<BR><A HREF="#417_only_virtual_functions_may_be_declared_pure">417 only virtual functions may be declared pure</A>
<BR><A HREF="#418_destructor_is_not_declared_in_its_proper_class">418 destructor is not declared in its proper class</A>
<BR><A HREF="#419_cannot_call_nonMconst_function_for_a_constant_object">419 cannot call non-const function for a constant object</A>
<BR><A HREF="#420_memory_initializer_list_may_only_appear_in_a_constructor_definition">420 memory initializer list may only appear in a constructor definition</A>
<BR><A HREF="#421_cannot_initialize_member___N__twice">421 cannot initialize member '%N' twice</A>
<BR><A HREF="#422_cannot_initialize_base_class___T__twice">422 cannot initialize base class '%T' twice</A>
<BR><A HREF="#423___T__is_not_a_direct_base_class">423 '%T' is not a direct base class</A>
<BR><A HREF="#424___N__cannot_be_initialized_because_it_is_not_a_member">424 '%N' cannot be initialized because it is not a member</A>
<BR><A HREF="#425___N__cannot_be_initialized_because_it_is_a_member_function">425 '%N' cannot be initialized because it is a member function</A>
<BR><A HREF="#426___N__cannot_be_initialized_because_it_is_a_static_member">426 '%N' cannot be initialized because it is a static member</A>
<BR><A HREF="#427___N__has_not_been_declared_as_a_member">427 '%N' has not been declared as a member</A>
<BR><A HREF="#428_constDreference_member___S__must_have_an_initializer">428 const/reference member '%S' must have an initializer</A>
<BR><A HREF="#429_abstract_class___T__cannot_be_used_as_an_argument_type">429 abstract class '%T' cannot be used as an argument type</A>
<BR><A HREF="#430_abstract_class___T__cannot_be_used_as_a_function_return_type">430 abstract class '%T' cannot be used as a function return type</A>
<BR><A HREF="#431_defining___S__is_not_possible_because___T__is_an_abstract_class">431 defining '%S' is not possible because '%T' is an abstract class</A>
<BR><A HREF="#432_cannot_convert_to_an_abstract_class___T_">432 cannot convert to an abstract class '%T'</A>
<BR><A HREF="#433_mangled_name_for___S__has_been_truncated">433 mangled name for '%S' has been truncated</A>
<BR><A HREF="#434_cannot_convert_to_a_type_of_unknown_size">434 cannot convert to a type of unknown size</A>
<BR><A HREF="#435_cannot_convert_a_type_of_unknown_size">435 cannot convert a type of unknown size</A>
<BR><A HREF="#436_cannot_construct_an_abstract_class">436 cannot construct an abstract class</A>
<BR><A HREF="#437_cannot_construct_an_undefined_class">437 cannot construct an undefined class</A>
<BR><A HREF="#438_string_literal_concatenated_during_array_initialization">438 string literal concatenated during array initialization</A>
<BR><A HREF="#439_maximum_size_of_segment___s__has_been_exceeded_for___S_">439 maximum size of segment '%s' has been exceeded for '%S'</A>
<BR><A HREF="#440_maximum_data_item_size_has_been_exceeded_for___S_">440 maximum data item size has been exceeded for '%S'</A>
<BR><A HREF="#441_function_attribute_has_been_repeated">441 function attribute has been repeated</A>
<BR><A HREF="#442_modifier_has_been_repeated">442 modifier has been repeated</A>
<BR><A HREF="#443_illegal_combination_of_memory_model_modifiers">443 illegal combination of memory model modifiers</A>
<BR><A HREF="#444_argument_name___N__has_already_been_used">444 argument name '%N' has already been used</A>
<BR><A HREF="#445_function_definition_for___S__must_be_declared_with_an_explicit_argument_list">445 function definition for '%S' must be declared with an explicit argument list</A>
<BR><A HREF="#446_userMdefined_conversion_cannot_convert_to_its_own_class_or_base_class">446 user-defined conversion cannot convert to its own class or base class</A>
<BR><A HREF="#447_userMdefined_conversion_cannot_convert_to_void">447 user-defined conversion cannot convert to void</A>
<BR><A HREF="#448_expecting_identifier">448 expecting identifier</A>
<BR><A HREF="#449_symbol___S__does_not_have_a_segment_associated_with_it">449 symbol '%S' does not have a segment associated with it</A>
<BR><A HREF="#450_symbol___S__must_have_integral_or_pointer_type">450 symbol '%S' must have integral or pointer type</A>
<BR><A HREF="#451_symbol___S__cannot_be_accessed_in_all_contexts">451 symbol '%S' cannot be accessed in all contexts</A>
<BR><A HREF="#452_cannot_convert_class_expression_to_be_copied">452 cannot convert class expression to be copied</A>
<BR><A HREF="#453_conversion_ambiguity__multiple_copy_constructors">453 conversion ambiguity:&nbsp; multiple copy constructors</A>
<BR><A HREF="#454_function_template___S__already_has_a_definition">454 function template '%S' already has a definition</A>
<BR><A HREF="#455_function_templates_cannot_have_default_arguments">455 function templates cannot have default arguments</A>
<BR><A HREF="#456__main__cannot_be_a_function_template">456 'main' cannot be a function template</A>
<BR><A HREF="#457___S__was_previously_declared_as_a_typedef">457 '%S' was previously declared as a typedef</A>
<BR><A HREF="#458___S__was_previously_declared_as_a_variableDfunction">458 '%S' was previously declared as a variable/function</A>
<BR><A HREF="#459_private_base_class_accessed_to_convert_assignment_expression">459 private base class accessed to convert assignment expression</A>
<BR><A HREF="#460_protected_base_class_accessed_to_convert_assignment_expression">460 protected base class accessed to convert assignment expression</A>
<BR><A HREF="#461_maximum_size_of_DGROUP_has_been_exceeded_for___S__in_segment___s_">461 maximum size of DGROUP has been exceeded for '%S' in segment '%s'</A>
<BR><A HREF="#462_type_of_return_value_is_not_the_enumeration_type_of_function">462 type of return value is not the enumeration type of function</A>
<BR><A HREF="#463_linkage_must_be_first_in_a_declarationS_probable_cause__missing__S_">463 linkage must be first in a declaration; probable cause:&nbsp; missing ';'</A>
<BR><A HREF="#464__main__cannot_be_a_static_function">464 'main' cannot be a static function</A>
<BR><A HREF="#465__main__cannot_be_an_inline_function">465 'main' cannot be an inline function</A>
<BR><A HREF="#466__main__cannot_be_referenced">466 'main' cannot be referenced</A>
<BR><A HREF="#467_cannot_call_a_nonMvolatile_function_for_a_volatile_object">467 cannot call a non-volatile function for a volatile object</A>
<BR><A HREF="#468_cannot_convert_pointer_to_constant_or_volatile_objects_to_pointer_to_void">468 cannot convert pointer to constant or volatile objects to pointer to void</A>
<BR><A HREF="#469_cannot_convert_pointer_to_constant_or_nonMvolatile_objects_to_pointer_to_volatile_void">469 cannot convert pointer to constant or non-volatile objects to pointer to volatile void</A>
<BR><A HREF="#470_address_of_function_is_too_large_to_be_converted_to_pointer_to_void">470 address of function is too large to be converted to pointer to void</A>
<BR><A HREF="#471_address_of_data_object_is_too_large_to_be_converted_to_pointer_to_void">471 address of data object is too large to be converted to pointer to void</A>
<BR><A HREF="#472_expression_with_side_effect_in_sizeof_discarded">472 expression with side effect in sizeof discarded</A>
<BR><A HREF="#473_function_argumentLsR_do_not_match_those_in_prototype">473 function argument(s) do not match those in prototype</A>
<BR><A HREF="#474_conversion_ambiguity__UexpressionV_to_Uclass_objectV">474 conversion ambiguity:&nbsp; [expression] to [class object]</A>
<BR><A HREF="#475_cannot_assign_right_expression_to_class_object">475 cannot assign right expression to class object</A>
<BR><A HREF="#476_argument_count_is__d_since_there_is_an_implicit__this__argument">476 argument count is %d since there is an implicit 'this' argument</A>
<BR><A HREF="#477_argument_count_is__d_since_there_is_no_implicit__this__argument">477 argument count is %d since there is no implicit 'this' argument</A>
<BR><A HREF="#478_argument_count_is__d_for_a_nonMmember_function">478 argument count is %d for a non-member function</A>
<BR><A HREF="#479_conversion_ambiguity__multiple_copy_constructors_to_copy_array___S_">479 conversion ambiguity:&nbsp; multiple copy constructors to copy array '%S'</A>
<BR><A HREF="#480_variableDfunction_has_the_same_name_as_the_classDenum___S_">480 variable/function has the same name as the class/enum '%S'</A>
<BR><A HREF="#481_classDenum_has_the_same_name_as_the_functionDvariable___S_">481 class/enum has the same name as the function/variable '%S'</A>
<BR><A HREF="#482_cannot_create_a_default_constructor">482 cannot create a default constructor</A>
<BR><A HREF="#483_attempting_to_access_default_constructor_for__T">483 attempting to access default constructor for %T</A>
<BR><A HREF="#484_cannot_align_symbol___S__to_segment_boundary">484 cannot align symbol '%S' to segment boundary</A>
<BR><A HREF="#485_friend_declaration_does_not_specify_a_class_or_function">485 friend declaration does not specify a class or function</A>
<BR><A HREF="#486_cannot_take_address_of_overloaded_function">486 cannot take address of overloaded function</A>
<BR><A HREF="#487_cannot_use_address_of_overloaded_function_as_a_variable_argument">487 cannot use address of overloaded function as a variable argument</A>
<BR><A HREF="#488___N__cannot_be_overloaded">488 '%N' cannot be overloaded</A>
<BR><A HREF="#489_symbol___S__has_already_been_initialized">489 symbol '%S' has already been initialized</A>
<BR><A HREF="#490_delete_expression_is_a_pointer_to_a_function">490 delete expression is a pointer to a function</A>
<BR><A HREF="#491_delete_of_a_pointer_to_const_data">491 delete of a pointer to const data</A>
<BR><A HREF="#492_delete_expression_is_not_a_pointer_to_data">492 delete expression is not a pointer to data</A>
<BR><A HREF="#493_template_argument_is_not_a_constant_expression">493 template argument is not a constant expression</A>
<BR><A HREF="#494_template_argument_is_not_an_external_linkage_symbol">494 template argument is not an external linkage symbol</A>
<BR><A HREF="#495_conversion_of_const_reference_to_volatile_reference">495 conversion of const reference to volatile reference</A>
<BR><A HREF="#496_conversion_of_volatile_reference_to_const_reference">496 conversion of volatile reference to const reference</A>
<BR><A HREF="#497_conversion_of_const_or_volatile_reference_to_plain_reference">497 conversion of const or volatile reference to plain reference</A>
<BR><A HREF="#498_syntax_error_before___s_S_probable_cause__incorrectly_spelled_type_name">498 syntax error before '%s'; probable cause:&nbsp; incorrectly spelled type name</A>
<BR><A HREF="#499_object_Lor_object_pointerR_required_to_access_nonMstatic_member_function">499 object (or object pointer) required to access non-static member function</A>
<DT>- 5 -
<DD><A HREF="#500_object_Lor_object_pointerR_cannot_be_used_to_access_function">500 object (or object pointer) cannot be used to access function</A>
<BR><A HREF="#501_object_Lor_object_pointerR_cannot_be_used_to_access_data">501 object (or object pointer) cannot be used to access data</A>
<BR><A HREF="#502_cannot_access_member_function_in_enclosing_class">502 cannot access member function in enclosing class</A>
<BR><A HREF="#503_cannot_access_data_member_in_enclosing_class">503 cannot access data member in enclosing class</A>
<BR><A HREF="#504_syntax_error_before_type_name___s_">504 syntax error before type name '%s'</A>
<BR><A HREF="#505_implementation_restriction__cannot_generate_thunk_from___S_">505 implementation restriction:&nbsp; cannot generate thunk from '%S'</A>
<BR><A HREF="#506_conversion_of___basedL_void_R_pointer_to_virtual_base_class">506 conversion of __based( void ) pointer to virtual base class</A>
<BR><A HREF="#507_class_for_target_operand_is_not_derived_from_class_for_source_operand">507 class for target operand is not derived from class for source operand</A>
<BR><A HREF="#508_conversion_ambiguity__Upointer_to_class_memberV_to_Uassignment_objectV">508 conversion ambiguity:&nbsp; [pointer to class member] to [assignment object]</A>
<BR><A HREF="#509_conversion_of_pointer_to_class_member_involves_a_private_base_class">509 conversion of pointer to class member involves a private base class</A>
<BR><A HREF="#510_conversion_of_pointer_to_class_member_involves_a_protected_base_class">510 conversion of pointer to class member involves a protected base class</A>
<BR><A HREF="#511_item_is_neither_a_nonMstatic_member_function_nor_data_member">511 item is neither a non-static member function nor data member</A>
<BR><A HREF="#512_function_address_cannot_be_converted_to_pointer_to_class_member">512 function address cannot be converted to pointer to class member</A>
<BR><A HREF="#513_conversion_ambiguity__Uaddress_of_functionV_to_Upointer_to_class_memberV">513 conversion ambiguity:&nbsp; [address of function] to [pointer to class member]</A>
<BR><A HREF="#514_addressed_function_is_in_a_private_base_class">514 addressed function is in a private base class</A>
<BR><A HREF="#515_addressed_function_is_in_a_protected_base_class">515 addressed function is in a protected base class</A>
<BR><A HREF="#516_class_for_object_is_not_defined">516 class for object is not defined</A>
<BR><A HREF="#517_left_expression_is_not_a_class_object">517 left expression is not a class object</A>
<BR><A HREF="#518_right_expression_is_not_a_pointer_to_class_member">518 right expression is not a pointer to class member</A>
<BR><A HREF="#519_cannot_convert_pointer_to_class_of_member_pointer">519 cannot convert pointer to class of member pointer</A>
<BR><A HREF="#520_conversion_ambiguity__UpointerV_to_Uclass_of_pointer_to_class_memberV">520 conversion ambiguity:&nbsp; [pointer] to [class of pointer to class member]</A>
<BR><A HREF="#521_conversion_of_pointer_to_class_of_member_pointer_involves_a_private_base_class">521 conversion of pointer to class of member pointer involves a private base class</A>
<BR><A HREF="#522_conversion_of_pointer_to_class_of_member_pointer_involves_a_protected_base_class">522 conversion of pointer to class of member pointer involves a protected base class</A>
<BR><A HREF="#523_cannot_convert_object_to_class_of_member_pointer">523 cannot convert object to class of member pointer</A>
<BR><A HREF="#524_conversion_ambiguity__UobjectV_to_Uclass_object_of_pointer_to_class_memberV">524 conversion ambiguity:&nbsp; [object] to [class object of pointer to class member]</A>
<BR><A HREF="#525_conversion_of_object_to_class_of_member_pointer_involves_a_private_base_class">525 conversion of object to class of member pointer involves a private base class</A>
<BR><A HREF="#526_conversion_of_object_to_class_of_member_pointer_involves_a_protected_base_class">526 conversion of object to class of member pointer involves a protected base class</A>
<BR><A HREF="#527_conversion_of_pointer_to_class_member_from_a_derived_to_a_base_class">527 conversion of pointer to class member from a derived to a base class</A>
<BR><A HREF="#528_form_is___pragma_inline_recursion_en__where__en__is__on__or__off_">528 form is '#pragma inline_recursion en' where 'en' is 'on' or 'off'</A>
<BR><A HREF="#529_expression_for_number_of_array_elements_must_be_integral">529 expression for number of array elements must be integral</A>
<BR><A HREF="#530_function_accessed_with___T__or__MYT__can_only_be_called">530 function accessed with '.*' or '-&gt;*' can only be called</A>
<BR><A HREF="#531_left_operand_must_be_a_pointer__pointer_to_class_member__or_arithmetic">531 left operand must be a pointer, pointer to class member, or arithmetic</A>
<BR><A HREF="#532_right_operand_must_be_a_pointer__pointer_to_class_member__or_arithmetic">532 right operand must be a pointer, pointer to class member, or arithmetic</A>
<BR><A HREF="#533_neither_pointer_to_class_member_can_be_converted_to_the_other">533 neither pointer to class member can be converted to the other</A>
<BR><A HREF="#534_left_operand_is_not_a_valid_pointer_to_class_member">534 left operand is not a valid pointer to class member</A>
<BR><A HREF="#535_right_operand_is_not_a_valid_pointer_to_class_member">535 right operand is not a valid pointer to class member</A>
<BR><A HREF="#536_cannot_use___T__nor__MYT__with_pointer_to_class_member_with_zero_value">536 cannot use '.*' nor '-&gt;*' with pointer to class member with zero value</A>
<BR><A HREF="#537_operand_is_not_a_valid_pointer_to_class_member">537 operand is not a valid pointer to class member</A>
<BR><A HREF="#538_destructor_can_be_invoked_only_with_____or__MY_">538 destructor can be invoked only with '.' or '-&gt;'</A>
<BR><A HREF="#539_class_of_destructor_must_be_class_of_object_being_destructed">539 class of destructor must be class of object being destructed</A>
<BR><A HREF="#540_destructor_is_not_properly_qualified">540 destructor is not properly qualified</A>
<BR><A HREF="#541_pointers_to_class_members_reference_different_object_types">541 pointers to class members reference different object types</A>
<BR><A HREF="#542_operand_must_be_pointer_to_class_or_struct">542 operand must be pointer to class or struct</A>
<BR><A HREF="#543_expression_must_have_void_type">543 expression must have void type</A>
<BR><A HREF="#544_expression_types_do_not_match_for_____operator">544 expression types do not match for ':' operator</A>
<BR><A HREF="#545_cannot_create_an_undefined_type_with__operator_new_">545 cannot create an undefined type with 'operator new'</A>
<BR><A HREF="#546_delete_of_a_pointer_to_an_undefined_type">546 delete of a pointer to an undefined type</A>
<BR><A HREF="#547_cannot_access___S__through_a_private_base_class">547 cannot access '%S' through a private base class</A>
<BR><A HREF="#548_cannot_access___S__through_a_protected_base_class">548 cannot access '%S' through a protected base class</A>
<BR><A HREF="#549__sizeof__operand_contains_compiler_generated_information">549 'sizeof' operand contains compiler generated information</A>
<BR><A HREF="#550_cannot_convert_____operands_to_a_common_reference_type">550 cannot convert ':' operands to a common reference type</A>
<BR><A HREF="#551_conversion_ambiguity__Ureference_to_objectV_to_Utype_of_opposite_____operandV">551 conversion ambiguity:&nbsp; [reference to object] to [type of opposite ':' operand]</A>
<BR><A HREF="#552_conversion_of_reference_to_____object_involves_a_private_base_class">552 conversion of reference to ':' object involves a private base class</A>
<BR><A HREF="#553_conversion_of_reference_to_____object_involves_a_protected_base_class">553 conversion of reference to ':' object involves a protected base class</A>
<BR><A HREF="#554_expression_must_have_type_arithmetic__pointer__or_pointer_to_class_member">554 expression must have type arithmetic, pointer, or pointer to class member</A>
<BR><A HREF="#555_expression_for__while__is_always_false">555 expression for 'while' is always false</A>
<BR><A HREF="#556_testing_expression_for__for__is_always_false">556 testing expression for 'for' is always false</A>
<BR><A HREF="#557_message_number___d__is_invalid">557 message number '%d' is invalid</A>
<BR><A HREF="#558_warning_level_must_be_an_integer_in_range_0_to_9">558 warning level must be an integer in range 0 to 9</A>
<BR><A HREF="#559_function___S__cannot_be_defined_because_it_is_generated_by_the_compiler">559 function '%S' cannot be defined because it is generated by the compiler</A>
<BR><A HREF="#560_neither_environment_variable_nor_file_found_for__A__name">560 neither environment variable nor file found for '@' name</A>
<BR><A HREF="#561_more_than_5_indirections_during_command_line_processing">561 more than 5 indirections during command line processing</A>
<BR><A HREF="#562_cannot_take_address_of_nonMstatic_member_function">562 cannot take address of non-static member function</A>
<BR><A HREF="#563_cannot_generate_default___S__because_class_contains_either_a_constant_or_a_reference_member">563 cannot generate default '%S' because class contains either a constant or a reference member</A>
<BR><A HREF="#564_cannot_convert_pointer_to_nonMconstant_or_volatile_objects_to_pointer_to_const_void">564 cannot convert pointer to non-constant or volatile objects to pointer to const void</A>
<BR><A HREF="#565_cannot_convert_pointer_to_nonMconstant_or_nonMvolatile_objects_to_pointer_to_const_volatile_void">565 cannot convert pointer to non-constant or non-volatile objects to pointer to const volatile void</A>
<BR><A HREF="#566_cannot_initialize_pointer_to_nonMvolatile_with_a_pointer_to_volatile">566 cannot initialize pointer to non-volatile with a pointer to volatile</A>
<BR><A HREF="#567_cannot_pass_a_pointer_or_reference_to_a_volatile_object">567 cannot pass a pointer or reference to a volatile object</A>
<BR><A HREF="#568_cannot_return_a_pointer_or_reference_to_a_volatile_object">568 cannot return a pointer or reference to a volatile object</A>
<BR><A HREF="#569_left_expression_is_not_a_pointer_to_a_volatile_object">569 left expression is not a pointer to a volatile object</A>
<BR><A HREF="#570_virtual_function_override_for___S__is_ambiguous">570 virtual function override for '%S' is ambiguous</A>
<BR><A HREF="#571_initialization_priority_must_be_number_0M255___library___or__program_">571 initialization priority must be number 0-255, 'library', or 'program'</A>
<BR><A HREF="#572_previous_case_label_defined__L">572 previous case label defined %L</A>
<BR><A HREF="#573_previous_default_label_defined__L">573 previous default label defined %L</A>
<BR><A HREF="#574_label_defined__L">574 label defined %L</A>
<BR><A HREF="#575_label_referenced__L">575 label referenced %L</A>
<BR><A HREF="#576_object_thrown_has_type___T">576 object thrown has type:&nbsp; %T</A>
<BR><A HREF="#577_object_thrown_has_an_ambiguous_base_class__T">577 object thrown has an ambiguous base class %T</A>
<BR><A HREF="#578_form_is___pragma_inline_depth_level__where__level__is_0_to_255">578 form is '#pragma inline_depth level' where 'level' is 0 to 255</A>
<BR><A HREF="#579_pointer_or_reference_truncated_by_cast">579 pointer or reference truncated by cast</A>
<BR><A HREF="#580_cannot_find_a_constructor_for_given_initializer_argument_list">580 cannot find a constructor for given initializer argument list</A>
<BR><A HREF="#581_variable___N__can_only_be_based_on_a_string_in_this_context">581 variable '%N' can only be based on a string in this context</A>
<BR><A HREF="#582_memory_model_modifiers_are_not_allowed_for_class_members">582 memory model modifiers are not allowed for class members</A>
<BR><A HREF="#583_redefinition_of_the_typedef_name___S__ignored">583 redefinition of the typedef name '%S' ignored</A>
<BR><A HREF="#584_constructor_for_variable___S__cannot_be_bypassed">584 constructor for variable '%S' cannot be bypassed</A>
<BR><A HREF="#585_syntax_errorS_missing_start_of_function_body_after_constructor_initializer">585 syntax error; missing start of function body after constructor initializer</A>
<BR><A HREF="#586_conversion_ambiguity__UexpressionV_to_Utype_of_default_argumentV">586 conversion ambiguity:&nbsp; [expression] to [type of default argument]</A>
<BR><A HREF="#587_conversion_of_expression_for_default_argument_is_impossible">587 conversion of expression for default argument is impossible</A>
<BR><A HREF="#588_syntax_error_before_template_name___s_">588 syntax error before template name '%s'</A>
<BR><A HREF="#589_private_base_class_accessed_to_convert_default_argument">589 private base class accessed to convert default argument</A>
<BR><A HREF="#590_protected_base_class_accessed_to_convert_default_argument">590 protected base class accessed to convert default argument</A>
<BR><A HREF="#591_operand_must_be_an_lvalue_Lcast_produces_rvalueR">591 operand must be an lvalue (cast produces rvalue)</A>
<BR><A HREF="#592_left_operand_must_be_an_lvalue_Lcast_produces_rvalueR">592 left operand must be an lvalue (cast produces rvalue)</A>
<BR><A HREF="#593_right_operand_must_be_an_lvalue_Lcast_produces_rvalueR">593 right operand must be an lvalue (cast produces rvalue)</A>
<BR><A HREF="#594_construct_resolved_as_a_declarationDtype">594 construct resolved as a declaration/type</A>
<BR><A HREF="#595_construct_resolved_as_an_expression">595 construct resolved as an expression</A>
<BR><A HREF="#596_construct_cannot_be_resolved">596 construct cannot be resolved</A>
<BR><A HREF="#597_encountered_another_ambiguous_construct_during_disambiguation">597 encountered another ambiguous construct during disambiguation</A>
<BR><A HREF="#598_ellipsis_L___R_argument_contains_compiler_generated_information">598 ellipsis (...) argument contains compiler generated information</A>
<BR><A HREF="#599_cannot_convert_argument_for_ellipsis_L___R_argument">599 cannot convert argument for ellipsis (...) argument</A>
<DT>- 6 -
<DD><A HREF="#600_conversion_ambiguity__UargumentV_to_Uellipsis_L___R_argumentV">600 conversion ambiguity:&nbsp; [argument] to [ellipsis (...) argument]</A>
<BR><A HREF="#601_converted_function_type_has_different__pragma_from_original_function_type">601 converted function type has different #pragma from original function type</A>
<BR><A HREF="#602_class_value_used_as_return_value_or_argument_in_converted_function_type">602 class value used as return value or argument in converted function type</A>
<BR><A HREF="#603_class_value_used_as_return_value_or_argument_in_original_function_type">603 class value used as return value or argument in original function type</A>
<BR><A HREF="#604_must_look_ahead_to_determine_whether_construct_is_a_declarationDtype_or_an_expression">604 must look ahead to determine whether construct is a declaration/type or an expression</A>
<BR><A HREF="#605_assembler____s_">605 assembler:&nbsp; '%s'</A>
<BR><A HREF="#606_default_argument_expression_cannot_reference__this_">606 default argument expression cannot reference 'this'</A>
<BR><A HREF="#607__pragma_aux_must_reference_a__C__linkage_function___S_">607 #pragma aux must reference a &quot;C&quot; linkage function '%S'</A>
<BR><A HREF="#608_assignment_is_ambiguous_for_operands_used">608 assignment is ambiguous for operands used</A>
<BR><A HREF="#609_pragma_name___s__is_not_defined">609 pragma name '%s' is not defined</A>
<BR><A HREF="#610___S__could_not_be_generated_by_the_compiler">610 '%S' could not be generated by the compiler</A>
<BR><A HREF="#611__catch__does_not_immediately_follow_a__try__or__catch_">611 'catch' does not immediately follow a 'try' or 'catch'</A>
<BR><A HREF="#612_preceding_catch_specified______">612 preceding catch specified '...'</A>
<BR><A HREF="#613_argument_to_extern__C__function_contains_compiler_generated_information">613 argument to extern &quot;C&quot; function contains compiler generated information</A>
<BR><A HREF="#614_previous_try_block_defined__L">614 previous try block defined %L</A>
<BR><A HREF="#615_previous_catch_block_defined__L">615 previous catch block defined %L</A>
<BR><A HREF="#616_catch_handler_can_never_be_invoked">616 catch handler can never be invoked</A>
<BR><A HREF="#617_cannot_overload_extern__C__functions_Lthe_other_function_is___S_R">617 cannot overload extern &quot;C&quot; functions (the other function is '%S')</A>
<BR><A HREF="#618_function_will_be_overload_ambiguous_with___S__using_default_arguments">618 function will be overload ambiguous with '%S' using default arguments</A>
<BR><A HREF="#619_linkage_specification_is_different_than_previous_declaration___S_">619 linkage specification is different than previous declaration '%S'</A>
<BR><A HREF="#620_not_enough_segment_registers_available_to_generate___s_">620 not enough segment registers available to generate '%s'</A>
<BR><A HREF="#621_pure_virtual_destructors_must_have_a_definition">621 pure virtual destructors must have a definition</A>
<BR><A HREF="#622_jump_into_try_block">622 jump into try block</A>
<BR><A HREF="#623_jump_into_catch_handler">623 jump into catch handler</A>
<BR><A HREF="#624_catch_block_does_not_immediately_follow_try_block">624 catch block does not immediately follow try block</A>
<BR><A HREF="#625_exceptions_must_be_enabled_to_use_feature_Luse__xs__optionR">625 exceptions must be enabled to use feature (use 'xs' option)</A>
<BR><A HREF="#626_IDO_error_reading___s____s_">626 I/O error reading '%s':&nbsp; %s&quot;</A>
<BR><A HREF="#627_text_following_preMprocessor_directive">627 text following pre-processor directive</A>
<BR><A HREF="#628_expression_is_not_meaningful">628 expression is not meaningful</A>
<BR><A HREF="#629_expression_has_no_side_effect">629 expression has no side effect</A>
<BR><A HREF="#630_source_conversion_type_is___T_">630 source conversion type is '%T'</A>
<BR><A HREF="#631_target_conversion_type_is___T_">631 target conversion type is '%T'</A>
<BR><A HREF="#632_redeclaration_of___S__has_different_attributes">632 redeclaration of '%S' has different attributes</A>
<BR><A HREF="#633_template_class_instantiation_for___T__was__L">633 template class instantiation for '%T' was %L</A>
<BR><A HREF="#634_template_function_instantiation_for___S__was__L">634 template function instantiation for '%S' was %L</A>
<BR><A HREF="#635_template_class_member_instantiation_was__L">635 template class member instantiation was %L</A>
<BR><A HREF="#636_function_template_binding_for___S__was__L">636 function template binding for '%S' was %L</A>
<BR><A HREF="#637_function_template_binding_of___S__was__L">637 function template binding of '%S' was %L</A>
<BR><A HREF="#638___s__defined__L">638 '%s' defined %L</A>
<BR><A HREF="#639_form_is___pragma_template_depth_level__where__level__is_a_nonMzero_number">639 form is '#pragma template_depth level' where 'level' is a non-zero number</A>
<BR><A HREF="#640_possible_nonMterminating_template_instantiation_Luse___pragma_template_depth__d__to_increase_depthR">640 possible non-terminating template instantiation (use &quot;#pragma template_depth %d&quot; to increase depth)</A>
<BR><A HREF="#641_cannot_inherit_a_partially_defined_base_class___T_">641 cannot inherit a partially defined base class '%T'</A>
<BR><A HREF="#642_ambiguous_function___F_defined__L">642 ambiguous function:&nbsp; %F defined %L</A>
<BR><A HREF="#643_cannot_convert_argument__d_defined__L">643 cannot convert argument %d defined %L</A>
<BR><A HREF="#644__this__cannot_be_converted">644 'this' cannot be converted</A>
<BR><A HREF="#645_rejected_function___F_defined__L">645 rejected function:&nbsp; %F defined %L</A>
<BR><A HREF="#646___T__operator_can_be_used">646 '%T' operator can be used</A>
<BR><A HREF="#647_cannot__undef___s_">647 cannot #undef '%s'</A>
<BR><A HREF="#648_cannot__define___s_">648 cannot #define '%s'</A>
<BR><A HREF="#649_template_function___F__defined__L">649 template function '%F' defined %L</A>
<BR><A HREF="#650_ambiguous_function_template___F_defined__L">650 ambiguous function template:&nbsp; %F defined %L</A>
<BR><A HREF="#651_cannot_instantiate__S">651 cannot instantiate %S</A>
<BR><A HREF="#652_rejected_function_template___F_defined__L">652 rejected function template:&nbsp; %F defined %L</A>
<BR><A HREF="#653_operand_cannot_be_a_function">653 operand cannot be a function</A>
<BR><A HREF="#654_left_operand_cannot_be_a_function">654 left operand cannot be a function</A>
<BR><A HREF="#655_right_operand_cannot_be_a_function">655 right operand cannot be a function</A>
<BR><A HREF="#656_define_this_function_inside_its_class_definition_Lmay_improve_code_qualityR">656 define this function inside its class definition (may improve code quality)</A>
<BR><A HREF="#657_define_this_function_inside_its_class_definition_Lcould_have_improved_code_qualityR">657 define this function inside its class definition (could have improved code quality)</A>
<BR><A HREF="#658_cannot_convert_address_of_overloaded_function___S_">658 cannot convert address of overloaded function '%S'</A>
<BR><A HREF="#659_expression_cannot_have_void_type">659 expression cannot have void type</A>
<BR><A HREF="#660_cannot_reference_a_bit_field">660 cannot reference a bit field</A>
<BR><A HREF="#661_cannot_assign_to_object_having_an_undefined_class">661 cannot assign to object having an undefined class</A>
<BR><A HREF="#662_cannot_create_member_pointer_to_constructor">662 cannot create member pointer to constructor</A>
<BR><A HREF="#663_cannot_create_member_pointer_to_destructor">663 cannot create member pointer to destructor</A>
<BR><A HREF="#664_attempt_to_initialize_a_nonMconstant_reference_with_a_temporary_object">664 attempt to initialize a non-constant reference with a temporary object</A>
<BR><A HREF="#665_temporary_object_used_to_initialize_a_nonMconstant_reference">665 temporary object used to initialize a non-constant reference</A>
<BR><A HREF="#666_assuming_unary__operator____not_overloaded_for_type___T_">666 assuming unary 'operator &amp;' not overloaded for type '%T'</A>
<BR><A HREF="#667__va_start__macro_will_not_work_without_an_argument_before______">667 'va_start' macro will not work without an argument before '...'</A>
<BR><A HREF="#668__va_start__macro_will_not_work_with_a_reference_argument_before______">668 'va_start' macro will not work with a reference argument before '...'</A>
<BR><A HREF="#669__va_start__macro_will_not_work_with_a_class_argument_before______">669 'va_start' macro will not work with a class argument before '...'</A>
<BR><A HREF="#670_function_modifier_conflicts_with_previous_declaration___S_">670 function modifier conflicts with previous declaration '%S'</A>
<BR><A HREF="#671_function_modifier_cannot_be_used_on_a_variable">671 function modifier cannot be used on a variable</A>
<BR><A HREF="#672___T__contains_the_following_pure_virtual_functions">672 '%T' contains the following pure virtual functions</A>
<BR><A HREF="#673___T__has_no_implementation_for_the_following_pure_virtual_functions">673 '%T' has no implementation for the following pure virtual functions</A>
<BR><A HREF="#674_pure_virtual_function___F__defined__L">674 pure virtual function '%F' defined %L</A>
<BR><A HREF="#675_restriction__standard_calling_convention_required_for___S_">675 restriction:&nbsp; standard calling convention required for '%S'</A>
<BR><A HREF="#676_number_of_arguments_in_function_call_is_incorrect">676 number of arguments in function call is incorrect</A>
<BR><A HREF="#677_function_has_type___T_">677 function has type '%T'</A>
<BR><A HREF="#678_invalid_octal_constant">678 invalid octal constant</A>
<BR><A HREF="#679_class_template_definition_started__L">679 class template definition started %L</A>
<BR><A HREF="#680_constructor_initializer_started__L">680 constructor initializer started %L</A>
<BR><A HREF="#681_zero_size_array_must_be_the_last_data_member">681 zero size array must be the last data member</A>
<BR><A HREF="#682_cannot_inherit_a_class_that_contains_a_zero_size_array">682 cannot inherit a class that contains a zero size array</A>
<BR><A HREF="#683_zero_size_array___S__cannot_be_used_in_a_class_with_base_classes">683 zero size array '%S' cannot be used in a class with base classes</A>
<BR><A HREF="#684_cannot_catch_abstract_class_object">684 cannot catch abstract class object</A>
<BR><A HREF="#685_nonMstatic_member_function___S__cannot_be_specified">685 non-static member function '%S' cannot be specified</A>
<BR><A HREF="#686_attempt_to_convert_pointer_or_reference_from_a_base_to_a_derived_class">686 attempt to convert pointer or reference from a base to a derived class</A>
<BR><A HREF="#687_expression_for__while__is_always_true">687 expression for 'while' is always true</A>
<BR><A HREF="#688_testing_expression_for__for__is_always_true">688 testing expression for 'for' is always true</A>
<BR><A HREF="#689_conditional_expression_is_always_true_LnonMzeroR">689 conditional expression is always true (non-zero)</A>
<BR><A HREF="#690_conditional_expression_is_always_false_LzeroR">690 conditional expression is always false (zero)</A>
<BR><A HREF="#691_expecting_a_member_of___T__to_be_defined_in_this_context">691 expecting a member of '%T' to be defined in this context</A>
<BR><A HREF="#692_cannot_throw_an_abstract_class">692 cannot throw an abstract class</A>
<BR><A HREF="#693_cannot_create_preMcompiled_header_file___s_">693 cannot create pre-compiled header file '%s'</A>
<BR><A HREF="#694_error_occurred_while_writing_preMcompiled_header_file">694 error occurred while writing pre-compiled header file</A>
<BR><A HREF="#695_error_occurred_while_reading_preMcompiled_header_file">695 error occurred while reading pre-compiled header file</A>
<BR><A HREF="#696_preMcompiled_header_file_being_recreated">696 pre-compiled header file being recreated</A>
<BR><A HREF="#697_preMcompiled_header_file_being_recreated_Ldifferent_compile_optionsR">697 pre-compiled header file being recreated (different compile options)</A>
<BR><A HREF="#698_preMcompiled_header_file_being_recreated_Ldifferent__include_fileR">698 pre-compiled header file being recreated (different #include file)</A>
<BR><A HREF="#699_preMcompiled_header_file_being_recreated_Ldifferent_current_directoryR">699 pre-compiled header file being recreated (different current directory)</A>
<DT>- 7 -
<DD><A HREF="#700_preMcompiled_header_file_being_recreated_Ldifferent_INCLUDE_pathR">700 pre-compiled header file being recreated (different INCLUDE path)</A>
<BR><A HREF="#701_preMcompiled_header_file_being_recreated_L__s__has_been_modifiedR">701 pre-compiled header file being recreated ('%s' has been modified)</A>
<BR><A HREF="#702_preMcompiled_header_file_being_recreated_Lmacro___s__is_differentR">702 pre-compiled header file being recreated (macro '%s' is different)</A>
<BR><A HREF="#703_preMcompiled_header_file_being_recreated_Lmacro___s__is_not_definedR">703 pre-compiled header file being recreated (macro '%s' is not defined)</A>
<BR><A HREF="#704_command_line_specifies_smart_windows_callbacks_and_DS_not_equal_to_SS">704 command line specifies smart windows callbacks and DS not equal to SS</A>
<BR><A HREF="#705_class___N__cannot_be_used_with__pragma_dump_object_model">705 class '%N' cannot be used with #pragma dump_object_model</A>
<BR><A HREF="#706_repeated_modifier_is___s_">706 repeated modifier is '%s'</A>
<BR><A HREF="#707_semicolon_L_S_R_may_be_missing_after_classDenum_definition">707 semicolon (';') may be missing after class/enum definition</A>
<BR><A HREF="#708_cannot_return_a_type_of_unknown_size">708 cannot return a type of unknown size</A>
<BR><A HREF="#709_cannot_initialize_array_member___S_">709 cannot initialize array member '%S'</A>
<BR><A HREF="#710_file___s__will__include_itself_forever">710 file '%s' will #include itself forever</A>
<BR><A HREF="#711__mutable__may_only_be_used_for_nonMstatic_class_members">711 'mutable' may only be used for non-static class members</A>
<BR><A HREF="#712__mutable__member_cannot_also_be_const">712 'mutable' member cannot also be const</A>
<BR><A HREF="#713_left_operand_cannot_be_of_type_bool">713 left operand cannot be of type bool</A>
<BR><A HREF="#714_operand_cannot_be_of_type_bool">714 operand cannot be of type bool</A>
<BR><A HREF="#715_member___N__has_not_been_declared_in___T_">715 member '%N' has not been declared in '%T'</A>
<BR><A HREF="#716_integral_value_may_be_truncated">716 integral value may be truncated</A>
<BR><A HREF="#717_left_operand_type_is___T_">717 left operand type is '%T'</A>
<BR><A HREF="#718_right_operand_type_is___T_">718 right operand type is '%T'</A>
<BR><A HREF="#719_operand_type_is___T_">719 operand type is '%T'</A>
<BR><A HREF="#720_expression_type_is___T_">720 expression type is '%T'</A>
<BR><A HREF="#721_virtual_function___S__cannot_have_its_return_type_changed">721 virtual function '%S' cannot have its return type changed</A>
<BR><A HREF="#722___declspecL___N__R_is_not_supported">722 __declspec( '%N' ) is not supported</A>
<BR><A HREF="#723_attempt_to_construct_a_far_object_when_the_data_model_is_near">723 attempt to construct a far object when the data model is near</A>
<BR><A HREF="#724_Mzo_is_an_obsolete_switch_Lhas_no_effectR">724 -zo is an obsolete switch (has no effect)</A>
<BR><A HREF="#725___s_">725 &quot;%s&quot;</A>
<BR><A HREF="#726_no_reference_to_formal_parameter___S_">726 no reference to formal parameter '%S'</A>
<BR><A HREF="#727_cannot_dereference_a_pointer_to_void">727 cannot dereference a pointer to void</A>
<BR><A HREF="#728_class_modifiers_for___T__conflict_with_class_modifiers_for___T_">728 class modifiers for '%T' conflict with class modifiers for '%T'</A>
<BR><A HREF="#729_invalid_hexadecimal_constant">729 invalid hexadecimal constant</A>
<BR><A HREF="#730_return_type_of__operator_MY__will_not_allow__MY__to_be_applied">730 return type of 'operator -&gt;' will not allow '-&gt;' to be applied</A>
<BR><A HREF="#731_class_should_have_a_name_since_it_needs_a_constructor_or_a_destructor">731 class should have a name since it needs a constructor or a destructor</A>
<BR><A HREF="#732_class_should_have_a_name_since_it_inherits_a_class">732 class should have a name since it inherits a class</A>
<BR><A HREF="#733_cannot_open_preMcompiled_header_file___s_">733 cannot open pre-compiled header file '%s'</A>
<BR><A HREF="#734_invalid_second_argument_to_va_start">734 invalid second argument to va_start</A>
<BR><A HREF="#735__DD__style_comment_continues_on_next_line">735 '//' style comment continues on next line</A>
<BR><A HREF="#736_cannot_open_file___s__for_write_access">736 cannot open file '%s' for write access</A>
<BR><A HREF="#737_implicit_conversion_of_pointers_to_integral_types_of_same_size">737 implicit conversion of pointers to integral types of same size</A>
<BR><A HREF="#738_option_requires_a_number">738 option requires a number</A>
<BR><A HREF="#739_option_Mfc_specified_more_than_once">739 option -fc specified more than once</A>
<BR><A HREF="#740_option_Mfc_specified_in_batch_file_of_commands">740 option -fc specified in batch file of commands</A>
<BR><A HREF="#741_file_specified_by_Mfc_is_empty_or_cannot_be_read">741 file specified by -fc is empty or cannot be read</A>
<BR><A HREF="#742_cannot_open_file_specified_by_Mfc_option">742 cannot open file specified by -fc option</A>
<BR><A HREF="#743_inputDoutput_error_reading_the_file_specified_by_Mfc_option">743 input/output error reading the file specified by -fc option</A>
<BR><A HREF="#744___N__does_not_have_a_return_type_specified_Lint_assumedR">744 '%N' does not have a return type specified (int assumed)</A>
<BR><A HREF="#745_cannot_initialize_reference_to_nonMconstant_with_a_constant_object">745 cannot initialize reference to non-constant with a constant object</A>
<BR><A HREF="#746_processing__s">746 processing %s</A>
<BR><A HREF="#747_class___T__has_not_been_defined">747 class '%T' has not been defined</A>
<BR><A HREF="#748_cannot_catch_undefined_class_object">748 cannot catch undefined class object</A>
<BR><A HREF="#749_class___T__cannot_be_used_since_its_definition_has_errors">749 class '%T' cannot be used since its definition has errors</A>
<BR><A HREF="#750_function_prototype_in_block_scope_missing__extern_">750 function prototype in block scope missing 'extern'</A>
<BR><A HREF="#751_function_prototype_is___T_">751 function prototype is '%T'</A>
<BR><A HREF="#752_class___T__contains_a_zero_size_array">752 class '%T' contains a zero size array</A>
<BR><A HREF="#753_invalid__new__modifier">753 invalid 'new' modifier</A>
<BR><A HREF="#754____declspecLthreadR__data___S__must_be_linkMtime_initialized">754 '__declspec(thread)' data '%S' must be link-time initialized</A>
<BR><A HREF="#755_code_may_not_work_properly_if_this_module_is_split_across_a_code_segment">755 code may not work properly if this module is split across a code segment</A>
<BR><A HREF="#756__pragma_extref__symbol___N__not_declared">756 #pragma extref:&nbsp; symbol '%N' not declared</A>
<BR><A HREF="#757__pragma_extref__overloaded_function___S__cannot_be_used">757 #pragma extref:&nbsp; overloaded function '%S' cannot be used</A>
<BR><A HREF="#758__pragma_extref____N__is_not_a_function_or_data">758 #pragma extref:&nbsp; '%N' is not a function or data</A>
<BR><A HREF="#759__pragma_extref____S__is_not_external">759 #pragma extref:&nbsp; '%S' is not external</A>
<BR><A HREF="#760_preMcompiled_header_file_being_recreated_Ldebugging_info_may_changeR">760 pre-compiled header file being recreated (debugging info may change)</A>
<BR><A HREF="#761_octal_escape_sequence_out_of_rangeS_truncated">761 octal escape sequence out of range; truncated</A>
<BR><A HREF="#762_binary_operator___s__missing_right_operand">762 binary operator '%s' missing right operand</A>
<BR><A HREF="#763_binary_operator___s__missing_left_operand">763 binary operator '%s' missing left operand</A>
<BR><A HREF="#764_expression_contains_extra_operandLsR">764 expression contains extra operand(s)</A>
<BR><A HREF="#765_expression_contains_consecutive_operandLsR">765 expression contains consecutive operand(s)</A>
<BR><A HREF="#766_unmatched_right_parenthesis__R_">766 unmatched right parenthesis ')'</A>
<BR><A HREF="#767_unmatched_left_parenthesis__L_">767 unmatched left parenthesis '('</A>
<BR><A HREF="#768_no_expression_between_parentheses__L_R_">768 no expression between parentheses '( )'</A>
<BR><A HREF="#769_expecting_____operator_in_conditional_expression">769 expecting ':' operator in conditional expression</A>
<BR><A HREF="#770_expecting_____operator_in_conditional_expression">770 expecting '?' operator in conditional expression</A>
<BR><A HREF="#771_expecting_first_operand_in_conditional_expression">771 expecting first operand in conditional expression</A>
<BR><A HREF="#772_expecting_second_operand_in_conditional_expression">772 expecting second operand in conditional expression</A>
<BR><A HREF="#773_expecting_third_operand_in_conditional_expression">773 expecting third operand in conditional expression</A>
<BR><A HREF="#774_expecting_operand_after_unary_operator___s_">774 expecting operand after unary operator '%s'</A>
<BR><A HREF="#775___s__unexpected_in_constant_expression">775 '%s' unexpected in constant expression</A>
<BR><A HREF="#776_assembler____s_">776 assembler:&nbsp; '%s'</A>
<BR><A HREF="#777_expecting__id__after______but_found___s_">777 expecting 'id' after '::' but found '%s'</A>
<BR><A HREF="#778_only_constructors_can_be_declared_explicit">778 only constructors can be declared explicit</A>
<BR><A HREF="#779_const_cast_type_must_be_pointer__member_pointer__or_reference">779 const_cast type must be pointer, member pointer, or reference</A>
<BR><A HREF="#780_const_cast_expression_must_be_pointer_to_same_kind_of_object">780 const_cast expression must be pointer to same kind of object</A>
<BR><A HREF="#781_const_cast_expression_must_be_lvalue_of_the_same_kind_of_object">781 const_cast expression must be lvalue of the same kind of object</A>
<BR><A HREF="#782_expression_must_be_pointer_to_member_from_same_class_in_const_cast">782 expression must be pointer to member from same class in const_cast</A>
<BR><A HREF="#783_expression_must_be_member_pointer_to_same_type_as_specified_in_const_cast">783 expression must be member pointer to same type as specified in const_cast</A>
<BR><A HREF="#784_reinterpret_cast_expression_must_be_pointer_or_integral_object">784 reinterpret_cast expression must be pointer or integral object</A>
<BR><A HREF="#785_reinterpret_cast_expression_cannot_be_casted_to_reference_type">785 reinterpret_cast expression cannot be casted to reference type</A>
<BR><A HREF="#786_reinterpret_cast_expression_cannot_be_casted_to_pointer_to_member">786 reinterpret_cast expression cannot be casted to pointer to member</A>
<BR><A HREF="#787_only_integral_arithmetic_types_can_be_used_with_reinterpret_cast">787 only integral arithmetic types can be used with reinterpret_cast</A>
<BR><A HREF="#788_only_integral_arithmetic_types_can_be_used_with_reinterpret_cast">788 only integral arithmetic types can be used with reinterpret_cast</A>
<BR><A HREF="#789_cannot_cast_away_constness">789 cannot cast away constness</A>
<BR><A HREF="#790_size_of_integral_type_in_cast_less_than_size_of_pointer">790 size of integral type in cast less than size of pointer</A>
<BR><A HREF="#791_type_cannot_be_used_in_reinterpret_cast">791 type cannot be used in reinterpret_cast</A>
<BR><A HREF="#792_only_pointers_can_be_casted_to_integral_types_with_reinterpret_cast">792 only pointers can be casted to integral types with reinterpret_cast</A>
<BR><A HREF="#793_only_integers_and_pointers_can_be_casted_to_pointer_types_with_reinterpret_cast">793 only integers and pointers can be casted to pointer types with reinterpret_cast</A>
<BR><A HREF="#794_static_cast_cannot_convert_the_expression">794 static_cast cannot convert the expression</A>
<BR><A HREF="#795_static_cast_cannot_be_used_with_the_type_specified">795 static_cast cannot be used with the type specified</A>
<BR><A HREF="#796_static_cast_cannot_be_used_with_the_reference_type_specified">796 static_cast cannot be used with the reference type specified</A>
<BR><A HREF="#797_static_cast_cannot_be_used_with_the_pointer_type_specified">797 static_cast cannot be used with the pointer type specified</A>
<BR><A HREF="#798_static_cast_cannot_be_used_with_the_member_pointer_type_specified">798 static_cast cannot be used with the member pointer type specified</A>
<BR><A HREF="#799_static_cast_type_is_ambiguous">799 static_cast type is ambiguous</A>
<DT>- 8 -
<DD><A HREF="#800_cannot_cast_from_ambiguous_base_class">800 cannot cast from ambiguous base class</A>
<BR><A HREF="#801_cannot_cast_to_ambiguous_base_class">801 cannot cast to ambiguous base class</A>
<BR><A HREF="#802_can_only_static_cast_integers_to_enumeration_type">802 can only static_cast integers to enumeration type</A>
<BR><A HREF="#803_dynamic_cast_cannot_be_used_with_the_type_specified">803 dynamic_cast cannot be used with the type specified</A>
<BR><A HREF="#804_dynamic_cast_cannot_convert_the_expression">804 dynamic_cast cannot convert the expression</A>
<BR><A HREF="#805_dynamic_cast_requires_class___T__to_have_virtual_functions">805 dynamic_cast requires class '%T' to have virtual functions</A>
<BR><A HREF="#806_base_class_for_type_in_dynamic_cast_is_ambiguous_Lwill_failR">806 base class for type in dynamic_cast is ambiguous (will fail)</A>
<BR><A HREF="#807_base_class_for_type_in_dynamic_cast_is_private_Lmay_failR">807 base class for type in dynamic_cast is private (may fail)</A>
<BR><A HREF="#808_base_class_for_type_in_dynamic_cast_is_protected_Lmay_failR">808 base class for type in dynamic_cast is protected (may fail)</A>
<BR><A HREF="#809_type_cannot_be_used_with_an_explicit_cast">809 type cannot be used with an explicit cast</A>
<BR><A HREF="#810_cannot_cast_to_an_array_type">810 cannot cast to an array type</A>
<BR><A HREF="#811_cannot_cast_to_a_function_type">811 cannot cast to a function type</A>
<BR><A HREF="#812_implementation_restriction__cannot_generate_RTTI_info_for___T__L_d_classesR">812 implementation restriction:&nbsp; cannot generate RTTI info for '%T' (%d classes)</A>
<BR><A HREF="#813_more_than_one_default_constructor_for___T_">813 more than one default constructor for '%T'</A>
<BR><A HREF="#814_userMdefined_conversion_is_ambiguous">814 user-defined conversion is ambiguous</A>
<BR><A HREF="#815_range_of_possible_values_for_type___T__is__s_to__s">815 range of possible values for type '%T' is %s to %s</A>
<BR><A HREF="#816_range_of_possible_values_for_type___T__is__s_to__s">816 range of possible values for type '%T' is %s to %s</A>
<BR><A HREF="#817_constant_expression_in_comparison_has_value__s">817 constant expression in comparison has value %s</A>
<BR><A HREF="#818_constant_expression_in_comparison_has_value__s">818 constant expression in comparison has value %s</A>
<BR><A HREF="#819_conversion_of_const_reference_to_nonMconst_reference">819 conversion of const reference to non-const reference</A>
<BR><A HREF="#820_conversion_of_volatile_reference_to_nonMvolatile_reference">820 conversion of volatile reference to non-volatile reference</A>
<BR><A HREF="#821_conversion_of_const_volatile_reference_to_plain_reference">821 conversion of const volatile reference to plain reference</A>
<BR><A HREF="#822_current_declaration_has_type___T_">822 current declaration has type '%T'</A>
<BR><A HREF="#823_only_a_nonMvolatile_const_reference_can_be_bound_to_temporary">823 only a non-volatile const reference can be bound to temporary</A>
<BR><A HREF="#824_conversion_of_pointer_to_member_across_a_virtual_base">824 conversion of pointer to member across a virtual base</A>
<BR><A HREF="#825_declaration_cannot_be_in_the_same_scope_as_namespace___S_">825 declaration cannot be in the same scope as namespace '%S'</A>
<BR><A HREF="#826___S__cannot_be_in_the_same_scope_as_a_namespace">826 '%S' cannot be in the same scope as a namespace</A>
<BR><A HREF="#827_File___s">827 File:&nbsp; %s</A>
<BR><A HREF="#828__s">828 %s</A>
<BR><A HREF="#829__s___s">829 %s:&nbsp; %s</A>
<BR><A HREF="#830__s___S">830 %s:&nbsp; %S</A>
<BR><A HREF="#831_possible_override_is___S_">831 possible override is '%S'</A>
<BR><A HREF="#832_function_being_overridden_is___S_">832 function being overridden is '%S'</A>
<BR><A HREF="#833_name_does_not_reference_a_namespace">833 name does not reference a namespace</A>
<BR><A HREF="#834_namespace_alias_cannot_be_changed">834 namespace alias cannot be changed</A>
<BR><A HREF="#835_cannot_throw_undefined_class_object">835 cannot throw undefined class object</A>
<BR><A HREF="#836_symbol_has_different_type_than_previous_symbol_in_same_declaration">836 symbol has different type than previous symbol in same declaration</A>
<BR><A HREF="#837_companion_definition_is___S_">837 companion definition is '%S'</A>
<BR><A HREF="#838_syntax_errorS_default_argument_cannot_be_processed">838 syntax error; default argument cannot be processed</A>
<BR><A HREF="#839_default_argument_started__L">839 default argument started %L</A>
<BR><A HREF="#840___N__cannot_be_declared_in_a_namespace">840 '%N' cannot be declared in a namespace</A>
<BR><A HREF="#841_namespace_cannot_be_defined_in_a_nonMnamespace_scope">841 namespace cannot be defined in a non-namespace scope</A>
<BR><A HREF="#842_namespace______qualifier_cannot_be_used_in_this_context">842 namespace '::' qualifier cannot be used in this context</A>
<BR><A HREF="#843_cannot_cast_away_volatility">843 cannot cast away volatility</A>
<BR><A HREF="#844_cannot_cast_away_constness_and_volatility">844 cannot cast away constness and volatility</A>
<BR><A HREF="#845_cannot_cast_away_unaligned">845 cannot cast away unaligned</A>
<BR><A HREF="#846_subscript_expression_must_be_integral">846 subscript expression must be integral</A>
<BR><A HREF="#847_extension__nonMstandard_userMdefined_conversion">847 extension:&nbsp; non-standard user-defined conversion</A>
<BR><A HREF="#848_useless_using_directive_ignored">848 useless using directive ignored</A>
<BR><A HREF="#849_base_class_virtual_function_has_not_been_overridden">849 base class virtual function has not been overridden</A>
<BR><A HREF="#850_virtual_function_is___S_">850 virtual function is '%S'</A>
<BR><A HREF="#851_macro___s__defined__L">851 macro '%s' defined %L</A>
<BR><A HREF="#852_expanding_macro___s__defined__L">852 expanding macro '%s' defined %L</A>
<BR><A HREF="#853_conversion_to_common_class_type_is_impossible">853 conversion to common class type is impossible</A>
<BR><A HREF="#854_conversion_to_common_class_type_is_ambiguous">854 conversion to common class type is ambiguous</A>
<BR><A HREF="#855_conversion_to_common_class_type_requires_private_access">855 conversion to common class type requires private access</A>
<BR><A HREF="#856_conversion_to_common_class_type_requires_protected_access">856 conversion to common class type requires protected access</A>
<BR><A HREF="#857_namespace_lookup_is_ambiguous">857 namespace lookup is ambiguous</A>
<BR><A HREF="#858_ambiguous_namespace_symbol_is___S_">858 ambiguous namespace symbol is '%S'</A>
<BR><A HREF="#859_attempt_to_static_cast_from_a_private_base_class">859 attempt to static_cast from a private base class</A>
<BR><A HREF="#860_attempt_to_static_cast_from_a_protected_base_class">860 attempt to static_cast from a protected base class</A>
<BR><A HREF="#861_qualified_symbol_cannot_be_defined_in_this_scope">861 qualified symbol cannot be defined in this scope</A>
<BR><A HREF="#862_using_declaration_references_nonMmember">862 using declaration references non-member</A>
<BR><A HREF="#863_using_declaration_references_class_member">863 using declaration references class member</A>
<BR><A HREF="#864_invalid_suffix_for_a_constant">864 invalid suffix for a constant</A>
<BR><A HREF="#865_class_in_using_declaration_L__T_R_must_be_a_base_class">865 class in using declaration ('%T') must be a base class</A>
<BR><A HREF="#866_name_in_using_declaration_is_already_in_scope">866 name in using declaration is already in scope</A>
<BR><A HREF="#867_conflict_with_a_previous_usingMdecl___S_">867 conflict with a previous using-decl '%S'</A>
<BR><A HREF="#868_conflict_with_current_usingMdecl___S_">868 conflict with current using-decl '%S'</A>
<BR><A HREF="#869_use_of___N__requires_build_target_to_be_multiMthreaded">869 use of '%N' requires build target to be multi-threaded</A>
<BR><A HREF="#870_implementation_restriction__cannot_use_64Mbit_value_in_switch_statement">870 implementation restriction:&nbsp; cannot use 64-bit value in switch statement</A>
<BR><A HREF="#871_implementation_restriction__cannot_use_64Mbit_value_in_case_statement">871 implementation restriction:&nbsp; cannot use 64-bit value in case statement</A>
<BR><A HREF="#872_implementation_restriction__cannot_use___int64_as_bitMfield_base_type">872 implementation restriction:&nbsp; cannot use __int64 as bit-field base type</A>
<BR><A HREF="#873_based_function_object_cannot_be_placed_in_nonMcode_segment___s__">873 based function object cannot be placed in non-code segment &quot;%s&quot;.</A>
<BR><A HREF="#874_Use_a_segment_name_ending_in___s___or_the_default_code_segment___CODE__">874 Use a segment name ending in &quot;%s&quot;, or the default code segment &quot;_CODE&quot;.</A>
<BR><A HREF="#875_RTTI_must_be_enabled_to_use_feature_Luse__xr__optionR">875 RTTI must be enabled to use feature (use 'xr' option)</A>
<BR><A HREF="#876__typeid__class_type_must_be_defined">876 'typeid' class type must be defined</A>
<BR><A HREF="#877_cast_involves_unrelated_member_pointers">877 cast involves unrelated member pointers</A>
<BR><A HREF="#878_unexpected_type_modifier_found">878 unexpected type modifier found</A>
<BR><A HREF="#879_invalid_bitMfield_name___N_">879 invalid bit-field name '%N'</A>
<BR><A HREF="#880__u_padding_byteLsR_added">880 %u padding byte(s) added</A>
<BR><A HREF="#881_cannot_be_called_with_a___T_T_">881 cannot be called with a '%T *'</A>
<BR><A HREF="#882_cast_involves_an_undefined_member_pointer">882 cast involves an undefined member pointer</A>
<BR><A HREF="#883_cast_changes_both_member_pointer_object_and_class_type">883 cast changes both member pointer object and class type</A>
<BR><A HREF="#884_virtual_function___S__has_a_different_calling_convention">884 virtual function '%S' has a different calling convention</A>
<BR><A HREF="#885__endif_matches__if_in_different_source_file">885 #endif matches #if in different source file</A>
<BR><A HREF="#886_preprocessing_directive_found__L">886 preprocessing directive found %L</A>
<BR><A HREF="#887_unary__M__of_unsigned_operand_produces_unsigned_result">887 unary '-' of unsigned operand produces unsigned result</A>
<BR><A HREF="#888_trigraph_expansion_produced___c_">888 trigraph expansion produced '%c'</A>
<BR><A HREF="#889_hexadecimal_escape_sequence_out_of_rangeS_truncated">889 hexadecimal escape sequence out of range; truncated</A>
<BR><A HREF="#890_undefined_macro___s__evaluates_to_0">890 undefined macro '%s' evaluates to 0</A>
<BR><A HREF="#891_char_constant_has_value__u_Lmore_than_8_bitsR">891 char constant has value %u (more than 8 bits)</A>
<BR><A HREF="#892_promotion_of_unadorned_char_type_to_int">892 promotion of unadorned char type to int</A>
<BR><A HREF="#893_switch_statement_has_no_case_labels">893 switch statement has no case labels</A>
<BR><A HREF="#894_unexpected_character_L_uR_in_source_file">894 unexpected character (%u) in source file</A>
<BR><A HREF="#895_ignoring_whitespace_after_line_splice">895 ignoring whitespace after line splice</A>
<BR><A HREF="#896_empty_member_declaration">896 empty member declaration</A>
<BR><A HREF="#897___S__makes_use_of_a_nonMportable_feature_LzeroMsized_arrayR">897 '%S' makes use of a non-portable feature (zero-sized array)</A>
<BR><A HREF="#898_inMclass_initialization_is_only_allowed_for_const_static_integral_members">898 in-class initialization is only allowed for const static integral members</A>
<BR><A HREF="#899_cannot_convert_expression_to_target_type">899 cannot convert expression to target type</A>
<DT>- 9 -
<DD><A HREF="#900_unknown_template_specialization_of___S_">900 unknown template specialization of '%S'</A>
<BR><A HREF="#901_wrong_number_of_template_arguments_for___S_">901 wrong number of template arguments for '%S'</A>
<BR><A HREF="#902_cannot_explicitly_specialize_member_of___S_">902 cannot explicitly specialize member of '%S'</A>
<BR><A HREF="#903_specialization_arguments_for___S__match_primary_template">903 specialization arguments for '%S' match primary template</A>
<BR><A HREF="#904_partial_template_specialization_for___S__ambiguous">904 partial template specialization for '%S' ambiguous</A>
<BR><A HREF="#905_static_assertion_failed___s_">905 static assertion failed '%s'</A>
<BR><A HREF="#906_Exported_templates_are_not_supported_by_Open_Watcom_CPP">906 Exported templates are not supported by Open Watcom C++</A>
<BR><A HREF="#907_redeclaration_of_member_function___S__not_allowed">907 redeclaration of member function '%S' not allowed</A>
<BR><A HREF="#909_Invalid_register_name___s__in__pragma">909 Invalid register name '%s' in #pragma</A>
<BR><A HREF="#910_Archaic_syntax__classDstruct_missing_in_explicit_template_instantiation">910 Archaic syntax:&nbsp; class/struct missing in explicit template instantiation</A>
<BR><A HREF="#911_destructor_for_type_void_cannot_be_called">911 destructor for type void cannot be called</A>
<BR><A HREF="#912__typename__keyword_used_outside_template">912 'typename' keyword used outside template</A>
<BR><A HREF="#913___N__does_not_have_a_return_type_specified">913 '%N' does not have a return type specified</A>
<BR><A HREF="#914__main__must_return__int_">914 'main' must return 'int'</A>
<BR><A HREF="#915_explicit_may_only_be_used_within_class_definition">915 explicit may only be used within class definition</A>
<BR><A HREF="#916_virtual_may_only_be_used_within_class_definition">916 virtual may only be used within class definition</A>
<BR><A HREF="#917_cannot_redefine_default_template_argument___N_">917 cannot redefine default template argument '%N'</A>
<BR><A HREF="#918_cannot_have_default_template_arguments_in_partial_specializations">918 cannot have default template arguments in partial specializations</A>
<BR><A HREF="#919_delete_of_a_pointer_to_void">919 delete of a pointer to void</A>
<BR><A HREF="#920__long_char__is_deprecated__use_wchar_t_instead">920 'long char' is deprecated, use wchar_t instead</A>
<BR><A HREF="#921_namespace___I__not_allowed_in_usingMdeclaration">921 namespace '%I' not allowed in using-declaration</A>
<BR><A HREF="#923_qualified_name___I__does_not_name_a_class">923 qualified name '%I' does not name a class</A>
<BR><A HREF="#924_expected_class_type__but_got___T_">924 expected class type, but got '%T'</A>
<BR><A HREF="#925_syntax_error_near___s_S_probable_cause__incorrectly_spelled_type_name">925 syntax error near '%s'; probable cause:&nbsp; incorrectly spelled type name</A>
<BR><A HREF="#926_syntax_error____s__has_not_been_declared_as_a_member">926 syntax error:&nbsp; '%s' has not been declared as a member</A>
<BR><A HREF="#927_syntax_error____s__has_not_been_declared">927 syntax error:&nbsp; '%s' has not been declared</A>
<BR><A HREF="#930_member___S__cannot_be_declared_in_this_class">930 member '%S' cannot be declared in this class</A>
<BR><A HREF="#931_cvMqualifier_in_cast_to___T__is_meaningless">931 cv-qualifier in cast to '%T' is meaningless</A>
<BR><A HREF="#932_cvMqualifier_in_return_type___T__is_meaningless">932 cv-qualifier in return type '%T' is meaningless</A>
<BR><A HREF="#933_use_of_CMstyle_cast_to___T__is_discouraged">933 use of C-style cast to '%T' is discouraged</A>
<BR><A HREF="#934_unable_to_match_function_template_definition___S_">934 unable to match function template definition '%S'</A>
<BR><A HREF="#935_form_is___pragma_enable_messageL_msgnum_R_">935 form is '#pragma enable_message( msgnum )'</A>
<BR><A HREF="#936_form_is___pragma_disable_messageL_msgnum_R_">936 form is '#pragma disable_message( msgnum )'</A>
<BR><A HREF="#937_option_requires_a_character">937 option requires a character</A>
<BR><A HREF="#938__auto__is_no_longer_a_storage_specifier_in_CPP11_mode">938 'auto' is no longer a storage specifier in C++11 mode</A>
<BR><A HREF="#939_Implicit_conversion_from__decltypeLnullptrR__to__bool__">939 Implicit conversion from 'decltype(nullptr)' to 'bool'.</A>
<DT>- O -
<DD><A HREF="#Open_Watcom_CPP_Diagnostic_Messages">Open Watcom C++ Diagnostic Messages</A>
</DL>
<H1 ID="Open_Watcom_CPP_Diagnostic_Messages"> Open Watcom C++ Diagnostic Messages </H1>
<BR>The following is a list of all warning and error messages produced by the Open Watcom C++ compilers.&nbsp; Diagnostic
messages are issued during compilation and execution.
<BR><BR>The messages listed in the following sections contain references to<TT> %N, %S, %T, %s, %d</TT> and<TT> %u.</TT>&nbsp;
They represent strings that are substituted by the Open Watcom C++ compilers to make the error message more exact.<TT>&nbsp;
%d</TT> and<TT> %u</TT> represent a string of digits;<TT> %N, %S, %T</TT> and<TT> %s</TT> a string, usually a symbolic name.
<BR><BR>Consider the following program, named<TT> err.cpp</TT>, which contains errors.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 13143.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Integer value is %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Floating-point value is %f\n&quot;, x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If we compile the above program, the following messages will appear on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; File: err.cpp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (6,12): Error! E042: symbol 'i' already defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'i' declared at: (5,9)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (9,5): Error! E029: symbol 'x' has not been declared</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; err.cpp: 12 lines, included 174, no warnings, 2 errors</TT>
<BR><BR>The diagnostic messages consist of the following information:
<OL>
<LI>the name of the file being compiled,
<LI>the line number and column of the line containing the error (in parentheses),
<LI>a message number, and
<LI>text explaining the nature of the error.
</OL>
<BR>In the above example, the first error occurred on line 6 of the file<TT> err.cpp.</TT>&nbsp; Error number 042 (with the
appropriate substitutions) was diagnosed.&nbsp; The second error occurred on line 9 of the file<TT> err.cpp.</TT>&nbsp; Error
number 029 (with the appropriate substitutions) was diagnosed.
<BR><BR>The following sections contain a complete list of the messages.&nbsp; Run-time messages (messages displayed during
execution) do not have message numbers associated with them.
<BR><BR>A number of messages contain a reference to the ARM.&nbsp; This is the &quot;Annotated C++ Reference Manual&quot;
written by Margaret A.&nbsp; Ellis and Bjarne Stroustrup and published by Addison-Wesley (ISBN 0-201-51459-1).
<H2 ID="000_internal_compiler_error"> 000 internal compiler error </H2>
<BR>If this message appears, please report the problem directly to the Open Watcom development team.&nbsp; See http://www.openwatcom.org/.
<H2 ID="001_assignment_of_constant_found_in_boolean_expression"> 001 assignment of constant found in boolean expression </H2>
<BR>An assignment of a constant has been detected in a boolean expression.&nbsp; For example:&nbsp; &quot;if( var = 0 )&quot;.
&nbsp;It is most likely that you want to use &quot;==&quot; for testing for equality.
<H2 ID="002_constant_out_of_rangeS_truncated"> 002 constant out of range; truncated </H2>
<BR>This message is issued if a constant cannot be represented in 32 bits or if a constant is outside the range of valid values
that can be assigned to a variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a = 12345678901234567890;</TT>
<H2 ID="003_missing_return_value"> 003 missing return value </H2>
<BR>A function has been declared with a non-void return type, but no<B><I> return</I></B> statement was found in the function.
&nbsp;Either add a<B><I> return</I></B> statement or change the function return type to<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = a + a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The message will be issued at the end of the function.
<H2 ID="004_base_class___T__does_not_have_a_virtual_destructor"> 004 base class '%T' does not have a virtual destructor </H2>
<BR>A virtual destructor has been declared in a class with base classes.&nbsp; However, one of those base classes does not
have a virtual destructor.&nbsp; A<B><I> delete</I></B> of a pointer cast to such a base class will not function properly
in all circumstances.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Base();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : Base {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual ~Derived();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>It is considered good programming practice to declare virtual destructors in all classes used as base classes of classes
having virtual destructors.
<H2 ID="005_pointer_or_reference_truncated"> 005 pointer or reference truncated </H2>
<BR>The expression contains a transfer of a pointer value to another pointer value of smaller size.&nbsp; This can be caused
by<B><I> __near</I></B> or<B><I> __far</I></B> qualifiers (i.e., assigning a<B><I> far</I></B> pointer to a<B><I> near</I></B>
pointer).&nbsp; Function pointers can also have a different size than data pointers in certain memory models.&nbsp; This message
indicates that some information is being lost so check the code carefully.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __far *foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far *p_far = foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __near *p_near = p_far; // truncated</TT>
<H2 ID="006_syntax_errorS_probable_cause__missing__S_"> 006 syntax error; probable cause:&nbsp; missing ';' </H2>
<BR>The compiler has found a complete expression (or declaration) during parsing but could not continue.&nbsp; The compiler
has detected that it could have continued if a semicolon was present so there may be a semicolon missing.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; // missing ';'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="007___array__may_not_produce_intended_result"> 007 '&amp;array' may not produce intended result </H2>
<BR>The type of the expression '&amp;array' is different from the type of the expression 'array'.&nbsp; Suppose we have the
declaration<TT> char buffer[80].</TT>&nbsp; Then the expression<TT> (&amp;buffer + 3)</TT> will be evaluated as<TT> (buffer
+ 3 * sizeof(buffer))</TT> which is<TT> (buffer + 3 * 80)</TT> and not<TT> (buffer + 3 * 1)</TT> which is what one may have
expected.&nbsp; The address-of operator '&amp;' is not required for getting the address of an array.
<H2 ID="008_returning_address_of_function_argument_or_of_auto_or_register_variable"> 008 returning address of function argument or of auto or register variable </H2>
<BR>This warning usually indicates a serious programming error.&nbsp; When a function exits, the storage allocated on the
stack for auto variables is released.&nbsp; This storage will be overwritten by further function calls and/or hardware interrupt
service routines.&nbsp; Therefore, the data pointed to by the return value may be destroyed before your program has a chance
to reference it or make a copy of it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k = 123;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // k is automatic variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="009_option_requires_a_file_name"> 009 option requires a file name </H2>
<BR>The specified option is not recognized by the compiler since there was no file name after it (i.e., &quot;-fo=my.obj&quot;
).
<H2 ID="010_asm_directive_ignored"> 010 asm directive ignored </H2>
<BR>The asm directive (e.g., asm( &quot;mov r0,1&quot; ); ) is a non-portable construct.&nbsp; The Open Watcom C++ compiler
treats all asm directives like comments.
<H2 ID="011_all_members_are_private"> 011 all members are private </H2>
<BR>This message warns the programmer that there will be no way to use the contents of the class because all accesses will
be flagged as erroneous (i.e., accessing a private member).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Private {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Private();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Private();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Private( const Private&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="012_template_argument_cannot_be_type___T_"> 012 template argument cannot be type '%T' </H2>
<BR>A template argument can be either a generic type (e.g.,<TT> template &lt; class</TT> T<TT> &gt;</TT> ), a pointer, or
an integral type.&nbsp; These types are required for expressions that can be checked at compile time.
<H2 ID="013_unreachable_code"> 013 unreachable code </H2>
<BR>The indicated statement will never be executed because there is no path through the program that causes control to reach
that statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p = 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p = 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The statement following the<B><I> return</I></B> statement cannot be reached.
<H2 ID="014_no_reference_to_symbol___S_"> 014 no reference to symbol '%S' </H2>
<BR>There are no references to the declared variable.&nbsp; The declaration for the variable can be deleted.&nbsp; If the
variable is a parameter to a function, all calls to the function must also have the value for that parameter deleted.
<BR><BR>In some cases, there may be a valid reason for retaining the variable.&nbsp; You can prevent the message from being
issued through use of<B> #pragma off(unreferenced),</B> or adding a statement that assigns the variable to itself.
<H2 ID="015_nested_comment_found_in_comment_started_on_line__u"> 015 nested comment found in comment started on line %u </H2>
<BR>While scanning a comment for its end, the compiler detected<TT> /*</TT> for the start of another comment.&nbsp; Nested
comments are not allowed in ISO/ANSI C.&nbsp; You may be missing the<TT> */</TT> for the previous comment.
<H2 ID="016_template_argument_list_cannot_be_empty"> 016 template argument list cannot be empty </H2>
<BR>An empty template argument list would result in a template that could only define a single class or function.
<H2 ID="017_label___s__has_not_been_referenced_by_a_goto"> 017 label '%s' has not been referenced by a goto </H2>
<BR>The indicated label has not been referenced and, as such, is useless.&nbsp; This warning can be safely ignored.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; un_refed:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="018_no_reference_to_anonymous_union_member___S_"> 018 no reference to anonymous union member '%S' </H2>
<BR>The declaration for the anonymous member can be safely deleted without any effect.
<H2 ID="019__break__may_only_appear_in_a_for__do__while__or_switch_statement"> 019 'break' may only appear in a for, do, while, or switch statement </H2>
<BR>A<B><I> break</I></B> statement has been found in an illegal place in the program.&nbsp; You may be missing an opening
brace<TT> {</TT> for a<B><I> while,</I></B> <B><I> do,</I></B> <B><I> for</I></B> or<B><I> switch</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a+b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="020__case__may_only_appear_in_a_switch_statement"> 020 'case' may only appear in a switch statement </H2>
<BR>A<B><I> case</I></B> label has been found that is not inside a<B><I> switch</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:&nbsp;&nbsp;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a+b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="021__continue__may_only_appear_in_a_for__do__or_while_statement"> 021 'continue' may only appear in a for, do, or while statement </H2>
<BR>The<B><I> continue</I></B> statement must be inside a<B><I> while,</I></B> <B><I> do</I></B> or<B><I> for</I></B> statement.
&nbsp;You may have too many<TT> }</TT> between the<B><I> while,</I></B> <B><I> do</I></B> or<B><I> for</I></B> statement and
the<B><I> continue</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;&nbsp;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a+b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="022__default__may_only_appear_in_a_switch_statement"> 022 'default' may only appear in a switch statement </H2>
<BR>A<B><I> default</I></B> label has been found that is not inside a<B><I> switch</I></B> statement.&nbsp; You may have too
many<TT> }</TT> between the start of the<B><I> switch</I></B> and the<B><I> default</I></B> label.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a+b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="023_misplaced_____or_missing_earlier____"> 023 misplaced '}' or missing earlier '{' </H2>
<BR>An extra<TT> }</TT> has been found which cannot be matched up with an earlier<TT> {.</TT>
<H2 ID="024_misplaced__elif_directive"> 024 misplaced #elif directive </H2>
<BR>The<B><I> #elif</I></B> directive must be inside an<B><I> #if</I></B> preprocessing group and before the<B><I> #else</I></B>
directive if present.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elif IN_IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The<B><I> #else,</I></B> <B><I> #elif,</I></B> and<B><I> #endif</I></B> statements are all illegal because there is
no<B><I> #if</I></B> that corresponds to them.
<H2 ID="025_misplaced__else_directive"> 025 misplaced #else directive </H2>
<BR>The<B><I> #else</I></B> directive must be inside an<B><I> #if</I></B> preprocessing group and follow all<B><I> #elif</I></B>
directives if present.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elif IN_IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The<B><I> #else,</I></B> <B><I> #elif,</I></B> and<B><I> #endif</I></B> statements are all illegal because there is
no<B><I> #if</I></B> that corresponds to them.
<H2 ID="026_misplaced__endif_directive"> 026 misplaced #endif directive </H2>
<BR>A<B><I> #endif</I></B> preprocessing directive has been found without a matching<B><I> #if</I></B> directive.&nbsp; You
either have an extra<B><I> #endif</I></B> or you are missing an<B><I> #if</I></B> directive earlier in the file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elif IN_IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The<B><I> #else,</I></B> <B><I> #elif,</I></B> and<B><I> #endif</I></B> statements are all illegal because there is
no<B><I> #if</I></B> that corresponds to them.
<H2 ID="027_only_one__default__per_switch_statement_is_allowed"> 027 only one 'default' per switch statement is allowed </H2>
<BR>You cannot have more than one<B><I> default</I></B> label in a<B><I> switch</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int translate( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 8;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="028_expecting___s__but_found___s_"> 028 expecting '%s' but found '%s' </H2>
<BR>A syntax error has been detected.&nbsp; The tokens displayed in the message should help you to determine the problem.
<H2 ID="029_symbol___N__has_not_been_declared"> 029 symbol '%N' has not been declared </H2>
<BR>The compiler has found a symbol which has not been previously declared.&nbsp; The symbol may be spelled differently than
the declaration, or you may need to<B><I> #include</I></B> a header file that contains the declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a = b;&nbsp; // b has not been declared</TT>
<H2 ID="030_left_expression_must_be_a_function_or_a_function_pointer"> 030 left expression must be a function or a function pointer </H2>
<BR>The compiler has found an expression that looks like a function call, but it is not defined as a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b = a( 12 );</TT>
<H2 ID="031_operand_must_be_an_lvalue"> 031 operand must be an lvalue </H2>
<BR>The operand on the left side of an &quot;=&quot; sign must be a variable or memory location which can have a value assigned
to it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( a + 1 ) = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = ++ ( a + 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Both statements within the function are erroneous, since lvalues are expected where the additions are shown.
<H2 ID="032_label___s__already_defined"> 032 label '%s' already defined </H2>
<BR>All labels within a function must be unique.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bar( int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; label:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; label:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The second label is illegal.
<H2 ID="033_label___s__is_not_defined_in_function"> 033 label '%s' is not defined in function </H2>
<BR>A<B><I> goto</I></B> statement has referenced a label that is not defined in the function.&nbsp; Add the necessary label
or check the spelling of the label(s) in the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bar( int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; labl:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto label;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The label referenced in the<B><I> goto</I></B> is not defined.
<H2 ID="034_dimension_cannot_be_zero"> 034 dimension cannot be zero </H2>
<BR>The dimension of an array must be non-zero.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array[0];&nbsp;&nbsp; // not allowed</TT>
<H2 ID="035_dimension_cannot_be_negative"> 035 dimension cannot be negative </H2>
<BR>The dimension of an array must be positive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array[-1];&nbsp; // not allowed</TT>
<H2 ID="036_dimensions_of_multiMdimension_array_must_be_specified"> 036 dimensions of multi-dimension array must be specified </H2>
<BR>All dimensions of a multiple dimension array must be specified.&nbsp; The only exception is the first dimension which
can declared as &quot;[]&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array[][];&nbsp;&nbsp; // not allowed</TT>
<H2 ID="037_invalid_storage_class_for_function"> 037 invalid storage class for function </H2>
<BR>If a storage class is given for a function, it must be<B><I> static</I></B> or<B><I> extern.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; auto void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="038_expression_must_have_pointer_type"> 038 expression must have pointer type </H2>
<BR>An attempt has been made to de-reference a variable or expression which is not declared to be a pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b = *a;</TT>
<H2 ID="039_cannot_take_address_of_an_rvalue"> 039 cannot take address of an rvalue </H2>
<BR>You can only take the address of a variable or memory location.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *p1 = &amp; &amp; c;&nbsp;&nbsp; // not allowed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *p2 = &amp; (c+1); // not allowed</TT>
<H2 ID="040_expression_for_____must_be_a_class__struct_or_union"> 040 expression for '.' must be a class, struct or union </H2>
<BR>The compiler has encountered the pattern &quot;expression&quot; &quot;.&quot; &quot;field_name&quot; where the expression
is not a<B><I> class,</I></B> <B><I> struct</I></B> or<B><I> union</I></B> type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp;fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a = fun().a;</TT>
<H2 ID="041_expression_for__MY__must_be_pointer_to_class__struct_or_union"> 041 expression for '-&gt;' must be pointer to class, struct or union </H2>
<BR>The compiler has encountered the pattern &quot;expression&quot; &quot;-&gt;&quot; &quot;field_name&quot; where the expression
is not a pointer to<B><I> class,</I></B> <B><I> struct</I></B> or<B><I> union</I></B> type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a = fun()-&gt;a;</TT>
<H2 ID="042_symbol___S__already_defined"> 042 symbol '%S' already defined </H2>
<BR>The specified symbol has already been defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char a = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char a = 2; // not allowed</TT>
<H2 ID="043_static_function___S__has_not_been_defined"> 043 static function '%S' has not been defined </H2>
<BR>A prototype has been found for a<B><I> static</I></B> function, but a definition for the<B><I> static</I></B> function
has not been found in the file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int fun( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // fun not defined by end of program</TT>
<H2 ID="044_expecting_label_for_goto_statement"> 044 expecting label for goto statement </H2>
<BR>The<B><I> goto</I></B> statement requires the name of a label.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fun( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="045_duplicate_case_value___s__found"> 045 duplicate case value '%s' found </H2>
<BR>Every case value in a<B><I> switch</I></B> statement must be unique.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fun( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1: // duplicate not allowed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 79;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="046_bitMfield_width_is_too_large"> 046 bit-field width is too large </H2>
<BR>The maximum field width allowed is 16 bits in the 16-bit compiler and 32 bits in the 32-bit compiler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned bitfield :48;&nbsp; // too wide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="047_width_of_a_named_bitMfield_must_not_be_zero"> 047 width of a named bit-field must not be zero </H2>
<BR>A bit field must be at least one bit in size.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bitfield :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int :0;&nbsp;&nbsp; // okay, aligns to int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int h :0; // error, field is named</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="048_bitMfield_width_must_be_positive"> 048 bit-field width must be positive </H2>
<BR>You cannot have a negative field width.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned bitfield :-10; // cannot be negative</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="049_bitMfield_base_type_must_be_an_integral_type"> 049 bit-field base type must be an integral type </H2>
<BR>The types allowed for bit fields are<B><I> signed</I></B> or<B><I> unsigned</I></B> varieties of<B><I> char,</I></B> <B><I>
short</I></B> and<B><I> int.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float bitfield : 10;&nbsp;&nbsp;&nbsp; // must be integral</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="050_subscript_on_nonMarray"> 050 subscript on non-array </H2>
<BR>One of the operands of '[]' must be an array or a pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i1 = array[0];&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i2 = 0[array];&nbsp; // same as above</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i3 = 0[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // illegal</TT>
<H2 ID="051_incomplete_comment"> 051 incomplete comment </H2>
<BR>The compiler did not find<TT> */</TT> to mark the end of a comment.
<H2 ID="052_argument_for___must_be_a_macro_parm"> 052 argument for # must be a macro parm </H2>
<BR>The argument for the stringize operator '#' must be a macro parameter.
<H2 ID="053_unknown_preprocessing_directive____s_"> 053 unknown preprocessing directive '#%s' </H2>
<BR>An unrecognized preprocessing directive has been encountered.&nbsp; Check for correct spelling.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #i_goofed&nbsp;&nbsp; // not valid</TT>
<H2 ID="054_invalid__include_directive"> 054 invalid #include directive </H2>
<BR>A syntax error has been encountered in a<B><I> #include</I></B> directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include&nbsp;&nbsp;&nbsp; // no header file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include stdio.h</TT>
<BR><BR>Both examples are illegal.
<H2 ID="055_not_enough_parameters_given_for_macro___s_"> 055 not enough parameters given for macro '%s' </H2>
<BR>You have not supplied enough parameters to the specified macro.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define mac(a,b) a+b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = mac(123);&nbsp;&nbsp; // needs 2 parameters</TT>
<H2 ID="056_not_expecting_a_return_value"> 056 not expecting a return value </H2>
<BR>The specified function is declared as a<B><I> void</I></B> function.&nbsp; Delete the<B><I> return</I></B> value, or change
the type of the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fun()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 14;&nbsp; // not expecting return value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="057_cannot_take_address_of_a_bitMfield"> 057 cannot take address of a bit-field </H2>
<BR>The smallest addressable unit is a byte.&nbsp; You cannot take the address of a bit field.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; int bits :6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bitfield :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S var;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p = &amp;var.bitfield;&nbsp;&nbsp;&nbsp; // illegal</TT>
<H2 ID="058_expression_must_be_a_constant"> 058 expression must be a constant </H2>
<BR>The compiler expects a constant expression.&nbsp; This message can occur during static initialization if you are trying
to initialize a non-pointer type with an address expression.
<H2 ID="059_unable_to_open___s_"> 059 unable to open '%s' </H2>
<BR>The file specified in an<B><I> #include</I></B> directive could not be located.&nbsp; Make sure that the file name is
spelled correctly, or that the appropriate path for the file is included in the list of paths specified in the<B> INCLUDE</B>
or<B> INCLUDE</B> environment variables or in the &quot;i=&quot; option on the command line.
<H2 ID="060_too_many_parameters_given_for_macro___s_"> 060 too many parameters given for macro '%s' </H2>
<BR>You have supplied too many parameters for the specified macro.&nbsp; The extra parameters are ignored.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define mac(a,b) a+b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = mac(1,2,3); // needs 2 parameters</TT>
<H2 ID="061_cannot_use___based_or___far16_pointers_in_this_context"> 061 cannot use __based or __far16 pointers in this context </H2>
<BR>The use of<B><I> __based</I></B> and<B><I> __far16</I></B> pointers is prohibited in<B><I> throw</I></B> expressions and<B><I>
catch</I></B> statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __based( __segname( &quot;myseg&quot; ) ) *pi;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bad()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw pi;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( int __far16 *p16 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p16 = 87;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Both the<B><I> throw</I></B> expression and<B><I> catch</I></B> statements cause this error to be diagnosed.
<H2 ID="062_only_one_type_is_allowed_in_declaration_specifiers"> 062 only one type is allowed in declaration specifiers </H2>
<BR>Only one type is allowed for the first part of a declaration.&nbsp; A common cause of this message is that there may be
a missing semi-colon (';') after a class definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs &quot;;&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo() { return 7; }</TT>
<H2 ID="063_out_of_memory"> 063 out of memory </H2>
<BR>The compiler has run out of memory to store information about the file being compiled.&nbsp; Try reducing the number of
data declarations and or the size of the file being compiled.&nbsp; Do not<B><I> #include</I></B> header files that are not
required.
<H2 ID="064_invalid_character_constant"> 064 invalid character constant </H2>
<BR>This message is issued for an improperly formed character constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char c = '12345';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char d = ''';</TT>
<H2 ID="065_taking_address_of_variable_with_storage_class__register_"> 065 taking address of variable with storage class 'register' </H2>
<BR>You can take the address of a<B><I> register</I></B> variable in C++ (but not in ISO/ANSI C).&nbsp; If there is a chance
that the source will be compiled using a C compiler, change the storage class from<B><I> register</I></B> to<B><I> auto.</I></B>
&nbsp;
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( char* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int bar()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register char c = 'c';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return foo( &amp;c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="066__delete__expression_size_is_not_allowed"> 066 'delete' expression size is not allowed </H2>
<BR>The C++ language has evolved to the point where the<B><I> delete</I></B> expression size is no longer required for a correct
deletion of an array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( unsigned n, char *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [n] p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="067_ending___missing_for_string_literal"> 067 ending &quot; missing for string literal </H2>
<BR>The compiler did not find a second double quote to end the string literal.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *a = &quot;no_ending_quote;</TT>
<H2 ID="068_invalid_option"> 068 invalid option </H2>
<BR>The specified option is not recognized by the compiler.
<H2 ID="069_invalid_optimization_option"> 069 invalid optimization option </H2>
<BR>The specified option is an unrecognized optimization option.
<H2 ID="070_invalid_memory_model"> 070 invalid memory model </H2>
<BR>Memory model option must be one of &quot;ms&quot;, &quot;mm&quot;, &quot;mc&quot;, &quot;ml&quot;, &quot;mh&quot; or &quot;mf&quot;
which selects the Small, Medium, Compact, Large, Huge or Flat memory model.
<H2 ID="071_expression_must_be_integral"> 071 expression must be integral </H2>
<BR>An integral expression is required.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, float b, int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1.3:&nbsp;&nbsp;&nbsp;&nbsp; // must be integral</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p[b];&nbsp;&nbsp;&nbsp; // index not integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b &lt;&lt;= 2;&nbsp;&nbsp;&nbsp; // can only shift integers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="072_expression_must_be_arithmetic"> 072 expression must be arithmetic </H2>
<BR>Arithmetic operations, such as &quot;/&quot; and &quot;*&quot;, require arithmetic operands unless the operation has been
overloaded or unless the operands can be converted to arithmetic operands.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C cv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = cv / 2;</TT>
<H2 ID="073_statement_required_after_label"> 073 statement required after label </H2>
<BR>The C language definition requires a statement following a label.&nbsp; You can use a null statement which consists of
just a semicolon (&quot;;&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int bar( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( a ) goto ending;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bar( a );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ending:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs statement following</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="074_statement_required_after__do_"> 074 statement required after 'do' </H2>
<BR>A statement is required between the<B><I> do</I></B> and<B><I> while</I></B> keywords.
<H2 ID="075_statement_required_after__case_"> 075 statement required after 'case' </H2>
<BR>The C language definition requires a statement following a<B><I> case</I></B> label.&nbsp; You can use a null statement
which consists of just a semicolon (&quot;;&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1: // needs statement following</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 18;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="076_statement_required_after__default_"> 076 statement required after 'default' </H2>
<BR>The C language definition requires a statement following a<B><I> default</I></B> label.&nbsp; You can use a null statement
which consists of just a semicolon (&quot;;&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs statement following</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 18;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="077_missing_matching__endif_directive"> 077 missing matching #endif directive </H2>
<BR>You are missing a<B><I> #endif</I></B> to terminate a<B><I> #if,</I></B> <B><I> #ifdef</I></B> or<B><I> #ifndef</I></B>
preprocessing directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // needs #endif</TT>
<H2 ID="078_invalid_macro_definition__missing__R_"> 078 invalid macro definition, missing ')' </H2>
<BR>The right parenthesis &quot;)&quot; is required for a function-like macro definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define bad_mac( a, b</TT>
<H2 ID="079_missing__R__for_expansion_of___s__macro"> 079 missing ')' for expansion of '%s' macro </H2>
<BR>The compiler encountered end-of-file while collecting up the argument for a function-like macro.&nbsp; A right parenthesis
&quot;)&quot; is required to mark the end of the argument(s) for a function-like macro.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define mac( a, b) a+b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int d = mac( 1, 2</TT>
<H2 ID="080__s"> 080 %s </H2>
<BR>This is a user message generated with the<B><I> #error</I></B> preprocessing directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #error my very own error message</TT>
<H2 ID="081_cannot_define_an_array_of_functions"> 081 cannot define an array of functions </H2>
<BR>You can have an array of pointers to functions, but not an array of functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int TD(float);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TD array[12];</TT>
<H2 ID="082_function_cannot_return_an_array"> 082 function cannot return an array </H2>
<BR>A function cannot return an array.&nbsp; You can return a pointer to an array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int ARR[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ARR fun( float );</TT>
<H2 ID="083_function_cannot_return_a_function"> 083 function cannot return a function </H2>
<BR>You cannot return a function.&nbsp; You can return a pointer to a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int TD();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TD fun( float );</TT>
<H2 ID="084_function_templates_can_only_have_type_arguments"> 084 function templates can only have type arguments </H2>
<BR>A function template argument can only be a generic type (e.g.,<TT> template &lt; class</TT> T<TT> &gt;</TT> ).&nbsp; This
is a restriction in the C++ language that allows compilers to automatically instantiate functions purely from the argument
types of calls.
<H2 ID="085_maximum_class_size_has_been_exceeded"> 085 maximum class size has been exceeded </H2>
<BR>The 16-bit compiler limits the size of a<B><I> struct</I></B> or<B><I> union</I></B> to 64K so that the compiler can represent
the offset of a member in a 16-bit register.&nbsp; This error also occurs if the size of a structure overflows the size of
an<B><I> unsigned</I></B> integer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char arr1[ 0xfffe ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char arr2[ 0xfffe ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char arr3[ 0xfffe ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char arr4[ 0xfffffffe ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="086_definition_of_macro___s__not_identical_to_previous_definition"> 086 definition of macro '%s' not identical to previous definition </H2>
<BR>If a macro is defined more than once, the definitions must be identical.&nbsp; If you want to redefine a macro to have
a different definition, you must<B><I> #undef</I></B> it before you can define it with a new definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define CON 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define CON 124&nbsp;&nbsp;&nbsp;&nbsp; // not same as previous</TT>
<H2 ID="087_initialization_of___S__must_be_in_file_scope"> 087 initialization of '%S' must be in file scope </H2>
<BR>A file scope variable must be initialized in file scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern int v = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="088_default_argument_for___S__declared_outside_of_class_definition"> 088 default argument for '%S' declared outside of class definition </H2>
<BR>Problems can occur with member functions that do not declare all of their default arguments during the class definition.
&nbsp;For instance, a copy constructor is declared if a class does not define a copy constructor.&nbsp; If a default argument
is added later on to a constructor that makes it a copy constructor, an ambiguity results.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( S const &amp;, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // S( S const &amp; );&nbsp; &lt;-- declared by compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // ambiguity with compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // generated copy constructor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // S( S const &amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::S( S const &amp;, int = 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="089____must_not_be_at_start_or_end_of_replacement_tokens"> 089 ## must not be at start or end of replacement tokens </H2>
<BR>There must be a token on each side of the &quot;##&quot; (token pasting) operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define badmac( a, b ) ## a ## b</TT>
<H2 ID="090_invalid_floatingMpoint_constant"> 090 invalid floating-point constant </H2>
<BR>The exponent part of the floating-point constant is not formed correctly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = 123.9E+Q;</TT>
<H2 ID="091__sizeof__is_not_allowed_for_a_bitMfield"> 091 'sizeof' is not allowed for a bit-field </H2>
<BR>The smallest object that you can ask for the size of is a char.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } v;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = sizeof( v.b );</TT>
<H2 ID="092_option_requires_a_path"> 092 option requires a path </H2>
<BR>The specified option is not recognized by the compiler since there was no path after it (i.e., &quot;-i=d:\include;d:\path&quot;
).
<H2 ID="093_must_use__va_start__macro_inside_function_with_variable_arguments"> 093 must use 'va_start' macro inside function with variable arguments </H2>
<BR>The<TT> va_start</TT> macro is used to setup access to the parameters in a function that takes a variable number of parameters.
&nbsp;A function is defined with a variable number of parameters by declaring the last parameter in the function as &quot;...&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, a );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="094_TTTFATALTTT__s"> 094 ***FATAL*** %s </H2>
<BR>A fatal error has been detected during code generation time.&nbsp; The type of error is displayed in the message.
<H2 ID="095_internal_compiler_error__d"> 095 internal compiler error %d </H2>
<BR>A bug has been encountered in the compiler.&nbsp; Please report the specified internal compiler error number and any other
helpful details about the program being compiled to the Open Watcom development team so that we can fix the problem.&nbsp;
See http://www.openwatcom.org/.
<H2 ID="096_argument_number__d_M_invalid_register_in__pragma"> 096 argument number %d - invalid register in #pragma </H2>
<BR>The designated registers cannot hold the value for the parameter.
<H2 ID="097_procedure___s__has_invalid_return_register_in__pragma"> 097 procedure '%s' has invalid return register in #pragma </H2>
<BR>The size of the return register does not match the size of the result returned by the function.
<H2 ID="098_illegal_register_modified_by___s___pragma"> 098 illegal register modified by '%s' #pragma </H2>
<BR><B>For the 16-bit Open Watcom C/C++ compiler:</B>&nbsp; The BP, CS, DS, and SS registers cannot be modified in small data
models.&nbsp; The BP, CS, and SS registers cannot be modified in large data models.
<BR><BR><B>For the 32-bit Open Watcom C/C++ compiler:</B>&nbsp; The EBP, CS, DS, ES, and SS registers cannot be modified in
flat memory models.&nbsp; The EBP, CS, DS, and SS registers cannot be modified in small data models.&nbsp; The EBP, CS, and
SS registers cannot be modified in large data models.
<H2 ID="099_file_must_contain_at_least_one_external_definition"> 099 file must contain at least one external definition </H2>
<BR>Every file must contain at least one global object, (either a data variable or a function).
<BR><BR>Note:&nbsp; This message has been disabled starting with Open Watcom v1.4.&nbsp; The ISO 1998 C++ standard allows
empty translation units.
<H2 ID="100_out_of_macro_space"> 100 out of macro space </H2>
<BR>The compiler ran out of memory for storing macro definitions.
<H2 ID="101_keyboard_interrupt_detected"> 101 keyboard interrupt detected </H2>
<BR>The compilation has been aborted with Ctrl/C or Ctrl/Break.
<H2 ID="102_duplicate_macro_parameter___s_"> 102 duplicate macro parameter '%s' </H2>
<BR>The parameters specified in a macro definition must be unique.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define badmac( a, b, a ) a ## b</TT>
<H2 ID="103_unable_to_open_work_file__error_code_E__d"> 103 unable to open work file:&nbsp; error code = %d </H2>
<BR>The compiler tries to open a new work file by the name &quot;__wrkN__.tmp&quot; where N is the digit 0 to 9.&nbsp; This
message will be issued if all of those files already exist.
<H2 ID="104_write_error_on_work_file__error_code_E__d"> 104 write error on work file:&nbsp; error code = %d </H2>
<BR>An error was encountered trying to write information to the work file.&nbsp; The disk could be full.
<H2 ID="105_read_error_on_work_file__error_code_E__d"> 105 read error on work file:&nbsp; error code = %d </H2>
<BR>An error was encountered trying to read information from the work file.
<H2 ID="106_token_too_longS_truncated"> 106 token too long; truncated </H2>
<BR>The token must be less than 510 bytes in length.
<H2 ID="107_filename_required_on_command_line"> 107 filename required on command line </H2>
<BR>The name of a file to be compiled must be specified on the command line.
<H2 ID="108_command_line_contains_more_than_one_file_to_compile"> 108 command line contains more than one file to compile </H2>
<BR>You have more than one file name specified on the command line to be compiled.&nbsp; The compiler can only compile one
file at a time.&nbsp; You can use the Open Watcom Compile and Link utility to compile multiple files with a single command.
<H2 ID="109_virtual_member_functions_are_not_allowed_in_a_union"> 109 virtual member functions are not allowed in a union </H2>
<BR>A union can only be used to overlay the storage of data.&nbsp; The storage of virtual function information (in a safe
manner) cannot be done if storage is overlaid.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S1{ int f( int ); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S2{ int f( int ); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union un { S1 s1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S2 s2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int vf( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="110_union_cannot_be_used_as_a_base_class"> 110 union cannot be used as a base class </H2>
<BR>This restriction prevents C++ programmers from viewing a<B><I> union</I></B> as an encapsulation unit.&nbsp; If it is
necessary, one can encapsulate the union into a<B><I> class</I></B> and achieve the same effect.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union U { int a; int b; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S : public U { int s; };</TT>
<H2 ID="111_union_cannot_have_a_base_class"> 111 union cannot have a base class </H2>
<BR>This restriction prevents C++ programmers from viewing a<B><I> union</I></B> as an encapsulation unit.&nbsp; If it is
necessary, one can encapsulate the union into a<B><I> class</I></B> and inherit the base classes normally.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S { public: int s; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union U : public S { int a; int b; };</TT>
<H2 ID="112_cannot_inherit_an_undefined_base_class___T_"> 112 cannot inherit an undefined base class '%T' </H2>
<BR>The storage requirements for a<B><I> class</I></B> type must be known when inheritance is involved because the layout
of the final class depends on knowing the complete contents of all base classes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Undefined;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C : public Undefined {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="113_repeated_direct_base_class_will_cause_ambiguities"> 113 repeated direct base class will cause ambiguities </H2>
<BR>Almost all accesses will be ambiguous.&nbsp; This restriction is useful in catching programming errors.&nbsp; The repeated
base class can be encapsulated in another class if the repetition is required.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Dup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C : public Dup, public Dup</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="114_templates_may_only_be_declared_in_namespace_scope"> 114 templates may only be declared in namespace scope </H2>
<BR>Currently, templates can only be declared in namespace scope.&nbsp; This simple restriction was chosen in favour of more
freedom with possibly subtle restrictions.
<H2 ID="115_linkages_may_only_be_declared_in_file_scope"> 115 linkages may only be declared in file scope </H2>
<BR>A common source of errors for C and C++ result from the use of prototypes inside of functions.&nbsp; This restriction
attempts to prevent such errors.
<H2 ID="116_unknown_linkage___s_"> 116 unknown linkage '%s' </H2>
<BR>Only the linkages &quot;C&quot; and &quot;C++&quot; are supported by Open Watcom C++.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern &quot;APL&quot; void AplFunc( int* );</TT>
<H2 ID="117_too_many_storage_class_specifiers"> 117 too many storage class specifiers </H2>
<BR>This message is a result of duplicating a previous storage class or having a different storage class.&nbsp; You can only
have one of the following storage classes,<B><I> extern,</I></B> <B><I> static,</I></B> <B><I> auto,</I></B> <B><I> register,</I></B>
or<B><I> typedef.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern typedef int (*fn)( void );</TT>
<H2 ID="118_nameless_declaration_is_not_allowed"> 118 nameless declaration is not allowed </H2>
<BR>A type was used in a declaration but no name was given.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int;</TT>
<H2 ID="119_illegal_combination_of_type_specifiers"> 119 illegal combination of type specifiers </H2>
<BR>An incorrect scalar type was found.&nbsp; Either a scalar keyword was repeated or the combination is illegal.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short short x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short long y;</TT>
<H2 ID="120_illegal_combination_of_type_qualifiers"> 120 illegal combination of type qualifiers </H2>
<BR>A repetition of a type qualifier has been detected.&nbsp; Some compilers may ignore repetitions but strictly speaking
it is incorrect code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const const x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int virtual virtual fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="121_syntax_error"> 121 syntax error </H2>
<BR>The C++ compiler was unable to interpret the text starting at the location of the message.&nbsp; The C++ language is sufficiently
complicated that it is difficult for a compiler to correct the error itself.
<H2 ID="122_parser_stack_corrupted"> 122 parser stack corrupted </H2>
<BR>The C++ parser has detected an internal problem that usually indicates a compiler problem.&nbsp; Please report this directly
to the Open Watcom development team.&nbsp; See http://www.openwatcom.org/.
<H2 ID="123_template_declarations_cannot_be_nested_within_each_other"> 123 template declarations cannot be nested within each other </H2>
<BR>Currently, templates can only be declared in namespace scope.&nbsp; Furthermore, a template declaration must be finished
before another template can be declared.
<H2 ID="124_expression_is_too_complicated"> 124 expression is too complicated </H2>
<BR>The expression contains too many levels of nested parentheses.&nbsp; Divide the expression up into two or more sub-expressions.
<H2 ID="125_invalid_redefinition_of_the_typedef_name___S_"> 125 invalid redefinition of the typedef name '%S' </H2>
<BR>Redefinition of typedef names is only allowed if you are redefining a typedef name to itself.&nbsp; Any other redefinition
is illegal.&nbsp; You should delete the duplicate<B><I> typedef</I></B> definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int TD;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef float TD;&nbsp;&nbsp; // illegal</TT>
<H2 ID="126_class___T__has_already_been_defined"> 126 class '%T' has already been defined </H2>
<BR>This message usually results from the definition of two classes in the same scope.&nbsp; This is illegal regardless of
whether the class definitions are identical.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="127__sizeof__is_not_allowed_for_an_undefined_type"> 127 'sizeof' is not allowed for an undefined type </H2>
<BR>If a type has not been defined, the compiler cannot know how large it is.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x = sizeof( C );</TT>
<H2 ID="128_initializer_for_variable___S__cannot_be_bypassed"> 128 initializer for variable '%S' cannot be bypassed </H2>
<BR>The variable may not be initialized when code is executing at the position indicated in the message.&nbsp; The C++ language
places these restrictions to prevent the use of uninitialized variables.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: // b bypassed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b + 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="129_division_by_zero_in_a_constant_expression"> 129 division by zero in a constant expression </H2>
<BR>Division by zero is not allowed in a constant expression.&nbsp; The value of the expression cannot be used with this error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4 / 0:&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="130_arithmetic_overflow_in_a_constant_expression"> 130 arithmetic overflow in a constant expression </H2>
<BR>The multiplication of two integral values cannot be represented.&nbsp; The value of the expression cannot be used with
this error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x7FFF * 0x7FFF * 0x7FFF:&nbsp; // overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="131_not_enough_memory_to_fully_optimize_procedure___s_"> 131 not enough memory to fully optimize procedure '%s' </H2>
<BR>The indicated procedure cannot be fully optimized with the amount of memory available.&nbsp; The code generated will still
be correct and execute properly.&nbsp; This message is purely informational (i.e., buy more memory).
<H2 ID="132_not_enough_memory_to_maintain_full_peephole"> 132 not enough memory to maintain full peephole </H2>
<BR>Certain optimizations benefit from being able to store the entire module in memory during optimization.&nbsp; All functions
will be individually optimized but the optimizer will not be able to share code between functions if this message appears.
&nbsp;The code generated will still be correct and execute properly.&nbsp; This message is purely informational (i.e., buy
more memory).
<H2 ID="133_too_many_errors__compilation_aborted"> 133 too many errors:&nbsp; compilation aborted </H2>
<BR>The Open Watcom C++ compiler sets a limit to the number of error messages it will issue.&nbsp; Once the number of messages
reaches the limit the above message is issued.&nbsp; This limit can be changed via the &quot;/e&quot; command line option.
<H2 ID="134_too_many_parm_sets"> 134 too many parm sets </H2>
<BR>An extra parameter passing description has been found in the aux pragma text.&nbsp; Only one parameter passing description
is allowed.
<H2 ID="135__friend____virtual__or__inline__modifiers_may_only_be_used_on_functions"> 135 'friend', 'virtual' or 'inline' modifiers may only be used on functions </H2>
<BR>This message indicates that you are trying to declare a strange entity like an<B><I> inline</I></B> variable.&nbsp; These
qualifiers can only be used on function declarations and definitions.
<H2 ID="136_more_than_one_calling_convention_has_been_specified"> 136 more than one calling convention has been specified </H2>
<BR>A function cannot have more than one #pragma modifier applied to it.&nbsp; Combine the pragmas into one pragma and apply
it once.
<H2 ID="137_pure_member_function_constant_must_be__0_"> 137 pure member function constant must be '0' </H2>
<BR>The constant must be changed to '0' in order for the Open Watcom C++ compiler to accept the pure virtual member function
declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int wrong( void ) = 91;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="138_based_modifier_has_been_repeated"> 138 based modifier has been repeated </H2>
<BR>A repeated based modifier has been detected.&nbsp; There are no semantics for combining base modifiers so this is not
allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( void ) __based( ptr ) *a;</TT>
<H2 ID="139_enumeration_variable_is_not_assigned_a_constant_from_its_enumeration"> 139 enumeration variable is not assigned a constant from its enumeration </H2>
<BR>In C++ (as opposed to C), enums represent values of distinct types.&nbsp; Thus, the compiler will not automatically convert
an integer value to an enum type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum Days { sun, mod, tues, wed, thur, fri, sat };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum Days day = 2;</TT>
<H2 ID="140_bitMfield_declaration_cannot_have_a_storage_class_specifier"> 140 bit-field declaration cannot have a storage class specifier </H2>
<BR>Bit-fields (along with most members) cannot have storage class specifiers in their declaration.&nbsp; Remove the storage
class specifier to correct the code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned bitf :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="141_bitMfield_declaration_must_have_a_base_type_specified"> 141 bit-field declaration must have a base type specified </H2>
<BR>A bit-field cannot make use of a default integer type.&nbsp; Specify the type<B><I> int</I></B> to correct the code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitf :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="142_illegal_qualification_of_a_bitMfield_declaration"> 142 illegal qualification of a bit-field declaration </H2>
<BR>A bit-field can only be declared<B><I> const</I></B> or<B><I> volatile.</I></B>&nbsp; Qualifications like<B><I> friend</I></B>
are not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend int bit1 :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline int bit2 :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int bit3 :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>All three declarations of bit-fields are illegal.
<H2 ID="143_duplicate_base_qualifier"> 143 duplicate base qualifier </H2>
<BR>The compiler has found a repetition of base qualifiers like<B><I> protected</I></B> or<B><I> virtual.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base { int b; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : public public Base { int d; };</TT>
<H2 ID="144_only_one_access_specifier_is_allowed"> 144 only one access specifier is allowed </H2>
<BR>The compiler has found more than one access specifier for a base class.&nbsp; Since the compiler cannot choose one over
the other, remove the unwanted access specifier to correct the code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base { int b; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : public protected Base { int d; };</TT>
<H2 ID="145_unexpected_type_qualifier_found"> 145 unexpected type qualifier found </H2>
<BR>Type specifiers cannot have<B><I> const</I></B> or<B><I> volatile</I></B> qualifiers.&nbsp; This shows up in<B><I> new</I></B>
expressions because one cannot allocate a<B><I> const</I></B> object.
<H2 ID="146_unexpected_storage_class_specifier_found"> 146 unexpected storage class specifier found </H2>
<BR>Type specifiers cannot have<B><I> auto</I></B> or<B><I> static</I></B> storage class specifiers.&nbsp; This shows up in<B><I>
new</I></B> expressions because one cannot allocate a<B><I> static</I></B> object.
<H2 ID="147_access_to___S__is_not_allowed_because_it_is_ambiguous"> 147 access to '%S' is not allowed because it is ambiguous </H2>
<BR>There are two ways that this error can show up in C++ code.&nbsp; The first way a member can be ambiguous is that the
same name can be used in two different classes.&nbsp; If these classes are combined with multiple inheritance, accesses of
the name will be ambiguous.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S1 { int s; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S2 { int s; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : public S1, public S2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo() { s = 2; };&nbsp; // s is ambiguous</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The second way a member can be ambiguous involves multiple inheritance.&nbsp; If a class is inherited non-virtually
by two different classes which then get combined with multiple inheritance, an access of the member is faced with deciding
which copy of the member is intended.&nbsp; Use the '::' operator to clarify what member is being accessed or access the member
with a different class pointer or reference.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Top { int t; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Mid : public Top { int m; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Bot : public Top, public Mid</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo() { t = 2; };&nbsp; // t is ambiguous</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="148_access_to_private_member___S__is_not_allowed"> 148 access to private member '%S' is not allowed </H2>
<BR>The indicated member is being accessed by an expression that does not have permission to access private members of the
class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Top { int t; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Bot : private Top</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo() { return t; };&nbsp; // t is private</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bot b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = b.foo();&nbsp;&nbsp;&nbsp; // foo is private</TT>
<H2 ID="149_access_to_protected_member___S__is_not_allowed"> 149 access to protected member '%S' is not allowed </H2>
<BR>The indicated member is being accessed by an expression that does not have permission to access protected members of the
class.&nbsp; The compiler also requires that<B><I> protected</I></B> members be accessed through a derived class to ensure
that an unrelated base class cannot be quietly modified.&nbsp; This is a fairly recent change to the C++ language that may
cause Open Watcom C++ to not accept older C++ code.&nbsp; See Section 11.5 in the ARM for a discussion of protected access.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Top { int t; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Mid : public Top { int m; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Bot : protected Mid</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // t cannot be accessed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo() { return t; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bot b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = b.foo(); // foo is protected</TT>
<H2 ID="150_operation_does_not_allow_both_operands_to_be_pointers"> 150 operation does not allow both operands to be pointers </H2>
<BR>There may be a missing indirection in the code exhibiting this error.&nbsp; An example of this error is adding two pointers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *p, *q;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p += q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="151_operand_is_neither_a_pointer_nor_an_arithmetic_type"> 151 operand is neither a pointer nor an arithmetic type </H2>
<BR>An example of this error is incrementing a class that does not have any overloaded operators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="152_left_operand_is_neither_a_pointer_nor_an_arithmetic_type"> 152 left operand is neither a pointer nor an arithmetic type </H2>
<BR>An example of this error is trying to add 1 to a class that does not have any overloaded operators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="153_right_operand_is_neither_a_pointer_nor_an_arithmetic_type"> 153 right operand is neither a pointer nor an arithmetic type </H2>
<BR>An example of this error is trying to add 1 to a class that does not have any overloaded operators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1 + x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="154_cannot_subtract_a_pointer_from_an_arithmetic_operand"> 154 cannot subtract a pointer from an arithmetic operand </H2>
<BR>The subtract operands are probably in the wrong order.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn( char *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 10 - p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="155_left_expression_must_be_arithmetic"> 155 left expression must be arithmetic </H2>
<BR>Certain operations like multiplication require both operands to be of arithmetic types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x * 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="156_right_expression_must_be_arithmetic"> 156 right expression must be arithmetic </H2>
<BR>Certain operations like multiplication require both operands to be of arithmetic types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1 * x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="157_left_expression_must_be_integral"> 157 left expression must be integral </H2>
<BR>Certain operators like the bit manipulation operators require both operands to be of integral types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x ^ 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="158_right_expression_must_be_integral"> 158 right expression must be integral </H2>
<BR>Certain operators like the bit manipulation operators require both operands to be of integral types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { } x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 1 ^ x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="159_cannot_assign_a_pointer_value_to_an_arithmetic_item"> 159 cannot assign a pointer value to an arithmetic item </H2>
<BR>The pointer value must be cast to the desired type before the assignment takes place.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( char *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="160_attempt_to_destroy_a_far_object_when_the_data_model_is_near"> 160 attempt to destroy a far object when the data model is near </H2>
<BR>Destructors cannot be applied to objects which are stored in far memory when the default memory model for data is near.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Obj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~Obj();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Obj far obj;</TT>
<BR><BR>The last line causes this error to be displayed when the memory model is small (switch -ms), since the memory model
for data is near.
<H2 ID="161_attempt_to_call_member_function_for_far_object_when_the_data_model_is_near"> 161 attempt to call member function for far object when the data model is near </H2>
<BR>Member functions cannot be called for objects which are stored in far memory when the default memory model for data is
near.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Obj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Obj far obj;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int integer = obj.foo();</TT>
<BR><BR>The last line causes this error to be displayed when the memory model is small (switch -ms), since the memory model
for data is near.
<H2 ID="162_template_type_argument_cannot_have_a_default_argument"> 162 template type argument cannot have a default argument </H2>
<BR>This message was produced by earlier versions of the Open Watcom C++ compiler.&nbsp; Support for default template arguments
was added in version 1.3 and this message was removed at that time.
<H2 ID="163_attempt_to_delete_a_far_object_when_the_data_model_is_near"> 163 attempt to delete a far object when the data model is near </H2>
<BR><B><I>delete</I></B> cannot be used to deallocate objects which are stored in far memory when the default memory model
for data is near.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Obj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( Obj far *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The second last line causes this error to be displayed when the memory model is small (switch -ms), since the memory
model for data is near.
<H2 ID="164_first_operand_is_not_a_class__struct_or_union"> 164 first operand is not a class, struct or union </H2>
<BR>The<B><I> offsetof</I></B> operation can only be performed on a type that can have members.&nbsp; It is meaningless for
any other type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return offsetof( double, sign );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="165_syntax_error__class_template_cannot_be_processed"> 165 syntax error:&nbsp; class template cannot be processed </H2>
<BR>The class template contains unbalanced braces.&nbsp; The class definition cannot be processed in this form.
<H2 ID="166_cannot_convert_right_pointer_to_type_of_left_operand"> 166 cannot convert right pointer to type of left operand </H2>
<BR>The C++ language will not allow the implicit conversion of unrelated class pointers.&nbsp; An explicit cast is required.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fun( C1* pc1, C2* pc2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pc2 = pc1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="167_left_operand_must_be_an_lvalue"> 167 left operand must be an lvalue </H2>
<BR>The left operand must be an expression that is valid on the left side of an assignment.&nbsp; Examples of incorrect lvalues
include constants and the results of most operators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i, j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( i - 1 ) = j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="168_static_data_members_are_not_allowed_in_an_union"> 168 static data members are not allowed in an union </H2>
<BR>A union should only be used to organize memory in C++.&nbsp; Enclose the union in a class if you need a static data member
associated with the union.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union U</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="169_invalid_storage_class_for_a_member"> 169 invalid storage class for a member </H2>
<BR>A class member cannot be declared with<B><I> auto,</I></B> <B><I> register,</I></B> or<B><I> extern</I></B> storage class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto int a;&nbsp;&nbsp;&nbsp;&nbsp; // cannot specify auto</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="170_declaration_is_too_complicated"> 170 declaration is too complicated </H2>
<BR>The declaration contains too many declarators (i.e., pointer, array, and function types).&nbsp; Break up the declaration
into a series of typedefs ending in a final declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ************p;</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // transform this to ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int ****PD1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef PD1 ****PD2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PD2 ****p;</TT>
<H2 ID="171_exception_declaration_is_too_complicated"> 171 exception declaration is too complicated </H2>
<BR>The exception declaration contains too many declarators (i.e., pointer, array, and function types).&nbsp; Break up the
declaration into a series of typedefs ending in a final declaration.
<H2 ID="172_floatingMpoint_constant_too_large_to_represent"> 172 floating-point constant too large to represent </H2>
<BR>The Open Watcom C++ compiler cannot represent the floating-point constant because the magnitude of the positive exponent
is too large.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = 1.2e78965;</TT>
<H2 ID="173_floatingMpoint_constant_too_small_to_represent"> 173 floating-point constant too small to represent </H2>
<BR>The Open Watcom C++ compiler cannot represent the floating-point constant because the magnitude of the negative exponent
is too large.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = 1.2e-78965;</TT>
<H2 ID="174_class_template___M__cannot_be_overloaded"> 174 class template '%M' cannot be overloaded </H2>
<BR>A class template name must be unique across the entire C++ program.&nbsp; Furthermore, a class template cannot coexist
with another class template of the same name.
<H2 ID="175_range_of_enum_constants_cannot_be_represented"> 175 range of enum constants cannot be represented </H2>
<BR>If one integral type cannot be chosen to represent all values of an enumeration, the values cannot be used reliably in
the generated code.&nbsp; Shrink the range of enumerator values used in the<B><I> enum</I></B> declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; e1 = 0xFFFFFFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ,&nbsp;&nbsp; e2 = -1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="176___S__cannot_be_in_the_same_scope_as_a_class_template"> 176 '%S' cannot be in the same scope as a class template </H2>
<BR>A class template name must be unique across the entire C++ program.&nbsp; Any other use of a name cannot be in the same
scope as the class template.
<H2 ID="177_invalid_storage_class_in_file_scope"> 177 invalid storage class in file scope </H2>
<BR>A declaration in file scope cannot have a storage class of<B><I> auto</I></B> or<B><I> register.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; auto int a;</TT>
<H2 ID="178_const_object_must_be_initialized"> 178 const object must be initialized </H2>
<BR>Constant objects cannot be modified so they must be initialized before use.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int a;</TT>
<H2 ID="179_declaration_cannot_be_in_the_same_scope_as_class_template___S_"> 179 declaration cannot be in the same scope as class template '%S' </H2>
<BR>A class template name must be unique across the entire C++ program.&nbsp; Any other use of a name cannot be in the same
scope as the class template.
<H2 ID="180_template_arguments_must_be_named"> 180 template arguments must be named </H2>
<BR>A member function of a template class cannot be defined outside the class declaration unless all template arguments have
been named.
<H2 ID="181_class_template___M__is_already_defined"> 181 class template '%M' is already defined </H2>
<BR>A class template cannot have its definition repeated regardless of whether it is identical to the previous definition.
<H2 ID="182_invalid_storage_class_for_an_argument"> 182 invalid storage class for an argument </H2>
<BR>An argument declaration cannot have a storage class of<B><I> extern,</I></B> <B><I> static,</I></B> or<B><I> typedef.</I></B>
&nbsp;
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( extern int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="183_unions_cannot_have_members_with_constructors"> 183 unions cannot have members with constructors </H2>
<BR>A union should only be used to organize memory in C++.&nbsp; Allowing union members to have constructors would mean that
the same piece of memory could be constructed twice.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union U</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C c;&nbsp;&nbsp;&nbsp; // has constructor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="184_statement_is_too_complicated"> 184 statement is too complicated </H2>
<BR>The statement contains too many nested constructs.&nbsp; Break up the statement into multiple statements.
<H2 ID="185___s__is_not_the_name_of_a_class_or_namespace"> 185 '%s' is not the name of a class or namespace </H2>
<BR>The right hand operand of a '::' operator turned out not to reference a class type or namespace.&nbsp; Because the name
is followed by another '::', it must name a class or namespace.
<H2 ID="186_attempt_to_modify_a_constant_value"> 186 attempt to modify a constant value </H2>
<BR>Modification of a constant value is not allowed.&nbsp; If you must force this to work, take the address and cast away
the constant nature of the type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int const con = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con = 13;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(int*)&amp;con = 13;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="187__offsetof__is_not_allowed_for_a_bitMfield"> 187 'offsetof' is not allowed for a bit-field </H2>
<BR>A bit-field cannot have a simple offset so it cannot be referenced in an<B><I> offsetof</I></B> expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned b1 :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned b2 :15;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned b3 :11;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = offsetof( S, b2 );</TT>
<H2 ID="188_base_class_is_inherited_with_private_access"> 188 base class is inherited with private access </H2>
<BR>This warning indicates that the base class was originally declared as a<B><I> class</I></B> as opposed to a<B><I> struct.</I></B>
&nbsp;Furthermore, no access was specified so the base class defaults to<B><I> private</I></B> inheritance.&nbsp; Add the<B><I>
private</I></B> or<B><I> public</I></B> access specifier to prevent this message depending on the intended access.
<H2 ID="189_overloaded_function_cannot_be_selected_for_arguments_used_in_call"> 189 overloaded function cannot be selected for arguments used in call </H2>
<BR>Either conversions were not possible for an argument to the function or a function with the right number of arguments
was not available.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( C1* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( C2* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( 5 );</TT>
<H2 ID="190_base_operator_operands_must_be_____segment__Y_pointer__"> 190 base operator operands must be &quot; __segment :&gt; pointer &quot; </H2>
<BR>The base operator (:&gt;) requires the left operand to be of type __segment and the right operand to be a pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char _based( void ) *pcb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __far *pcf = pcb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs :&gt; operator</TT>
<BR><BR>Examples of typical uses are as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const __segment mySegAbs = 0x4000;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( void ) *c_bv = 24;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __far *c_fp_1 = mySegAbs :&gt; c_bv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __far *c_fp_2 = __segname( &quot;_DATA&quot; ) :&gt; c_bv;</TT>
<H2 ID="191_expression_must_be_a_pointer_or_a_zero_constant"> 191 expression must be a pointer or a zero constant </H2>
<BR>In a conditional expression, if one side of the ':' is a pointer then the other side must also be a pointer or a zero
constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *p = ( a &gt; 7 ) ? &amp;a : 12;</TT>
<H2 ID="192_left_expression_pointer_type_cannot_be_incremented_or_decremented"> 192 left expression pointer type cannot be incremented or decremented </H2>
<BR>The expression requires that the scaling size of the pointer be known.&nbsp; Pointers to functions, arrays of unknown
size, or<B><I> void</I></B> cannot be incremented because there is no size defined for functions, arrays of unknown size,
or<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *q = p + 2;</TT>
<H2 ID="193_right_expression_pointer_type_cannot_be_incremented_or_decremented"> 193 right expression pointer type cannot be incremented or decremented </H2>
<BR>The expression requires that the scaling size of the pointer be known.&nbsp; Pointers to functions, arrays of unknown
size, or<B><I> void</I></B> cannot be incremented because there is no size defined for functions, arrays of unknown size,
or<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *q = 2 + p;</TT>
<H2 ID="194_expression_pointer_type_cannot_be_incremented_or_decremented"> 194 expression pointer type cannot be incremented or decremented </H2>
<BR>The expression requires that the scaling size of the pointer be known.&nbsp; Pointers to functions, arrays of unknown
size, or<B><I> void</I></B> cannot be incremented because there is no size defined for functions, arrays of unknown size,
or<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *q = ++p;</TT>
<H2 ID="195__sizeof__is_not_allowed_for_a_function"> 195 'sizeof' is not allowed for a function </H2>
<BR>A function has no size defined for it by the C++ language specification.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int FT( int );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned y = sizeof( FT );</TT>
<H2 ID="196__sizeof__is_not_allowed_for_type_void"> 196 'sizeof' is not allowed for type void </H2>
<BR>The type<B><I> void</I></B> has no size defined for it by the C++ language specification.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned size = sizeof( *p );</TT>
<H2 ID="197_type_cannot_be_defined_in_this_context"> 197 type cannot be defined in this context </H2>
<BR>A type cannot be defined in certain contexts.&nbsp; For example, a new type cannot be defined in an argument list, a<B><I>
new</I></B> expression, a conversion function identifier, or a catch handler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( struct S { int s; } ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="198_expression_cannot_be_used_as_a_class_template_parameter"> 198 expression cannot be used as a class template parameter </H2>
<BR>The compiler has to be able to compare expressions during compilation so this limits the complexity of expressions that
can be used for template parameters.&nbsp; The only types of expressions that can be used for template parameters are constant
integral expressions and addresses.&nbsp; Any symbols must have external linkage or must be static class members.
<H2 ID="199_premature_endMofMfile_encountered_during_compilation"> 199 premature end-of-file encountered during compilation </H2>
<BR>The compiler expects more source code at this point.&nbsp; This can be due to missing parentheses (')') or missing closing
braces ('}').
<H2 ID="200_duplicate_case_value___s__after_conversion_to_type_of_switch_expression"> 200 duplicate case value '%s' after conversion to type of switch expression </H2>
<BR>A duplicate<B><I> case</I></B> value has been found.&nbsp; Keep in mind that all case values must be converted to the
type of the switch expression.&nbsp; Constants that may be different initially may convert to the same value.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E { e1, e2 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( short a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x10001:&nbsp;&nbsp;&nbsp; // converts to 1 as short</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="201_declaration_statement_follows_an_if_statement"> 201 declaration statement follows an if statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="202_declaration_statement_follows_an_else_statement"> 202 declaration statement follows an else statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c = 15;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="203_declaration_statement_follows_a_switch_statement"> 203 declaration statement follows a switch statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="204__this__pointer_is_not_defined"> 204 'this' pointer is not defined </H2>
<BR>The<B><I> this</I></B> value can only be used from within non-static member functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="205_declaration_statement_cannot_follow_a_while_statement"> 205 declaration statement cannot follow a while statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="206_declaration_statement_cannot_follow_a_do_statement"> 206 declaration statement cannot follow a do statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( a );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="207_declaration_statement_cannot_follow_a_for_statement"> 207 declaration statement cannot follow a for statement </H2>
<BR>There are implicit scopes created for most control structures.&nbsp; Because of this, no code can access any of the names
declared in the declaration.&nbsp; Although the code is legal it may not be what the programmer intended.&nbsp; A<B><I> for</I></B>
loop with an initial declaration is allowed to be used within another<B><I> for</I></B> loop, so this code is legal C++:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int **a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; 10; ++i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int j = 0; j &lt; 10; ++j )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[i][j] = i + j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The following example, however, illustrates a potentially erroneous situation.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ; a&lt;10; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="208_pointer_to_virtual_base_class_converted_to_pointer_to_derived_class"> 208 pointer to virtual base class converted to pointer to derived class </H2>
<BR>Since the relative position of a virtual base can change through repeated derivations, this conversion is very dangerous.
&nbsp;All C++ translators must report an error for this type of conversion.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct VBase { int v; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : virtual public VBase { int&nbsp;&nbsp; d; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern VBase *pv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Der *pd = (Der *)pv;</TT>
<H2 ID="209_cannot_use_far_pointer_in_this_context"> 209 cannot use far pointer in this context </H2>
<BR>Only near pointers can be thrown when the data memory model is near.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __far *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>When the small memory model (-ms switch) is selected, the<B><I> throw</I></B> expression is diagnosed as erroneous.
&nbsp;Similarly, only near pointers can be specified in<B><I> catch</I></B> statements when the data memory model is near.
<H2 ID="210_returning_reference_to_function_argument_or_to_auto_or_register_variable"> 210 returning reference to function argument or to auto or register variable </H2>
<BR>The storage for the automatic variable will be destroyed immediately upon function return.&nbsp; Returning a reference
effectively allows the caller to modify storage which does not exist.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C auto_var;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return auto_var;&nbsp;&nbsp;&nbsp; // not allowed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="211__pragma_attributes_for___S__may_be_inconsistent"> 211 #pragma attributes for '%S' may be inconsistent </H2>
<BR>A pragma attribute was changed to a value which matches neither the current default not the previous value for that attribute.
&nbsp;A warning is issued since this usually indicates an attribute is being set twice (or more) in an inconsistent way.&nbsp;
The warning can also occur when the default attribute is changed between two pragmas for the same object.
<H2 ID="212_function_arguments_cannot_be_of_type_void"> 212 function arguments cannot be of type void </H2>
<BR>Having more than one<B><I> void</I></B> argument is not allowed.&nbsp; The special case of one<B><I> void</I></B> argument
indicates that the function accepts no parameters.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn1( void )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn2( void, void, void )&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="213_class_template___M__requires_more_parameters_for_instantiation"> 213 class template '%M' requires more parameters for instantiation </H2>
<BR>The class template instantiation has too few parameters supplied so the class cannot be instantiated properly.
<H2 ID="214_class_template___M__requires_fewer_parameters_for_instantiation"> 214 class template '%M' requires fewer parameters for instantiation </H2>
<BR>The class template instantiation has too many parameters supplied so the class cannot be instantiated properly.
<H2 ID="215_no_declared__operator_new__has_arguments_that_match"> 215 no declared 'operator new' has arguments that match </H2>
<BR>An<B><I> operator new</I></B> could not be found to match the<B><I> new</I></B> expression.&nbsp; Supply the correct arguments
for special<B><I> operator new</I></B> functions that are defined with the placement syntax.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *operator new( size_t, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S *p = new ('a') S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="216_wide_character_string_concatenated_with_a_simple_character_string"> 216 wide character string concatenated with a simple character string </H2>
<BR>There are no semantics defined for combining a wide character string with a simple character string.&nbsp; To correct
the problem, make the simple character string a wide character string by prefixing it with a<B><I> L.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *p = &quot;1234&quot; L&quot;5678&quot;;</TT>
<H2 ID="217__offsetof__is_not_allowed_for_a_static_member"> 217 'offsetof' is not allowed for a static member </H2>
<BR>A<B><I> static</I></B> member does not have an offset like simple data members.&nbsp; If this is required, use the address
of the<B><I> static</I></B> member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int stat;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int memb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int size_1 = offsetof( C, stat );&nbsp;&nbsp; // not allowed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int size_2 = offsetof( C, memb );&nbsp;&nbsp; // ok</TT>
<H2 ID="218_cannot_define_an_array_of_void"> 218 cannot define an array of void </H2>
<BR>Since the<B><I> void</I></B> type has no size and there are no values of<B><I> void</I></B> type, one cannot declare an
array of<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void array[24];</TT>
<H2 ID="219_cannot_define_an_array_of_references"> 219 cannot define an array of references </H2>
<BR>References are not objects, they are simply a way of creating an efficient alias to another name.&nbsp; Creating an array
of references is currently not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&amp; array[24];</TT>
<H2 ID="220_cannot_define_a_reference_to_void"> 220 cannot define a reference to void </H2>
<BR>One cannot create a reference to a<B><I> void</I></B> because there can be no<B><I> void</I></B> variables to supply for
initializing the reference.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void&amp; ref;</TT>
<H2 ID="221_cannot_define_a_reference_to_another_reference"> 221 cannot define a reference to another reference </H2>
<BR>References are not objects, they are simply a way of creating an efficient alias to another name.&nbsp; Creating a reference
to another reference is currently not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp; &amp; ref;</TT>
<H2 ID="222_cannot_define_a_pointer_to_a_reference"> 222 cannot define a pointer to a reference </H2>
<BR>References are not objects, they are simply a way of creating an efficient alias to another name.&nbsp; Creating a pointer
to a reference is currently not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&amp; *ptr;</TT>
<H2 ID="223_cannot_initialize_array_with__operator_new_"> 223 cannot initialize array with 'operator new' </H2>
<BR>The initialization of arrays created with<B><I> operator new</I></B> can only be done with default constructors.&nbsp;
The capability of using another constructor with arguments is currently not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S *p = new S[10] ( 12 );</TT>
<H2 ID="224___N__is_a_variable_of_type_void"> 224 '%N' is a variable of type void </H2>
<BR>A variable cannot be of type<B><I> void.</I></B>&nbsp; The<B><I> void</I></B> type can only be used in restricted circumstances
because it has no size.&nbsp; For instance, a function returning<B><I> void</I></B> means that it does not return any value.
&nbsp;A pointer to<B><I> void</I></B> is used as a generic pointer but it cannot be dereferenced.
<H2 ID="225_cannot_define_a_member_pointer_to_a_reference"> 225 cannot define a member pointer to a reference </H2>
<BR>References are not objects, they are simply a way of creating an efficient alias to another name.&nbsp; Creating a member
pointer to a reference is currently not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int &amp;ref;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&amp; S::* p;</TT>
<H2 ID="226_function___S__is_not_distinct"> 226 function '%S' is not distinct </H2>
<BR>The function being declared is not distinct enough from the other functions of the same name.&nbsp; This means that all
function overloads involving the function's argument types will be ambiguous.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( S* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( S* const ); // not distinct enough</TT>
<H2 ID="227_overloaded_function_is_ambiguous_for_arguments_used_in_call"> 227 overloaded function is ambiguous for arguments used in call </H2>
<BR>The compiler could not find an unambiguous choice for the function being called.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( short );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( 4 );</TT>
<H2 ID="228_declared__operator_new__is_ambiguous_for_arguments_used"> 228 declared 'operator new' is ambiguous for arguments used </H2>
<BR>The compiler could not find an unambiguous choice for<B><I> operator new.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s[2];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void* operator new( size_t, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void* operator new( size_t, short );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Der *p = new(10) Der;</TT>
<H2 ID="229_function___S__has_already_been_defined"> 229 function '%S' has already been defined </H2>
<BR>The function being defined has already been defined elsewhere.&nbsp; Even if the two function bodies are identical, there
must be only one definition for a particular function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int s ) { return s; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int s ) { return s; }&nbsp; // illegal</TT>
<H2 ID="230_expression_on_left_is_an_array"> 230 expression on left is an array </H2>
<BR>The array expression is being used in a context where only pointers are allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="231_userMdefined_conversion_has_a_return_type"> 231 user-defined conversion has a return type </H2>
<BR>A user-defined conversion cannot be declared with a return type.&nbsp; The &quot;return type&quot; of the user-defined
conversion is implicit in the name of the user-defined conversion.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator int(); // cannot have return type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="232_userMdefined_conversion_must_be_a_function"> 232 user-defined conversion must be a function </H2>
<BR>The operator name describing a user-defined conversion can only be used to designate functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // operator char can only be a function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int operator char = 9;</TT>
<H2 ID="233_userMdefined_conversion_has_an_argument_list"> 233 user-defined conversion has an argument list </H2>
<BR>A user-defined conversion cannot have an argument list.&nbsp; Since user-defined conversions can only be non-static member
functions, they have an implicit<B><I> this</I></B> argument.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator int( S&amp; ); // cannot have arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="234_destructor_cannot_have_a_return_type"> 234 destructor cannot have a return type </H2>
<BR>A destructor cannot have a return type (even<B><I> void</I></B> ).&nbsp; The destructor is a special member function that
is not required to be identical in form to all other member functions.&nbsp; This allows different implementations to have
different uses for any return values.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void* ~S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="235_destructor_must_be_a_function"> 235 destructor must be a function </H2>
<BR>The tilde ('~') style of name is reserved for declaring destructor functions.&nbsp; Variable names cannot make use of
the destructor style of names.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ~S; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="236_destructor_has_an_argument_list"> 236 destructor has an argument list </H2>
<BR>A destructor cannot have an argument list.&nbsp; Since destructors can only be non-static member functions, they have
an implicit<B><I> this</I></B> argument.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~S( S&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="237___N__must_be_a_function"> 237 '%N' must be a function </H2>
<BR>The<B><I> operator</I></B> style of name is reserved for declaring operator functions.&nbsp; Variable names cannot make
use of the<B><I> operator</I></B> style of names.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator+;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="238___N__is_not_a_function"> 238 '%N' is not a function </H2>
<BR>The compiler has detected what looks like a function body.&nbsp; The message is a result of not finding a function being
declared.&nbsp; This can happen in many ways, such as dropping the ':' before defining base classes, or dropping the '=' before
initializing a structure via a braced initializer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D B { int i; };</TT>
<H2 ID="239_nested_type_class___s__has_not_been_declared"> 239 nested type class '%s' has not been declared </H2>
<BR>A nested class has not been found but is required by the use of repeated '::' operators.&nbsp; The construct &quot;A::B::C&quot;
requires that 'A' be a class type, and 'B' be a nested class within the scope of 'A'.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A : public B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int A::B::b = 2;&nbsp;&nbsp;&nbsp; // B not nested in A</TT>
<BR><BR>The preceding example is illegal; the following is legal
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int A::B::b = 2;&nbsp;&nbsp;&nbsp; // B nested in A</TT>
<H2 ID="240_enum___s__has_not_been_declared"> 240 enum '%s' has not been declared </H2>
<BR>An elaborated reference to an<B><I> enum</I></B> could not be satisfied.&nbsp; All enclosing scopes have been searched
for an<B><I> enum</I></B> name.&nbsp; Visible variable declarations do not affect the search.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum E { e1, e2, e3 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E enum_var;&nbsp;&nbsp;&nbsp; // E not visible</TT>
<H2 ID="241_class_or_namespace___s__has_not_been_declared"> 241 class or namespace '%s' has not been declared </H2>
<BR>The construct &quot;A::B::C&quot; requires that 'A' be a class type or a namespace, and 'B' be a nested class or namespace
within the scope of 'A'.&nbsp; The reference to 'A' could not be satisfied.&nbsp; All enclosing scopes have been searched
for a<B><I> class</I></B> or<B><I> namespace</I></B> name.&nbsp; Visible variable declarations do not affect the search.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A{ int a; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int c = B::A::b;</TT>
<H2 ID="242_only_one_initializer_argument_allowed"> 242 only one initializer argument allowed </H2>
<BR>The comma (',') in a function like cast is treated like an argument list comma (',').&nbsp; If a comma expression is desired,
use parentheses to enclose the comma expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = int( 1, 2 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = int( ( 1, 2 ) );&nbsp;&nbsp;&nbsp; // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="243_default_arguments_are_not_part_of_a_function_s_type"> 243 default arguments are not part of a function's type </H2>
<BR>This message indicates that a declaration has been found that requires default arguments to be part of a function's type.
&nbsp;Either declaring a function<B><I> typedef</I></B> or a pointer to a function with default arguments are examples of
incorrect declarations.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int TD( int, int a = 14 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*p)( int, int a = 14 ) = 0;</TT>
<H2 ID="244_missing_default_arguments"> 244 missing default arguments </H2>
<BR>Gaps in a succession of default arguments are not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int = 1, int, int = 3 );</TT>
<H2 ID="245_overloaded_operator_cannot_have_default_arguments"> 245 overloaded operator cannot have default arguments </H2>
<BR>Preventing overloaded operators from having default arguments enforces the property that binary operators will only be
called from a use of a binary operator.&nbsp; Allowing default arguments would allow a binary<B><I> operator +</I></B> to
function as a unary<B><I> operator +.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C operator +( int a = 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="246_left_expression_is_not_a_pointer_to_a_constant_object"> 246 left expression is not a pointer to a constant object </H2>
<BR>One cannot assign a pointer to a constant type to a pointer to a non-constant type.&nbsp; This would allow a constant
object to be modified via the non-constant pointer.&nbsp; Use a cast if this is absolutely necessary.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char* fun( const char* p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="247_cannot_redefine_default_argument_for___S_"> 247 cannot redefine default argument for '%S' </H2>
<BR>Default arguments can only be defined once in a program regardless of whether the value of the default argument is identical.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int foo( int a = 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int foo( int a = 10 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a+a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="248_using_default_arguments_would_be_overload_ambiguous_with___S_"> 248 using default arguments would be overload ambiguous with '%S' </H2>
<BR>The declaration declares enough default arguments that the function is indistinguishable from another function of the
same name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int, int = 1 );</TT>
<BR><BR>Calling the function 'fn' with one argument is ambiguous because it could match either the first 'fn' without any
default arguments or the second 'fn' with a default argument applied.
<H2 ID="249_using_default_arguments_would_be_overload_ambiguous_with___S__using_default_arguments"> 249 using default arguments would be overload ambiguous with '%S' using default arguments </H2>
<BR>The declaration declares enough default arguments that the function is indistinguishable from another function of the
same name with default arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int, int = 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int, char = 'a' );</TT>
<BR><BR>Calling the function 'fn' with one argument is ambiguous because it could match either the first 'fn' with a default
argument or the second 'fn' with a default argument applied.
<H2 ID="250_missing_default_argument_for___S_"> 250 missing default argument for '%S' </H2>
<BR>In C++, one is allowed to add default arguments to the right hand arguments of a function declaration in successive declarations.
&nbsp;The message indicates that the declaration is only valid if there was a default argument previously declared for the
next argument.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn1( int&nbsp;&nbsp;&nbsp; , int&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn1( int&nbsp;&nbsp;&nbsp; , int = 3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn1( int = 2, int&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp; // OK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn2( int&nbsp;&nbsp;&nbsp; , int&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn2( int = 2, int&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp; // Error!</TT>
<H2 ID="251_enum_references_must_have_an_identifier"> 251 enum references must have an identifier </H2>
<BR>There is no way to reference an anonymous<B><I> enum.</I></B>&nbsp; If all enums are named, the cause of this message
is most likely a missing identifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum&nbsp;&nbsp; { X, Y, Z }; // anonymous enum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="252_class_declaration_has_not_been_seen_for____s_"> 252 class declaration has not been seen for '~%s' </H2>
<BR>A destructor has been used in a context where its class is not visible.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fun( C* p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;~S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="253______qualifier_cannot_be_used_in_this_context"> 253 '::' qualifier cannot be used in this context </H2>
<BR>Qualified identifiers in a class context are allowed for declaring<B><I> friend</I></B> member functions.&nbsp; The Open
Watcom C++ compiler also allows code that is qualified with its own class so that declarations can be moved in and out of
class definitions easily.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct N {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void S::foo() { // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void N::bar() { // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="254___S__has_not_been_declared_as_a_member"> 254 '%S' has not been declared as a member </H2>
<BR>In a definition of a class member, the indicated declaration must already have been declared when the class was defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int C::x = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C::not_decled() { }</TT>
<H2 ID="255_default_argument_expression_cannot_use_function_argument___S_"> 255 default argument expression cannot use function argument '%S' </H2>
<BR>Default arguments must be evaluated at each call.&nbsp; Since the order of evaluation for arguments is undefined, a compiler
must diagnose all default arguments that depend on other arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop( int d )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cannot access &quot;d&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo( int c, int b = d )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b + c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="256_default_argument_expression_cannot_use_local_variable___S_"> 256 default argument expression cannot use local variable '%S' </H2>
<BR>Default arguments must be evaluated at each call.&nbsp; Since a local variable is not always available in all contexts
(e.g., file scope initializers), a compiler must diagnose all default arguments that depend on local variables.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cannot access &quot;a&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo( int c, int b = a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b + c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="257_access_declarations_may_only_be__public__or__protected_"> 257 access declarations may only be 'public' or 'protected' </H2>
<BR>Access declarations are used to increase access.&nbsp; A<B><I> private</I></B> access declaration is useless because there
is no access level for which<B><I> private</I></B> is an increase in access.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pri;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pro;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pub;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Derived : public Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private: Base::pri;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="258_cannot_declare_both_a_function_and_variable_of_the_same_name_L__N_R"> 258 cannot declare both a function and variable of the same name ('%N') </H2>
<BR>Functions can be overloaded in C++ but they cannot be overloaded in the presence of a variable of the same name.&nbsp;
Likewise, one cannot declare a variable in the same scope as a set of overloaded functions of the same name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bad();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bad;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="259_class_in_access_declaration_L__T_R_must_be_a_direct_base_class"> 259 class in access declaration ('%T') must be a direct base class </H2>
<BR>Access declarations can only be applied to direct (immediate) base classes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int g;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : private C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B::f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>In the above example, &quot;C&quot; is a direct base class of &quot;D&quot; and &quot;B&quot; is a direct base class
of &quot;C&quot;, but &quot;B&quot; is not a direct base class of &quot;D&quot;.
<H2 ID="260_overloaded_functions_L__N_R_do_not_have_the_same_access"> 260 overloaded functions ('%N') do not have the same access </H2>
<BR>If an access declaration is referencing a set of overloaded functions, then they all must have the same access.&nbsp;
This is due to the lack of a type in an access declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int foo( int );&nbsp;&nbsp;&nbsp;&nbsp; // private</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int foo( float );&nbsp;&nbsp; // public</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class B : private C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public: C::foo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="261_cannot_grant_access_to___N_"> 261 cannot grant access to '%N' </H2>
<BR>A derived class cannot change the access of a base class member with an access declaration.&nbsp; The access declaration
can only be used to restore access changed by inheritance.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pub;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pro;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Der : private Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public: Base::pub;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public: Base::pro;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // changes
access</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="262_cannot_reduce_access_to___N_"> 262 cannot reduce access to '%N' </H2>
<BR>A derived class cannot change the access of a base class member with an access declaration.&nbsp; The access declaration
can only be used to restore access changed by inheritance.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pub;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pro;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Der : public Base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected: Base::pub;&nbsp;&nbsp; // changes access</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected: Base::pro;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="263_nested_class___N__has_not_been_defined"> 263 nested class '%N' has not been defined </H2>
<BR>The current state of the C++ language supports nested types.&nbsp; Unfortunately, this means that some working C code
will not work unchanged.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T *link;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>In the above example, the class &quot;T&quot; will be reported as not being defined by the end of the class declaration.
&nbsp;The code can be corrected in the following manner.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T *link;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="264_userMdefined_conversion_must_be_a_nonMstatic_member_function"> 264 user-defined conversion must be a non-static member function </H2>
<BR>A user-defined conversion is a special member function that allows the class to be converted implicitly (or explicitly)
to an arbitrary type.&nbsp; In order to do this, it must have access to an instance of the class so it is restricted to being
a non-static member function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static operator int();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="265_destructor_must_be_a_nonMstatic_member_function"> 265 destructor must be a non-static member function </H2>
<BR>A destructor is a special member function that will perform cleanup on a class before the storage for the class will be
released.&nbsp; In order to do this, it must have access to an instance of the class so it is restricted to being a non-static
member function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static ~S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="266___N__must_be_a_nonMstatic_member_function"> 266 '%N' must be a non-static member function </H2>
<BR>The operator function in the message is restricted to being a non-static member function.&nbsp; This usually means that
the operator function is treated in a special manner by the compiler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static operator =( C&amp;, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="267___N__must_have_one_argument"> 267 '%N' must have one argument </H2>
<BR>The operator function in the message is only allowed to have one argument.&nbsp; An operator like<B><I> operator ~</I></B>
is one such example because it represents a unary operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public: int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; operator~( const C&amp;, int );</TT>
<H2 ID="268___N__must_have_two_arguments"> 268 '%N' must have two arguments </H2>
<BR>The operator function in the message must have two arguments.&nbsp; An operator like<B><I> operator +=</I></B> is one
such example because it represents a binary operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public: int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; operator += ( const C&amp; );</TT>
<H2 ID="269___N__must_have_either_one_argument_or_two_arguments"> 269 '%N' must have either one argument or two arguments </H2>
<BR>The operator function in the message must have either one argument or two arguments.&nbsp; An operator like<B><I> operator
+</I></B> is one such example because it represents either a unary or a binary operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public: int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; operator+( const C&amp;, int, float );</TT>
<H2 ID="270___N__must_have_at_least_one_argument"> 270 '%N' must have at least one argument </H2>
<BR>The<B><I> operator new</I></B> and<B><I> operator new []</I></B> member functions must have at least one argument for
the size of the allocation.&nbsp; After that, any arguments are up to the programmer.&nbsp; The extra arguments can be supplied
in a<B><I> new</I></B> expression via the placement syntax.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * operator new( size_t, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S *p = new ('a') S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="271___N__must_have_a_return_type_of_void"> 271 '%N' must have a return type of void </H2>
<BR>The C++ language requires that<B><I> operator delete</I></B> and<B><I> operator delete []</I></B> have a return type of<B><I>
void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C* operator delete( void* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C* operator delete []( void* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="272___N__must_have_a_return_type_of_pointer_to_void"> 272 '%N' must have a return type of pointer to void </H2>
<BR>The C++ language requires that both<B><I> operator new</I></B> and<B><I> operator new []</I></B> have a return type of<TT>
void *.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C* operator new( size_t size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C* operator new []( size_t size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="273_the_first_argument_of___N__must_be_of_type_size_t"> 273 the first argument of '%N' must be of type size_t </H2>
<BR>The C++ language requires that the first argument for<B><I> operator new</I></B> and<B><I> operator new []</I></B> be
of the type &quot;size_t&quot;.&nbsp; The definition for &quot;size_t&quot; can be included by using the standard header file
&lt;stddef.h&gt;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *operator new( int size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *operator new( double size, char c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *operator new []( int size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *operator new []( double size, char c );</TT>
<H2 ID="274_the_first_argument_of___N__must_be_of_type_pointer_to_void"> 274 the first argument of '%N' must be of type pointer to void </H2>
<BR>The C++ language requires that the first argument for<B><I> operator delete</I></B> and<B><I> operator delete []</I></B>
be a<TT> void *.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void operator delete( C* );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void operator delete []( C* );</TT>
<H2 ID="275_the_second_argument_of___N__must_be_of_type_size_t"> 275 the second argument of '%N' must be of type size_t </H2>
<BR>The C++ language requires that the second argument for<B><I> operator delete</I></B> and<B><I> operator delete []</I></B>
be of type &quot;size_t&quot;.&nbsp; The two argument form of<B><I> operator delete</I></B> and<B><I> operator delete []</I></B>
is optional and it can only be present inside of a class declaration.&nbsp; The definition for &quot;size_t&quot; can be included
by using the standard header file &lt;stddef.h&gt;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator delete( void *, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator delete []( void *, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="276_the_second_argument_of__operator_PP__or__operator_MM__must_be_int"> 276 the second argument of 'operator ++' or 'operator --' must be int </H2>
<BR>The C++ language requires that the second argument for<B><I> operator ++</I></B> be<B><I> int.</I></B>&nbsp; The two argument
form of<B><I> operator ++</I></B> is used to overload the postfix operator &quot;++&quot;.&nbsp; The postfix operator &quot;--&quot;
can be overloaded similarly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long cv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; operator ++( C&amp;, unsigned );</TT>
<H2 ID="277_return_type_of___S__must_allow_the__MY__operator_to_be_applied"> 277 return type of '%S' must allow the '-&gt;' operator to be applied </H2>
<BR>This restriction is a result of the transformation that the compiler performs when the<B><I> operator -&gt;</I></B> is
overloaded.&nbsp; The transformation involves transforming the expression to invoke the operator with &quot;-&gt;&quot; applied
to the result of<B><I> operator -&gt;.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S *operator -&gt;();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( S &amp;q )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q-&gt;a = 1; // becomes (q.operator -&gt;())-&gt;a = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="278___N__must_take_at_least_one_argument_of_a_classDenum_or_a_reference_to_a_classDenum"> 278 '%N' must take at least one argument of a class/enum or a reference to a class/enum </H2>
<BR>Overloaded operators can only be defined for classes and enumerations.&nbsp; At least one argument, must be a class or
an enum type in order for the C++ compiler to distinguish the operator from the built-in operators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long cv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&amp; operator ++( unsigned, int );</TT>
<H2 ID="279_too_many_initializers"> 279 too many initializers </H2>
<BR>The compiler has detected extra initializers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a[3] = { 1, 2, 3, 4 };</TT>
<H2 ID="280_too_many_initializers_for_character_string"> 280 too many initializers for character string </H2>
<BR>A string literal used in an initialization of a character array is viewed as providing the terminating null character.
&nbsp;If the number of array elements isn't enough to accept the terminating character, this message is output.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char ac[3] = &quot;abc&quot;;</TT>
<H2 ID="281_expecting___s__but_found_expression"> 281 expecting '%s' but found expression </H2>
<BR>This message is output when some bracing or punctuation is expected but an expression was encountered.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b[3] = 3;</TT>
<H2 ID="282_anonymous_structDunion_member___N__cannot_be_declared_in_this_class"> 282 anonymous struct/union member '%N' cannot be declared in this class </H2>
<BR>An anonymous member cannot be declared with the same name as its containing class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int S;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="283_unexpected___s__during_initialization"> 283 unexpected '%s' during initialization </H2>
<BR>This message is output when some unexpected bracing or punctuation is encountered during initialization.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int e = { { 1 };</TT>
<H2 ID="284_nested_type___N__cannot_be_declared_in_this_class"> 284 nested type '%N' cannot be declared in this class </H2>
<BR>A nested type cannot be declared with the same name as its containing class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef int S;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="285_enumerator___N__cannot_be_declared_in_this_class"> 285 enumerator '%N' cannot be declared in this class </H2>
<BR>An enumerator cannot be declared with the same name as its containing class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum E {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S,&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="286_static_member___N__cannot_be_declared_in_this_class"> 286 static member '%N' cannot be declared in this class </H2>
<BR>A static member cannot be declared with the same name as its containing class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int S;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="287_constructor_cannot_have_a_return_type"> 287 constructor cannot have a return type </H2>
<BR>A constructor cannot have a return type (even<B><I> void</I></B> ).&nbsp; The constructor is a special member function
that is not required to be identical in form to all other member functions.&nbsp; This allows different implementations to
have different uses for any return values.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&amp; C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="288_constructor_cannot_be_a_static_member"> 288 constructor cannot be a static member </H2>
<BR>A constructor is a special member function that takes raw storage and changes it into an instance of a class.&nbsp; In
order to do this, it must have access to storage for the instance of the class so it is restricted to being a non-static member
function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="289_invalid_copy_constructor_argument_list_Lcauses_infinite_recursionR"> 289 invalid copy constructor argument list (causes infinite recursion) </H2>
<BR>A copy constructor's first argument must be a reference argument.&nbsp; Furthermore, any default arguments must also be
reference arguments.&nbsp; Without the reference, a copy constructor would require a copy constructor to execute in order
to prepare its arguments.&nbsp; Unfortunately, this would be calling itself since it is the copy constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( S const &amp; );&nbsp;&nbsp; // copy constructor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="290_constructor_cannot_be_declared_const_or_volatile"> 290 constructor cannot be declared const or volatile </H2>
<BR>A constructor must be able to operate on all instances of classes regardless of whether they are<B><I> const</I></B> or<B><I>
volatile.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( int ) const;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( float ) volatile;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="291_constructor_cannot_be_virtual"> 291 constructor cannot be virtual </H2>
<BR>Virtual functions cannot be called for an object before it is constructed.&nbsp; For this reason, a virtual constructor
is not allowed in the C++ language.&nbsp; Techniques for simulating a virtual constructor are known, one such technique is
described in the ARM p.263.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="292_types_do_not_match_in_simple_type_destructor"> 292 types do not match in simple type destructor </H2>
<BR>A simple type destructor is available for &quot;destructing&quot; simple types.&nbsp; The destructor has no effect.&nbsp;
Both of the types must be identical, for the destructor to have meaning.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;int::~double();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="293_overloaded_operator_is_ambiguous_for_operands_used"> 293 overloaded operator is ambiguous for operands used </H2>
<BR>The Open Watcom C++ compiler performs exhaustive analysis using formalized techniques in order to decide what implicit
conversions should be applied for overloading operators.&nbsp; Because of this, Open Watcom C++ detects ambiguities that may
escape other C++ compilers.&nbsp; The most common ambiguity that Open Watcom C++ detects involves classes having constructors
with single arguments and a user-defined conversion.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator int();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn( int b, int i, S s )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; i&nbsp;&nbsp;&nbsp; : s.operator int()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OR S(i) : s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b ? i : s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the above example, &quot;i&quot; and &quot;s&quot; must be brought to a common type.&nbsp; Unfortunately, there
are two common types so the compiler cannot decide which one it should choose, hence an ambiguity.
<H2 ID="294_feature_not_implemented"> 294 feature not implemented </H2>
<BR>The compiler does not support the indicated feature.
<H2 ID="295_invalid_friend_declaration"> 295 invalid friend declaration </H2>
<BR>This message indicates that the compiler found extra declaration specifiers like<B><I> auto,</I></B> <B><I> float,</I></B>
or<B><I> const</I></B> in the friend declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend float;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="296_friend_declarations_may_only_be_declared_in_a_class"> 296 friend declarations may only be declared in a class </H2>
<BR>This message indicates that a<B><I> friend</I></B> declaration was found outside a class scope (i.e., a class definition).
&nbsp;Friends are only meaningful for class types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; friend void foo();</TT>
<H2 ID="297_class_friend_declaration_needs__class__or__struct__keyword"> 297 class friend declaration needs 'class' or 'struct' keyword </H2>
<BR>The C++ language has evolved to require that all friend class declarations be of the form &quot;class S&quot; or &quot;struct
S&quot;.&nbsp; The Open Watcom C++ compiler accepts the older syntax with a warning but rejects the syntax in pure ISO/ANSI
C++ mode.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend S;&nbsp;&nbsp; // should be &quot;friend class S;&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="298_class_friend_declarations_cannot_contain_a_class_definition"> 298 class friend declarations cannot contain a class definition </H2>
<BR>A class friend declaration cannot define a new class.&nbsp; This is a restriction required in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend struct X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="299___T__has_already_been_declared_as_a_friend"> 299 '%T' has already been declared as a friend </H2>
<BR>The class in the message has already been declared as a friend.&nbsp; Remove the extra friend declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="300_function___S__has_already_been_declared_as_a_friend"> 300 function '%S' has already been declared as a friend </H2>
<BR>The function in the message has already been declared as a friend.&nbsp; Remove the extra friend declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend void foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend void foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="301__friend____virtual__or__inline__modifiers_are_not_part_of_a_function_s_type"> 301 'friend', 'virtual' or 'inline' modifiers are not part of a function's type </H2>
<BR>This message indicates that the modifiers may be incorrectly placed in the declaration.&nbsp; If the declaration is intended,
it cannot be accepted because the modifiers can only be applied to functions that have code associated with them.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef friend (*PF)( void );</TT>
<H2 ID="302_cannot_assign_right_expression_to_element_on_left"> 302 cannot assign right expression to element on left </H2>
<BR>This message indicates that the assignment cannot be performed.&nbsp; It usually arises in assignments of a class type
to an arithmetic type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; int sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="303_constructor_is_ambiguous_for_operands_used"> 303 constructor is ambiguous for operands used </H2>
<BR>The operands provided for the constructor did not select a unique constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S x = S(1.0);</TT>
<H2 ID="304_class___s__has_not_been_defined"> 304 class '%s' has not been defined </H2>
<BR>The name before a '::' scope resolution operator must be defined unless a member pointer is being declared.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* p; // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::a = 1;&nbsp;&nbsp; // Error!</TT>
<H2 ID="305_all_bitMfields_in_a_union_must_be_named"> 305 all bit-fields in a union must be named </H2>
<BR>This is a restriction in the C++ language.&nbsp; The same effect can be achieved with a named bitfield.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; unsigned bit1 :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned :6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="306_cannot_convert_expression_to_type_of_cast"> 306 cannot convert expression to type of cast </H2>
<BR>The cast is trying to convert an expression to a completely unrelated type.&nbsp; There is no way the compiler can provide
any meaning for the intended cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T y = (T) 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="307_conversion_ambiguity__UexpressionV_to_Ucast_typeV"> 307 conversion ambiguity:&nbsp; [expression] to [cast type] </H2>
<BR>The cast caused a constructor overload to occur.&nbsp; The operands provided for the constructor did not select a unique
constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S x = (S) 1.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="308_an_anonymous_class_without_a_declarator_is_useless"> 308 an anonymous class without a declarator is useless </H2>
<BR>There is no way to reference the type in this kind of declaration.&nbsp; A name must be provided for either the class
or a variable using the class as its type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="309_global_anonymous_union_must_be_declared_static"> 309 global anonymous union must be declared static </H2>
<BR>This is a restriction in the C++ language.&nbsp; Since there is no unique name for the anonymous union, it is difficult
for C++ translators to provide a correct implementation of external linkage anonymous unions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="310_anonymous_structDunion_cannot_have_storage_class_in_this_context"> 310 anonymous struct/union cannot have storage class in this context </H2>
<BR>Anonymous unions (or structs) declared in class scopes cannot be<B><I> static.</I></B>&nbsp; Any other storage class is
also disallowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned us;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="311_union_contains_a_protected_member"> 311 union contains a protected member </H2>
<BR>A union cannot have a<B><I> protected</I></B> member because a union cannot be a base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } u;</TT>
<H2 ID="312_anonymous_structDunion_contains_a_private_member___S_"> 312 anonymous struct/union contains a private member '%S' </H2>
<BR>An anonymous union (or struct) cannot have member functions or friends so it cannot have<B><I> private</I></B> members
since no code could access them.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; private:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="313_anonymous_structDunion_contains_a_function_member___S_"> 313 anonymous struct/union contains a function member '%S' </H2>
<BR>An anonymous union (or struct) cannot have any function members.&nbsp; This is a restriction in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo();&nbsp;&nbsp;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="314_anonymous_structDunion_contains_a_typedef_member___S_"> 314 anonymous struct/union contains a typedef member '%S' </H2>
<BR>An anonymous union (or struct) cannot have any nested types.&nbsp; This is a restriction in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef float F;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F fv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="315_anonymous_structDunion_contains_an_enumeration_member___S_"> 315 anonymous struct/union contains an enumeration member '%S' </H2>
<BR>An anonymous union (or struct) cannot have any enumeration members.&nbsp; This is a restriction in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum choice { good, bad, indifferent };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; choice c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="316_anonymous_structDunion_member___s__is_not_distinct_in_enclosing_scope"> 316 anonymous struct/union member '%s' is not distinct in enclosing scope </H2>
<BR>Since an anonymous union (or struct) provides its member names to the enclosing scope, the names must not collide with
other names in the enclosing scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int iv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="317_unions_cannot_have_members_with_destructors"> 317 unions cannot have members with destructors </H2>
<BR>A union should only be used to organize memory in C++.&nbsp; Allowing union members to have destructors would mean that
the same piece of memory could be destructed twice.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sv1, sv2, sv3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~T();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S su;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T tu;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="318_unions_cannot_have_members_with_userMdefined_assignment_operators"> 318 unions cannot have members with user-defined assignment operators </H2>
<BR>A union should only be used to organize memory in C++.&nbsp; Allowing union members to have assignment operators would
mean that the same piece of memory could be assigned twice.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sv1, sv2, sv3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator = ( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator = ( float );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S su;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T tu;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } u;</TT>
<H2 ID="319_anonymous_structDunion_cannot_have_any_friends"> 319 anonymous struct/union cannot have any friends </H2>
<BR>An anonymous union (or struct) cannot have any friends.&nbsp; This is a restriction in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sv1, sv2, sv3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S su1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S su2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="320_specific_versions_of_template_classes_can_only_be_defined_in_file_scope"> 320 specific versions of template classes can only be defined in file scope </H2>
<BR>Currently, specific versions of class templates can only be declared at file scope.&nbsp; This simple restriction was
chosen in favour of more freedom with possibly subtle restrictions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class G&gt; class S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Q {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S&lt;int&gt; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S&lt;double&gt; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="321_anonymous_union_in_a_function_may_only_be_static_or_auto"> 321 anonymous union in a function may only be static or auto </H2>
<BR>The current C++ language definition only allows<B><I> auto</I></B> anonymous unions.&nbsp; The Open Watcom C++ compiler
allows<B><I> static</I></B> anonymous unions.&nbsp; Any other storage class is not allowed.
<H2 ID="322_static_data_members_are_not_allowed_in_a_local_class"> 322 static data members are not allowed in a local class </H2>
<BR>Static data members are not allowed in a local class because there is no way to define the static member in file scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct local {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local lv;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lv.s = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return lv.s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="323_conversion_ambiguity__Ureturn_valueV_to_Ureturn_type_of_functionV"> 323 conversion ambiguity:&nbsp; [return value] to [return type of function] </H2>
<BR>The cast caused a constructor overload to occur.&nbsp; The operands provided for the constructor did not select a unique
constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="324_conversion_of_return_value_is_impossible"> 324 conversion of return value is impossible </H2>
<BR>The return is trying to convert an expression to a completely unrelated type.&nbsp; There is no way the compiler can provide
any meaning for the intended return type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; T fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="325_function_cannot_return_a_pointer_based_on___self"> 325 function cannot return a pointer based on __self </H2>
<BR>A function cannot return a pointer that is based on<B><I> __self.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __based(__self) *fn( unsigned );</TT>
<H2 ID="326_defining___S__is_not_possible_because_its_type_has_unknown_size"> 326 defining '%S' is not possible because its type has unknown size </H2>
<BR>In order to define a variable, the size must be known so that the correct amount of storage can be reserved.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S sv;</TT>
<H2 ID="327_typedef_cannot_be_initialized"> 327 typedef cannot be initialized </H2>
<BR>Initializing a<B><I> typedef</I></B> is meaningless in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int INT = 15;</TT>
<H2 ID="328_storage_class_of___S__conflicts_with_previous_declaration"> 328 storage class of '%S' conflicts with previous declaration </H2>
<BR>The symbol declaration conflicts with a previous declaration with regard to storage class.&nbsp; A symbol cannot be both<B><I>
static</I></B> and<B><I> extern.</I></B>&nbsp; 
<H2 ID="329_modifiers_of___S__conflict_with_previous_declaration"> 329 modifiers of '%S' conflict with previous declaration </H2>
<BR>The symbol declaration conflicts with a previous declaration with regard to modifiers.&nbsp; Correct the program by using
the same modifiers for both declarations.
<H2 ID="330_function_cannot_be_initialized"> 330 function cannot be initialized </H2>
<BR>A function cannot be initialized with an initializer syntax intended for variables.&nbsp; A function body is the only
way to provide a definition for a function.
<H2 ID="331_access_permission_of_nested_class___T__conflicts_with_previous_declaration"> 331 access permission of nested class '%T' conflicts with previous declaration </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct N;&nbsp;&nbsp; // public</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; private:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct N {&nbsp; // private</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="332_TTT_FATAL_TTT_internal_error_in_front_end"> 332 *** FATAL *** internal error in front end </H2>
<BR>If this message appears, please report the problem directly to the Open Watcom development team.&nbsp; See http://www.openwatcom.org/.
<H2 ID="333_cannot_convert_argument_to_type_specified_in_function_prototype"> 333 cannot convert argument to type specified in function prototype </H2>
<BR>It is impossible to convert the indicated argument in the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( int&amp; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int m;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int n;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( m + n );</TT>
<BR><BR>In the example, the value of &quot;m+n&quot; cannot be converted to a reference (it could be converted to a constant
reference), as shown in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( const int&amp; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int m;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int n;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( m + n );</TT>
<H2 ID="334_conversion_ambiguity__UargumentV_to_Uargument_type_in_prototypeV"> 334 conversion ambiguity:&nbsp; [argument] to [argument type in prototype] </H2>
<BR>An argument in the function call could not be converted since there is more than one constructor or user-defined conversion
which could be used to convert the argument.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T( S&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator T();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( T );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( s );&nbsp;&nbsp; // ambiguous</TT>
<BR><BR>In the example, the argument &quot;s&quot; could be converted by both the constructor in class &quot;T&quot; and by
the user-conversion in class &quot;S&quot;.
<H2 ID="335_cannot_be_based_on_based_pointer___S_"> 335 cannot be based on based pointer '%S' </H2>
<BR>A based pointer cannot be based on another based pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segment s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __based(s) *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __based(p) *q;</TT>
<H2 ID="336_declaration_specifiers_are_required_to_declare___N_"> 336 declaration specifiers are required to declare '%N' </H2>
<BR>The compiler has detected that the name does not represent a function.&nbsp; Only function declarations can leave out
declaration specifiers.&nbsp; This error also shows up when a typedef name declaration is missing.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int;</TT>
<H2 ID="337_static_function_declared_in_block_scope"> 337 static function declared in block scope </H2>
<BR>The C++ language does not allow static functions to be declared in block scope.&nbsp; This error can be triggered when
the intent is to define a<B><I> static</I></B> variable.&nbsp; Due to the complexities of parsing C++, statements that appear
to be variable definitions may actually parse as function prototypes.&nbsp; A work-around for this problem is contained in
the example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( C );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static S a( C() );&nbsp; // function prototype!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static S b( (C()) );// variable definition</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="338_cannot_define_a___based_reference"> 338 cannot define a __based reference </H2>
<BR>A C++ reference cannot be based on anything.&nbsp; Based modifiers can only be used with pointers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segment s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int __based(s) &amp; x );</TT>
<H2 ID="339_conversion_ambiguity__conversion_to_common_pointer_type"> 339 conversion ambiguity:&nbsp; conversion to common pointer type </H2>
<BR>A conversion to a common base class of two different pointers has been attempted.&nbsp; The pointer conversion could not
be performed because the destination type points to an ambiguous base class of one of the source types.
<H2 ID="340_cannot_construct_object_from_argumentLsR"> 340 cannot construct object from argument(s) </H2>
<BR>There is not an appropriate constructor for the set of arguments provided.
<H2 ID="341_number_of_arguments_for_function___S__is_incorrect"> 341 number of arguments for function '%S' is incorrect </H2>
<BR>The number of arguments in the function call does not match the number declared for the indicated non-overloaded function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int foo( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = foo( 1, 2, 3 );</TT>
<BR><BR>In the example, the function was declared to have two arguments.&nbsp; Three arguments were used in the call.
<H2 ID="342_private_base_class_accessed_to_convert_cast_expression"> 342 private base class accessed to convert cast expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : private Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Der *pd;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Priv *pp = (Priv*)pd;</TT>
<H2 ID="343_private_base_class_accessed_to_convert_return_expression"> 343 private base class accessed to convert return expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : private Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Priv *foo( Der *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="344_cannot_subtract_pointers_to_different_objects"> 344 cannot subtract pointers to different objects </H2>
<BR>Pointer subtraction can be performed only for objects of the same type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ptrdiff_t diff( float *fp, int *ip )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fp - ip;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, a diagnostic results from the attempt to subtract a pointer to an<B><I> int</I></B> object from a
pointer to a<B><I> float</I></B> object.
<H2 ID="345_private_base_class_accessed_to_convert_to_common_pointer_type"> 345 private base class accessed to convert to common pointer type </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : private Priv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( Der *pd, Priv *pp )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pd == pp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="346_protected_base_class_accessed_to_convert_cast_expression"> 346 protected base class accessed to convert cast expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : protected Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Der *pd;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Prot *pp = (Prot*)pd;</TT>
<H2 ID="347_protected_base_class_accessed_to_convert_return_expression"> 347 protected base class accessed to convert return expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : protected Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Prot *foo( Der *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="348_cannot_define_a_member_pointer_with_a_memory_model_modifier"> 348 cannot define a member pointer with a memory model modifier </H2>
<BR>A member pointer describes how to access a field from a class.&nbsp; Because of this a member pointer must be independent
of any memory model considerations.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int near S::*mp;</TT>
<H2 ID="349_protected_base_class_accessed_to_convert_to_common_pointer_type"> 349 protected base class accessed to convert to common pointer type </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Der : protected Prot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( Der *pd, Prot *pp )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pd == pp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="350_nonMtype_parameter_supplied_for_a_type_argument"> 350 non-type parameter supplied for a type argument </H2>
<BR>A non-type parameter (e.g., an address or a constant expression) has been supplied for a template type argument.&nbsp;
A type should be used instead.
<H2 ID="351_type_parameter_supplied_for_a_nonMtype_argument"> 351 type parameter supplied for a non-type argument </H2>
<BR>A type parameter (e.g.,<B><I> int</I></B> ) has been supplied for a template non-type argument.&nbsp; An address or a
constant expression should be used instead.
<H2 ID="352_cannot_access_enclosing_function_s_auto_variable___S_"> 352 cannot access enclosing function's auto variable '%S' </H2>
<BR>A local class member function cannot access its enclosing function's automatic variables.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo( int c, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b + c + a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="353_cannot_initialize_pointer_to_nonMconstant_with_a_pointer_to_constant"> 353 cannot initialize pointer to non-constant with a pointer to constant </H2>
<BR>A pointer to a non-constant type cannot be initialized with a pointer to a constant type because this would allow constant
data to be modified via the non-constant pointer to it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int *pic;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int *pi = pic;</TT>
<H2 ID="354_pointer_expression_is_always_YE_0"> 354 pointer expression is always &gt;= 0 </H2>
<BR>The indicated pointer expression will always be true because the pointer value is always treated as an unsigned quantity,
which will be greater or equal to zero.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned k = ( 0 &lt;= p );&nbsp;&nbsp;&nbsp; // always 1</TT>
<H2 ID="355_pointer_expression_is_never_X_0"> 355 pointer expression is never &lt; 0 </H2>
<BR>The indicated pointer expression will always be false because the pointer value is always treated as an unsigned quantity,
which will be greater or equal zero.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned k = ( 0 &gt;= p );&nbsp;&nbsp; // always 0</TT>
<H2 ID="356_type_cannot_be_used_in_this_context"> 356 type cannot be used in this context </H2>
<BR>This message is issued when a type name is being used in a context where a non-type name should be used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef int T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( S *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;T = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="357_virtual_function_may_only_be_declared_in_a_class"> 357 virtual function may only be declared in a class </H2>
<BR>Virtual functions can only be declared inside of a class.&nbsp; This error may be a result of forgetting the &quot;C::&quot;
qualification of a virtual function's name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtual void foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtual void bar()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = 9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="358___T__referenced_as_a_union"> 358 '%T' referenced as a union </H2>
<BR>A class type defined as a<B><I> class</I></B> or<B><I> struct</I></B> has been referenced as a<B><I> union</I></B> (i.e.,
union S).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s1, s2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union S var;</TT>
<H2 ID="359_union___T__referenced_as_a_class"> 359 union '%T' referenced as a class </H2>
<BR>A class type defined as a<B><I> union</I></B> has been referenced as a<B><I> struct</I></B> or a<B><I> class</I></B> (i.e.,
class S).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s1, s2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S var;</TT>
<H2 ID="360_typedef___N__defined_without_an_explicit_type"> 360 typedef '%N' defined without an explicit type </H2>
<BR>The typedef declaration was found to not have an explicit type in the declaration.&nbsp; If<B><I> int</I></B> is the desired
type, use an explicit<B><I> int</I></B> keyword to specify the type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef T;</TT>
<H2 ID="361_member_function_was_not_defined_in_its_class"> 361 member function was not defined in its class </H2>
<BR>Member functions of local classes must be defined in their class if they will be defined at all.&nbsp; This is a result
of the C++ language not allowing nested function definitions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="362_local_class_can_only_have_its_containing_function_as_a_friend"> 362 local class can only have its containing function as a friend </H2>
<BR>A local class can only be referenced from within its containing function.&nbsp; It is impossible to define an external
function that can reference the type of the local class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void ext();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend void ext();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="363_local_class_cannot_have___S__as_a_friend"> 363 local class cannot have '%S' as a friend </H2>
<BR>The only classes that a local class can have as a friend are classes within its own containing scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct ext</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class ext;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="364_adjacent_YE__XE__Y__X_operators"> 364 adjacent &gt;=, &lt;=, &gt;, &lt; operators </H2>
<BR>This message is warning about the possibility that the code may not do what was intended.&nbsp; An expression like &quot;a
&gt; b &gt; c&quot; evaluates one relational operator to a 1 or a 0 and then compares it against the other variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = a &gt; b &gt; c;</TT>
<H2 ID="365_cannot_access_enclosing_function_s_argument___S_"> 365 cannot access enclosing function's argument '%S' </H2>
<BR>A local class member function cannot access its enclosing function's arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop( int d )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo( int c, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b + c + d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="366_support_for_switch___s__is_not_implemented"> 366 support for switch '%s' is not implemented </H2>
<BR>Actions for the indicated switch have not been implemented.&nbsp; The switch is supported for compatibility with the Open
Watcom C compiler.
<H2 ID="367_conditional_expression_in_if_statement_is_always_true"> 367 conditional expression in if statement is always true </H2>
<BR>The compiler has detected that the expression will always be true.&nbsp; If this is not the expected behaviour, the code
may contain a comparison of an unsigned value against zero (e.g., unsigned integers are always greater than or equal to zero).
&nbsp;Comparisons against zero for addresses can also result in trivially true expressions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TEST 143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( TEST ) return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="368_conditional_expression_in_if_statement_is_always_false"> 368 conditional expression in if statement is always false </H2>
<BR>The compiler has detected that the expression will always be false.&nbsp; If this is not the expected behaviour, the code
may contain a comparison of an unsigned value against zero (e.g., unsigned integers are always greater than or equal to zero).
&nbsp;Comparisons against zero for addresses can also result in trivially false expressions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TEST 14-14</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( TEST ) return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="369_selection_expression_in_switch_statement_is_a_constant_value"> 369 selection expression in switch statement is a constant value </H2>
<BR>The expression in the<B><I> switch</I></B> statement is a constant.&nbsp; This means that only one case label will be
executed.&nbsp; If this is not the expected behaviour, check the switch expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TEST 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch ( TEST ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="370_constructor_is_required_for_a_class_with_a_const_member"> 370 constructor is required for a class with a const member </H2>
<BR>If a class has a constant member, a constructor is required in order to initialize it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="371_constructor_is_required_for_a_class_with_a_reference_member"> 371 constructor is required for a class with a reference member </H2>
<BR>If a class has a reference member, a constructor is required in order to initialize it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&amp; r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="372_inline_member_friend_function___S__is_not_allowed"> 372 inline member friend function '%S' is not allowed </H2>
<BR>A friend that is a member function of another class cannot be defined.&nbsp; Inline friend rules are currently in flux
so it is best to avoid inline friends.
<H2 ID="373_invalid_modifier_for_auto_variable"> 373 invalid modifier for auto variable </H2>
<BR>An automatic variable cannot have a memory model adjustment because they are always located on the stack (or in a register).
&nbsp;There are also other types of modifiers that are not allowed for auto variables such as thread-specific data modifiers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn( int far x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int far y = x + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="374_object_Lor_object_pointerR_required_to_access_nonMstatic_data_member"> 374 object (or object pointer) required to access non-static data member </H2>
<BR>A reference to a member in a class has occurred.&nbsp; The member is non-static so in order to access it, an object of
the class is required.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = 1;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="375_userMdefined_conversion_has_not_been_declared"> 375 user-defined conversion has not been declared </H2>
<BR>The named user-defined conversion has not been declared in the class of any of its base classes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator int();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double fn( S *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p-&gt;operator double();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="376_virtual_function_must_be_a_nonMstatic_member_function"> 376 virtual function must be a non-static member function </H2>
<BR>A member function cannot be both a<B><I> static</I></B> function and a<B><I> virtual</I></B> function.&nbsp; A static
member function does not have a<B><I> this</I></B> argument whereas a<B><I> virtual</I></B> function must have a<B><I> this</I></B>
argument so that the virtual function table can be accessed in order to call it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static virtual int foo();&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int bar();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int stat();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="377_protected_base_class_accessed_to_convert_argument_expression"> 377 protected base class accessed to convert argument expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; protected:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int cfun( C );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = cfun( 14 );</TT>
<BR><BR>The last line is erroneous since the constructor is protected.
<H2 ID="378_private_base_class_accessed_to_convert_argument_expression"> 378 private base class accessed to convert argument expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int cfun( C );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = cfun( 14 );</TT>
<BR><BR>The last line is erroneous since the constructor is private.
<H2 ID="379_delete_expression_will_invoke_a_nonMvirtual_destructor"> 379 delete expression will invoke a non-virtual destructor </H2>
<BR>In C++, it is possible to assign a base class pointer the value of a derived class pointer so that code that makes use
of base class virtual functions can be used.&nbsp; A problem that occurs is that a<B><I> delete</I></B> has to know the correct
size of the type in some instances (i.e., when a two argument version of<B><I> operator delete</I></B> is defined for a class).
&nbsp;This problem is solved by requiring that a destructor be defined as<B><I> virtual</I></B> if polymorphic deletes must
work.&nbsp; The<B><I> delete</I></B> expression will virtually call the correct destructor, which knows the correct size of
the complete object.&nbsp; This message informs you that the class you are deleting has virtual functions but it has a non-virtual
destructor.&nbsp; This means that the delete will not work correctly in all circumstances.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator delete( void *, size_t );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~B();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator delete( void *, size_t );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~D();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void dfn( B *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete p;&nbsp;&nbsp; // could be a pointer to D!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="380__offsetof__is_not_allowed_for_a_function"> 380 'offsetof' is not allowed for a function </H2>
<BR>A member function does not have an offset like simple data members.&nbsp; If this is required, use a member pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int s = offsetof( S, fun );</TT>
<H2 ID="381__offsetof__is_not_allowed_for_an_enumeration"> 381 'offsetof' is not allowed for an enumeration </H2>
<BR>An enumeration does not have an offset like simple data members.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum SE { S1, S2, S3, S4 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SE var;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int s = offsetof( S, SE );</TT>
<H2 ID="382_could_not_initialize_for_code_generation"> 382 could not initialize for code generation </H2>
<BR>The source code has been parsed and fully analysed when this error is emitted.&nbsp; The compiler attempted to start generating
object code but due to some problem (e.g., out of memory, no file handles) could not initialize itself.&nbsp; Try changing
the compilation environment to eliminate this error.
<H2 ID="383__offsetof__is_not_allowed_for_an_undefined_type"> 383 'offsetof' is not allowed for an undefined type </H2>
<BR>The class type used in<B><I> offsetof</I></B> must be completely defined, otherwise data member offsets will not be known.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c[ offsetof( S, b ) ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="384_attempt_to_override_virtual_function___S__with_a_different_return_type"> 384 attempt to override virtual function '%S' with a different return type </H2>
<BR>A function cannot be overloaded with identical argument types and a different return type.&nbsp; This is due to the fact
that the C++ language does not consider the function's return type when overloading.&nbsp; The exception to this rule in the
C++ language involves restricted changes in the return type of virtual functions.&nbsp; The derived virtual function's return
type can be derived from the return type of the base virtual function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual B *fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual D *fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="385_attempt_to_overload_function___S__with_a_different_return_type"> 385 attempt to overload function '%S' with a different return type </H2>
<BR>A function cannot be overloaded with identical argument types and a different return type.&nbsp; This is due to the fact
that the C++ language does not consider the function's return type when overloading.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned foo( char );</TT>
<H2 ID="386_attempt_to_use_pointer_to_undefined_class"> 386 attempt to use pointer to undefined class </H2>
<BR>An attempt was made to indirect or increment a pointer to an undefined class.&nbsp; Since the class is undefined, the
size is not known so the compiler cannot compile the expression properly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern C* pc1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C* pc2 = ++pc1;&nbsp;&nbsp;&nbsp;&nbsp; // C not defined</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( C*p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p-&gt;x;&nbsp;&nbsp;&nbsp; // C not defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="387_expression_is_useful_only_for_its_side_effects"> 387 expression is useful only for its side effects </H2>
<BR>The indicated expression is not meaningful.&nbsp; The expression, however, does contain one or more side effects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int* i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(i++);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, the expression is a reference to an integer which is meaningless in itself.&nbsp; The incrementation
of the pointer in the expression is a side effect.
<H2 ID="388_integral_constant_will_be_truncated_during_assignment_or_initialization"> 388 integral constant will be truncated during assignment or initialization </H2>
<BR>This message indicates that the compiler knows that a constant value will not be preserved after the assignment.&nbsp;
If this is acceptable, cast the constant value to the appropriate type in the assignment.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char c = 567;</TT>
<H2 ID="389_integral_value_may_be_truncated_during_assignment_or_initialization"> 389 integral value may be truncated during assignment or initialization </H2>
<BR>This message indicates that the compiler knows that all values will not be preserved after the assignment.&nbsp; If this
is acceptable, cast the value to the appropriate type in the assignment.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char c = s;</TT>
<H2 ID="390_cannot_generate_default_constructor_to_initialize___T__since_constructors_were_declared"> 390 cannot generate default constructor to initialize '%T' since constructors were declared </H2>
<BR>A default constructor will not be generated by the compiler if there are already constructors declared.&nbsp; Try using
default arguments to change one of the constructors to a default constructor or define a default constructor explicitly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( const C&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C cv;</TT>
<H2 ID="391_assignment_found_in_boolean_expression"> 391 assignment found in boolean expression </H2>
<BR>This is a construct that can lead to errors if it was intended to be an equality (using &quot;==&quot;) test.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( int a, int b )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( a = b ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // always return 1
?</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="392_definition____F_"> 392 definition:&nbsp; '%F' </H2>
<BR>This informational message indicates where the symbol in question was defined.&nbsp; The message is displayed following
an error or warning diagnostic for the symbol in question.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int a = 9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b = 89;</TT>
<BR><BR>The variable 'a' is not referenced in the preceding example and so will cause a warning to be generated.&nbsp; Following
the warning, the informational message indicates the line at which 'a' was declared.
<H2 ID="393_included_from__sL_uR"> 393 included from %s(%u) </H2>
<BR>This informational message indicates the line number of the file including the file in which an error or warning was diagnosed.
&nbsp;A number of such messages will allow you to trace back through the<B><I> #include</I></B> directives which are currently
being processed.
<H2 ID="394_reference_object_must_be_initialized"> 394 reference object must be initialized </H2>
<BR>A reference cannot be set except through initialization.&nbsp; Also references cannot be 0 so they must always be initialized.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp; ref;</TT>
<H2 ID="395_option_requires_an_identifier"> 395 option requires an identifier </H2>
<BR>The specified option is not recognized by the compiler since there was no identifier after it (i.e., &quot;-nt=module&quot;
).
<H2 ID="396__main__cannot_be_overloaded"> 396 'main' cannot be overloaded </H2>
<BR>There can only be one entry point for a C++ program.&nbsp; The &quot;main&quot; function cannot be overloaded.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main( int );</TT>
<H2 ID="397__new__expression_cannot_allocate_a_void"> 397 'new' expression cannot allocate a void </H2>
<BR>Since the<B><I> void</I></B> type has no size and there are no values of<B><I> void</I></B> type, one cannot allocate
an instance of<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *p = new void;</TT>
<H2 ID="398__new__expression_cannot_allocate_a_function"> 398 'new' expression cannot allocate a function </H2>
<BR>A function type cannot be allocated since there is no meaningful size that can be used.&nbsp; The<B><I> new</I></B> expression
can allocate a pointer to a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int tdfun( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tdfun *tdv = new tdfun;</TT>
<H2 ID="399__new__expression_allocates_a_const_or_volatile_object"> 399 'new' expression allocates a const or volatile object </H2>
<BR>The pool of raw memory cannot be guaranteed to support<B><I> const</I></B> or<B><I> volatile</I></B> semantics.&nbsp;
Usually<B><I> const</I></B> and<B><I> volatile</I></B> are used for statically allocated objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef const int con_int;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; con_int* p = new con_int;</TT>
<H2 ID="400_cannot_convert_right_expression_for_initialization"> 400 cannot convert right expression for initialization </H2>
<BR>The initialization is trying to convert an argument expression to a completely unrelated type.&nbsp; There is no way the
compiler can provide any meaning for the intended conversion.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; T x = 0;</TT>
<H2 ID="401_conversion_ambiguity__Uinitialization_expressionV_to_Utype_of_objectV"> 401 conversion ambiguity:&nbsp; [initialization expression] to [type of object] </H2>
<BR>The initialization caused a constructor overload to occur.&nbsp; The operands provided for the constructor did not select
a unique constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S x = 1.0;</TT>
<H2 ID="402_class_template___S__has_already_been_declared_as_a_friend"> 402 class template '%S' has already been declared as a friend </H2>
<BR>The class template in the message has already been declared as a friend.&nbsp; Remove the extra friend declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class S;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="403_private_base_class_accessed_to_convert_initialization_expression"> 403 private base class accessed to convert initialization expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<H2 ID="404_protected_base_class_accessed_to_convert_initialization_expression"> 404 protected base class accessed to convert initialization expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<H2 ID="405_cannot_return_a_pointer_or_reference_to_a_constant_object"> 405 cannot return a pointer or reference to a constant object </H2>
<BR>A pointer or reference to a constant object cannot be returned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *foo( const int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="406_cannot_pass_a_pointer_or_reference_to_a_constant_object"> 406 cannot pass a pointer or reference to a constant object </H2>
<BR>A pointer or reference to a constant object could not be passed as an argument.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *bar( int * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *foo( const int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bar( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="407_class_templates_must_be_named"> 407 class templates must be named </H2>
<BR>There is no syntax in the C++ language to reference an unnamed class template.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="408_function_templates_can_only_name_functions"> 408 function templates can only name functions </H2>
<BR>Variables cannot be overloaded in C++ so it is not possible to have many different instances of a variable with different
types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T x[1];</TT>
<H2 ID="409_template_argument___S__is_not_used_in_the_function_argument_list"> 409 template argument '%S' is not used in the function argument list </H2>
<BR>This restriction ensures that function templates can be bound to types during overload resolution.&nbsp; Functions currently
can only be overloaded based on argument types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo( int * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T bar( int * );</TT>
<H2 ID="410_destructor_cannot_be_declared_const_or_volatile"> 410 destructor cannot be declared const or volatile </H2>
<BR>A destructor must be able to operate on all instances of classes regardless of whether they are<B><I> const</I></B> or<B><I>
volatile.</I></B>&nbsp; 
<H2 ID="411_static_member_function_cannot_be_declared_const_or_volatile"> 411 static member function cannot be declared const or volatile </H2>
<BR>A static member function does not have an implicit<B><I> this</I></B> argument so the<B><I> const</I></B> and<B><I> volatile</I></B>
function qualifiers cannot be used.
<H2 ID="412_only_member_functions_can_be_declared_const_or_volatile"> 412 only member functions can be declared const or volatile </H2>
<BR>A non-member function does not have an implicit<B><I> this</I></B> argument so the<B><I> const</I></B> and<B><I> volatile</I></B>
function qualifiers cannot be used.
<H2 ID="413__const__or__volatile__modifiers_are_not_part_of_a_function_s_type"> 413 'const' or 'volatile' modifiers are not part of a function's type </H2>
<BR>The<B><I> const</I></B> and<B><I> volatile</I></B> qualifiers for a function cannot be used in typedefs or pointers to
functions.&nbsp; The trailing qualifiers are used to change the type of the implicit<B><I> this</I></B> argument so that member
functions that do not modify the object can be declared accurately.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // const is illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (*baddcl)() const;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fun() const;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // &quot;this&quot; has type &quot;S const *&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void S::fun() const</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;a = 1;&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="414_type_cannot_be_defined_in_an_argument"> 414 type cannot be defined in an argument </H2>
<BR>A new type cannot be defined in an argument because the type will only be visible within the function.&nbsp; This amounts
to defining a function that can never be called because C++ uses name equivalence for type checking.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern foo( struct S { int s; } );</TT>
<H2 ID="415_type_cannot_be_defined_in_return_type"> 415 type cannot be defined in return type </H2>
<BR>This is a restriction in the current C++ language.&nbsp; A function prototype should only use previously declared types
in order to guarantee that it can be called from other functions.&nbsp; The restriction is required for templates because
the compiler would have to wait until the end of a class definition before it could decide whether a class template or function
template is being defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } fn( T x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y.x = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>A common problem that results in this error is to forget to terminate a class or enum definition with a semicolon.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } // missing semicolon ';'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::S( int x, int y ) : x(x), y(y) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="416_data_members_cannot_be_initialized_inside_a_class_definition"> 416 data members cannot be initialized inside a class definition </H2>
<BR>This message appears when an initialization is attempted inside of a class definition.&nbsp; In the case of static data
members, initialization must be done outside the class definition.&nbsp; Ordinary data members can be initialized in a constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static const int size = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="417_only_virtual_functions_may_be_declared_pure"> 417 only virtual functions may be declared pure </H2>
<BR>The C++ language requires that all pure functions be declared virtual.&nbsp; A pure function establishes an interface
that must consist of virtual functions because the functions are required to be defined in the derived class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo() = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="418_destructor_is_not_declared_in_its_proper_class"> 418 destructor is not declared in its proper class </H2>
<BR>The destructor name is not declared in its own class or qualified by its own class.&nbsp; This is required in the C++
language.
<H2 ID="419_cannot_call_nonMconst_function_for_a_constant_object"> 419 cannot call non-const function for a constant object </H2>
<BR>A function that does not promise to not modify an object cannot be called for a constant object.&nbsp; A function can
declare its intention to not modify an object by using the<B><I> const</I></B> qualifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void cfn( const S *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;fn();&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="420_memory_initializer_list_may_only_appear_in_a_constructor_definition"> 420 memory initializer list may only appear in a constructor definition </H2>
<BR>A memory initializer list should be declared along with the body of the constructor function.
<H2 ID="421_cannot_initialize_member___N__twice"> 421 cannot initialize member '%N' twice </H2>
<BR>A member cannot be initialized twice in a member initialization list.
<H2 ID="422_cannot_initialize_base_class___T__twice"> 422 cannot initialize base class '%T' twice </H2>
<BR>A base class cannot be constructed twice in a member initialization list.
<H2 ID="423___T__is_not_a_direct_base_class"> 423 '%T' is not a direct base class </H2>
<BR>A base class initializer in a member initialization list must either be a direct base class or a virtual base class.
<H2 ID="424___N__cannot_be_initialized_because_it_is_not_a_member"> 424 '%N' cannot be initialized because it is not a member </H2>
<BR>The name used in the member initialization list does not name a member in the class.
<H2 ID="425___N__cannot_be_initialized_because_it_is_a_member_function"> 425 '%N' cannot be initialized because it is a member function </H2>
<BR>The name used in the member initialization list does not name a non-static data member in the class.
<H2 ID="426___N__cannot_be_initialized_because_it_is_a_static_member"> 426 '%N' cannot be initialized because it is a static member </H2>
<BR>The name used in the member initialization list does not name a non-static data member in the class.
<H2 ID="427___N__has_not_been_declared_as_a_member"> 427 '%N' has not been declared as a member </H2>
<BR>This message indicates that the member does not exist in the qualified class.&nbsp; This usually occurs in the context
of access declarations.
<H2 ID="428_constDreference_member___S__must_have_an_initializer"> 428 const/reference member '%S' must have an initializer </H2>
<BR>The<B><I> const</I></B> or reference member does not have an initializer so the constructor is not completely defined.
&nbsp;The member initialization list is the only way to initialize these types of members.
<H2 ID="429_abstract_class___T__cannot_be_used_as_an_argument_type"> 429 abstract class '%T' cannot be used as an argument type </H2>
<BR>An abstract class can only exist as a base class of another class.&nbsp; The C++ language does not allow an abstract class
to be used as an argument type.
<H2 ID="430_abstract_class___T__cannot_be_used_as_a_function_return_type"> 430 abstract class '%T' cannot be used as a function return type </H2>
<BR>An abstract class can only exist as a base class of another class.&nbsp; The C++ language does not allow an abstract class
to be used as a return type.
<H2 ID="431_defining___S__is_not_possible_because___T__is_an_abstract_class"> 431 defining '%S' is not possible because '%T' is an abstract class </H2>
<BR>An abstract class can only exist as a base class of another class.&nbsp; The C++ language does not allow an abstract class
to be used as either a member or a variable.
<H2 ID="432_cannot_convert_to_an_abstract_class___T_"> 432 cannot convert to an abstract class '%T' </H2>
<BR>An abstract class can only exist as a base class of another class.&nbsp; The C++ language does not allow an abstract class
to be used as the destination type in a conversion.
<H2 ID="433_mangled_name_for___S__has_been_truncated"> 433 mangled name for '%S' has been truncated </H2>
<BR>The name used in the object file that encodes the name and full type of the symbol is often called a mangled name.&nbsp;
The warning indicates that the mangled name had to be truncated due to limitations in the object file format.
<H2 ID="434_cannot_convert_to_a_type_of_unknown_size"> 434 cannot convert to a type of unknown size </H2>
<BR>A completely unknown type cannot be used in a conversion because its size is not known.&nbsp; The behaviour of the conversion
would be undefined also.
<H2 ID="435_cannot_convert_a_type_of_unknown_size"> 435 cannot convert a type of unknown size </H2>
<BR>A completely unknown type cannot be used in a conversion because its size is not known.&nbsp; The behaviour of the conversion
would be undefined also.
<H2 ID="436_cannot_construct_an_abstract_class"> 436 cannot construct an abstract class </H2>
<BR>An instance of an abstract class cannot be created because an abstract class can only be used as a base class.
<H2 ID="437_cannot_construct_an_undefined_class"> 437 cannot construct an undefined class </H2>
<BR>An instance of an undefined class cannot be created because the size is not known.
<H2 ID="438_string_literal_concatenated_during_array_initialization"> 438 string literal concatenated during array initialization </H2>
<BR>This message indicates that a missing comma (',') could have made a quiet change in the program.&nbsp; Otherwise, ignore
this message.
<H2 ID="439_maximum_size_of_segment___s__has_been_exceeded_for___S_"> 439 maximum size of segment '%s' has been exceeded for '%S' </H2>
<BR>The indicated symbol has grown in size to a point where it has caused the segment it is defined inside of to be exhausted.
<H2 ID="440_maximum_data_item_size_has_been_exceeded_for___S_"> 440 maximum data item size has been exceeded for '%S' </H2>
<BR>A non-huge data item is larger than 64k bytes in size.&nbsp; This message only occurs during 16-bit compilation of C++
code.
<H2 ID="441_function_attribute_has_been_repeated"> 441 function attribute has been repeated </H2>
<BR>A function attribute (like the<B><I> __export</I></B> attribute) has been repeated.&nbsp; Remove the extra attribute to
correct the declaration.
<H2 ID="442_modifier_has_been_repeated"> 442 modifier has been repeated </H2>
<BR>A modifier (like the<B><I> far</I></B> modifier) has been repeated.&nbsp; Remove the extra modifier to correct the declaration.
<H2 ID="443_illegal_combination_of_memory_model_modifiers"> 443 illegal combination of memory model modifiers </H2>
<BR>Memory model modifiers must be used individually because they cannot be combined meaningfully.
<H2 ID="444_argument_name___N__has_already_been_used"> 444 argument name '%N' has already been used </H2>
<BR>The indicated argument name has already been used in the same argument list.&nbsp; This is not allowed in the C++ language.
<H2 ID="445_function_definition_for___S__must_be_declared_with_an_explicit_argument_list"> 445 function definition for '%S' must be declared with an explicit argument list </H2>
<BR>A function cannot be defined with a typedef.&nbsp; The argument list must be explicit.
<H2 ID="446_userMdefined_conversion_cannot_convert_to_its_own_class_or_base_class"> 446 user-defined conversion cannot convert to its own class or base class </H2>
<BR>A user-defined conversion cannot be declared as a conversion either to its own class or to a base class of itself.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : private B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator B();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="447_userMdefined_conversion_cannot_convert_to_void"> 447 user-defined conversion cannot convert to void </H2>
<BR>A user-defined conversion cannot be declared as a conversion to<B><I> void.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator void();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="448_expecting_identifier"> 448 expecting identifier </H2>
<BR>An identifier was expected during processing.
<H2 ID="449_symbol___S__does_not_have_a_segment_associated_with_it"> 449 symbol '%S' does not have a segment associated with it </H2>
<BR>A pointer cannot be based on a member because it has no segment associated with it.&nbsp; A member describes a layout
of storage that can occur in any segment.
<H2 ID="450_symbol___S__must_have_integral_or_pointer_type"> 450 symbol '%S' must have integral or pointer type </H2>
<BR>If a symbol is based on another symbol, it must be integral or a pointer type.&nbsp; An integral type indicates the segment
value that will be used.&nbsp; A pointer type means that all accesses will be added to the pointer value to construct a full
pointer.
<H2 ID="451_symbol___S__cannot_be_accessed_in_all_contexts"> 451 symbol '%S' cannot be accessed in all contexts </H2>
<BR>The symbol that the pointer is based on is in another class so it cannot be accessed in all contexts that the based pointer
can be accessed.
<H2 ID="452_cannot_convert_class_expression_to_be_copied"> 452 cannot convert class expression to be copied </H2>
<BR>A convert class expression could not be copied.
<H2 ID="453_conversion_ambiguity__multiple_copy_constructors"> 453 conversion ambiguity:&nbsp; multiple copy constructors </H2>
<BR>More than one constructor could be used to copy a class object.
<H2 ID="454_function_template___S__already_has_a_definition"> 454 function template '%S' already has a definition </H2>
<BR>The function template has already been defined with a function body.&nbsp; A function template cannot be defined twice
even if the function body is identical.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f( T *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f( T *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="455_function_templates_cannot_have_default_arguments"> 455 function templates cannot have default arguments </H2>
<BR>A function template must not have default arguments because there are certain types of default arguments that do not force
the function argument to be a specific type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f2( T *p = 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="456__main__cannot_be_a_function_template"> 456 'main' cannot be a function template </H2>
<BR>This is a restriction in the C++ language because &quot;main&quot; cannot be overloaded.&nbsp; A function template provides
the possibility of having more than one &quot;main&quot; function.
<H2 ID="457___S__was_previously_declared_as_a_typedef"> 457 '%S' was previously declared as a typedef </H2>
<BR>The C++ language only allows function and variable names to coexist with names of classes or enumerations.&nbsp; This
is due to the fact that the class and enumeration names can still be referenced in their elaborated form after the non-type
name has been declared.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int T( int )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E { A, B, C };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void E()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum E x = A;&nbsp;&nbsp; // use &quot;enum E&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void C()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class C x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use &quot;class C&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="458___S__was_previously_declared_as_a_variableDfunction"> 458 '%S' was previously declared as a variable/function </H2>
<BR>The C++ language only allows function and variable names to coexist with names of classes or enumerations.&nbsp; This
is due to the fact that the class and enumeration names can still be referenced in their elaborated form after the non-type
name has been declared.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int T( int )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int T;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error!</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void E()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E { A, B, C };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum E x = A;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use &quot;enum E&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void C()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use &quot;class C&quot;</TT>
<H2 ID="459_private_base_class_accessed_to_convert_assignment_expression"> 459 private base class accessed to convert assignment expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a private base class.&nbsp; The access check did not
succeed so the conversion is not allowed.
<H2 ID="460_protected_base_class_accessed_to_convert_assignment_expression"> 460 protected base class accessed to convert assignment expression </H2>
<BR>A conversion involving the inheritance hierarchy required access to a protected base class.&nbsp; The access check did
not succeed so the conversion is not allowed.
<H2 ID="461_maximum_size_of_DGROUP_has_been_exceeded_for___S__in_segment___s_"> 461 maximum size of DGROUP has been exceeded for '%S' in segment '%s' </H2>
<BR>The indicated symbol's size has caused the DGROUP contribution of this module to exceed 64k.&nbsp; Changing memory models
or declaring some data as<B><I> far</I></B> data are two ways of fixing this problem.
<H2 ID="462_type_of_return_value_is_not_the_enumeration_type_of_function"> 462 type of return value is not the enumeration type of function </H2>
<BR>The return value does not have the proper enumeration type.&nbsp; Keep in mind that integral values are not automatically
converted to enum types like the C language.
<H2 ID="463_linkage_must_be_first_in_a_declarationS_probable_cause__missing__S_"> 463 linkage must be first in a declaration; probable cause:&nbsp; missing ';' </H2>
<BR>This message usually indicates a missing semicolon (';').&nbsp; The linkage specification must be the first part of a
declaration if it is used.
<H2 ID="464__main__cannot_be_a_static_function"> 464 'main' cannot be a static function </H2>
<BR>This is a restriction in the C++ language because &quot;main&quot; must have external linkage.
<H2 ID="465__main__cannot_be_an_inline_function"> 465 'main' cannot be an inline function </H2>
<BR>This is a restriction in the C++ language because &quot;main&quot; must have external linkage.
<H2 ID="466__main__cannot_be_referenced"> 466 'main' cannot be referenced </H2>
<BR>This is a restriction in the C++ language to prevent implementations from having to work around multiple invocations of
&quot;main&quot;.&nbsp; This can occur if an implementation has to generate special code in &quot;main&quot; to construct
all of the statically allocated classes.
<H2 ID="467_cannot_call_a_nonMvolatile_function_for_a_volatile_object"> 467 cannot call a non-volatile function for a volatile object </H2>
<BR>A function that does not promise to not modify an object using<B><I> volatile</I></B> semantics cannot be called for a
volatile object.&nbsp; A function can declare its intention to modify an object only through<B><I> volatile</I></B> semantics
by using the<B><I> volatile</I></B> qualifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void cfn( volatile S *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;fn();&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="468_cannot_convert_pointer_to_constant_or_volatile_objects_to_pointer_to_void"> 468 cannot convert pointer to constant or volatile objects to pointer to void </H2>
<BR>You cannot convert a pointer to constant or volatile objects to 'void*'.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int* pci;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void *vp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ( pci == vp );</TT>
<H2 ID="469_cannot_convert_pointer_to_constant_or_nonMvolatile_objects_to_pointer_to_volatile_void"> 469 cannot convert pointer to constant or non-volatile objects to pointer to volatile void </H2>
<BR>You cannot convert a pointer to constant or non-volatile objects to 'volatile void*'.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int* pci;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern volatile void *vp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ( pci == vp );</TT>
<H2 ID="470_address_of_function_is_too_large_to_be_converted_to_pointer_to_void"> 470 address of function is too large to be converted to pointer to void </H2>
<BR>The address of a function can be converted to 'void*' only when the size of a 'void*' object is large enough to contain
the function pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __far foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __near *v = &amp;foo;</TT>
<H2 ID="471_address_of_data_object_is_too_large_to_be_converted_to_pointer_to_void"> 471 address of data object is too large to be converted to pointer to void </H2>
<BR>The address of an object can be converted to 'void*' only when the size of a 'void*' object is large enough to contain
the pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far *ip;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __near *v = ip;</TT>
<H2 ID="472_expression_with_side_effect_in_sizeof_discarded"> 472 expression with side effect in sizeof discarded </H2>
<BR>The indicated expression will be discarded; consequently, any side effects in that expression will not be executed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int a = 14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int b = sizeof( a++ );</TT>
<BR><BR>In the example, the variable<TT> a</TT> will still have a value 14 after<TT> b</TT> has been initialized.
<H2 ID="473_function_argumentLsR_do_not_match_those_in_prototype"> 473 function argument(s) do not match those in prototype </H2>
<BR>The C++ language requires great precision in specifying arguments for a function.&nbsp; For instance, a pointer to<TT>
char</TT> is considered different than a pointer to<TT> unsigned char</TT> regardless of whether<TT> char</TT> is an unsigned
quantity.&nbsp; This message occurs when a non-overloaded function is invoked and one or more of the arguments cannot be converted.
&nbsp;It also occurs when the number of arguments differs from the number specified in the prototype.
<H2 ID="474_conversion_ambiguity__UexpressionV_to_Uclass_objectV"> 474 conversion ambiguity:&nbsp; [expression] to [class object] </H2>
<BR>The conversion of the expression to a class object is ambiguous.
<H2 ID="475_cannot_assign_right_expression_to_class_object"> 475 cannot assign right expression to class object </H2>
<BR>The expression on the right cannot be assigned to the indicated class object.
<H2 ID="476_argument_count_is__d_since_there_is_an_implicit__this__argument"> 476 argument count is %d since there is an implicit 'this' argument </H2>
<BR>This informational message indicates the number of arguments for the function mentioned in the error message.&nbsp; The
function is a member function with a<B><I> this</I></B> argument so it may have one more argument than expected.
<H2 ID="477_argument_count_is__d_since_there_is_no_implicit__this__argument"> 477 argument count is %d since there is no implicit 'this' argument </H2>
<BR>This informational message indicates the number of arguments for the function mentioned in the error message.&nbsp; The
function is a member function without a<B><I> this</I></B> argument so it may have one less argument than expected.
<H2 ID="478_argument_count_is__d_for_a_nonMmember_function"> 478 argument count is %d for a non-member function </H2>
<BR>This informational message indicates the number of arguments for the function mentioned in the error message.&nbsp; The
function is not a member function but it could be declared as a<B><I> friend</I></B> function.
<H2 ID="479_conversion_ambiguity__multiple_copy_constructors_to_copy_array___S_"> 479 conversion ambiguity:&nbsp; multiple copy constructors to copy array '%S' </H2>
<BR>More than one constructor to copy the indicated array exists.
<H2 ID="480_variableDfunction_has_the_same_name_as_the_classDenum___S_"> 480 variable/function has the same name as the class/enum '%S' </H2>
<BR>In C++, a class or enum name can coexist with a variable or function of the same name in a scope.&nbsp; This warning is
indicating that the current declaration is making use of this feature but the typedef name was declared in another file.&nbsp;
This usually means that there are two unrelated uses of the same name.
<H2 ID="481_classDenum_has_the_same_name_as_the_functionDvariable___S_"> 481 class/enum has the same name as the function/variable '%S' </H2>
<BR>In C++, a class or enum name can coexist with a variable or function of the same name in a scope.&nbsp; This warning is
indicating that the current declaration is making use of this feature but the function/variable name was declared in another
file.&nbsp; This usually means that there are two unrelated uses of the same name.&nbsp; Furthermore, all references to the
class or enum must be elaborated (i.e., use 'class C' instead of 'C') in order for subsequent references to compile properly.
<H2 ID="482_cannot_create_a_default_constructor"> 482 cannot create a default constructor </H2>
<BR>A default constructor could not be created, because other constructors were declared for the class in question.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X(X&amp;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Y {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X a[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Y yvar;</TT>
<BR><BR>In the example, the variable &quot;yvar&quot; causes a default constructor for the class &quot;Y&quot; to be generated.
&nbsp;The default constructor for &quot;Y&quot; attempts to call the default constructor for &quot;X&quot; in order to initialize
the array &quot;a&quot; in class &quot;Y&quot;.&nbsp; The default constructor for &quot;X&quot; cannot be defined because
another constructor has been declared.
<H2 ID="483_attempting_to_access_default_constructor_for__T"> 483 attempting to access default constructor for %T </H2>
<BR>This informational message indicates that a default constructor was referenced but could not be generated.
<H2 ID="484_cannot_align_symbol___S__to_segment_boundary"> 484 cannot align symbol '%S' to segment boundary </H2>
<BR>The indicated symbol requires more than one segment of storage and the symbol's components cannot be aligned to the segment
boundary.
<H2 ID="485_friend_declaration_does_not_specify_a_class_or_function"> 485 friend declaration does not specify a class or function </H2>
<BR>A class or function must be declared as a friend.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // should be class or function declaration</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; friend int;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="486_cannot_take_address_of_overloaded_function"> 486 cannot take address of overloaded function </H2>
<BR>This message indicates that an overloaded function's name was used in a context where a final type could not be found.
&nbsp;Because a final type was not specified, the compiler cannot select one function to use in the expression.&nbsp; Initialize
a properly-typed temporary with the appropriate function and use the temporary in the expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int (*p)( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ( p == &amp;foo );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fails</TT>
<BR><BR>The first<TT> foo</TT> can be passed as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int (*p)( char );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // introduce temporary</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int (*temp)( char ) = &amp;foo;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ( p == temp );</TT>
<H2 ID="487_cannot_use_address_of_overloaded_function_as_a_variable_argument"> 487 cannot use address of overloaded function as a variable argument </H2>
<BR>This message indicates that an overloaded function's name was used as a argument for a &quot;...&quot; style function.
&nbsp;Because a final function type is not present, the compiler cannot select one function to use in the expression.&nbsp;
Initialize a properly-typed temporary with the appropriate function and use the temporary in the call.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ellip_fun( int, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ellip_fun( 14, &amp;foo );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fails</TT>
<BR><BR>The first<TT> foo</TT> can be passed as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ellip_fun( int, ... );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int (*temp)( char ) = &amp;foo;&nbsp; // introduce temporary</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = ellip_fun( 14, temp );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<H2 ID="488___N__cannot_be_overloaded"> 488 '%N' cannot be overloaded </H2>
<BR>The indicated function cannot be overloaded.&nbsp; Functions that fall into this category include<B><I> operator delete.</I></B>
&nbsp;
<H2 ID="489_symbol___S__has_already_been_initialized"> 489 symbol '%S' has already been initialized </H2>
<BR>The indicated symbol has already been initialized.&nbsp; It cannot be initialized twice even if the initialization value
is identical.
<H2 ID="490_delete_expression_is_a_pointer_to_a_function"> 490 delete expression is a pointer to a function </H2>
<BR>A pointer to a function cannot be allocated so it cannot be deleted.
<H2 ID="491_delete_of_a_pointer_to_const_data"> 491 delete of a pointer to const data </H2>
<BR>Since deleting a pointer may involve modification of data, it is not always safe to delete a pointer to const data.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( S const *p, S const *q ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="492_delete_expression_is_not_a_pointer_to_data"> 492 delete expression is not a pointer to data </H2>
<BR>A<B><I> delete</I></B> expression can only delete pointers.&nbsp; For example, trying to delete an<B><I> int</I></B> is
not allowed in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete a;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="493_template_argument_is_not_a_constant_expression"> 493 template argument is not a constant expression </H2>
<BR>The compiler has found an incorrect expression provided as the value for a constant value template argument.&nbsp; The
only expressions allowed for scalar template arguments are integral constant expressions.
<H2 ID="494_template_argument_is_not_an_external_linkage_symbol"> 494 template argument is not an external linkage symbol </H2>
<BR>The compiler has found an incorrect expression provided as the value for a pointer value template argument.&nbsp; The
only expressions allowed for pointer template arguments are addresses of symbols.&nbsp; Any symbols must have external linkage
or must be static class members.
<H2 ID="495_conversion_of_const_reference_to_volatile_reference"> 495 conversion of const reference to volatile reference </H2>
<BR>The constant value can be modified by assigning into the volatile reference.&nbsp; This would allow constant data to be
modified quietly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( const int &amp;rci )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int volatile &amp;r = rci;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="496_conversion_of_volatile_reference_to_const_reference"> 496 conversion of volatile reference to const reference </H2>
<BR>The volatile value can be read incorrectly by accessing the const reference.&nbsp; This would allow volatile data to be
accessed without correct volatile semantics.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( volatile int &amp;rvi )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int const &amp;r = rvi; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="497_conversion_of_const_or_volatile_reference_to_plain_reference"> 497 conversion of const or volatile reference to plain reference </H2>
<BR>The constant value can be modified by assigning into the plain reference.&nbsp; This would allow constant data to be modified
quietly.&nbsp; In the case of volatile data, any access to the plain reference will not respect the volatility of the data
and thus would be incorrectly accessing the data.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( const int &amp;rci, volatile int &amp;rvi )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int &amp;r1 = rci;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int &amp;r2 = rvi;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="498_syntax_error_before___s_S_probable_cause__incorrectly_spelled_type_name"> 498 syntax error before '%s'; probable cause:&nbsp; incorrectly spelled type name </H2>
<BR>The identifier in the error message has not been declared as a type name in any scope at this point in the code.&nbsp;
This may be the cause of the syntax error.
<H2 ID="499_object_Lor_object_pointerR_required_to_access_nonMstatic_member_function"> 499 object (or object pointer) required to access non-static member function </H2>
<BR>A reference to a member function in a class has occurred.&nbsp; The member is non-static so in order to access it, an
object of the class is required.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m();&nbsp;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="500_object_Lor_object_pointerR_cannot_be_used_to_access_function"> 500 object (or object pointer) cannot be used to access function </H2>
<BR>The indicated object (or object pointer) cannot be used to access function.
<H2 ID="501_object_Lor_object_pointerR_cannot_be_used_to_access_data"> 501 object (or object pointer) cannot be used to access data </H2>
<BR>The indicated object (or object pointer) cannot be used to access data.
<H2 ID="502_cannot_access_member_function_in_enclosing_class"> 502 cannot access member function in enclosing class </H2>
<BR>A member function in enclosing class cannot be accessed.
<H2 ID="503_cannot_access_data_member_in_enclosing_class"> 503 cannot access data member in enclosing class </H2>
<BR>A data member in enclosing class cannot be accessed.
<H2 ID="504_syntax_error_before_type_name___s_"> 504 syntax error before type name '%s' </H2>
<BR>The identifier in the error message has been declared as a type name at this point in the code.&nbsp; This may be the
cause of the syntax error.
<H2 ID="505_implementation_restriction__cannot_generate_thunk_from___S_"> 505 implementation restriction:&nbsp; cannot generate thunk from '%S' </H2>
<BR>This implementation restriction is due to the use of a shared code generator between Open Watcom compilers.&nbsp; The
virtual<B><I> this</I></B> adjustment thunks are generated as functions linked into the virtual function table.&nbsp; The
functions rely on knowing the correct number of arguments to pass on to the overriding virtual function but in the case of
ellipsis (...) functions, the number of arguments cannot be known when the thunk function is being generated by the compiler.
&nbsp;The target symbol is listed in a diagnostic message.&nbsp; The work around for this problem is to recode the source
so that the virtual functions make use of the va_list type found in the stdarg header file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void fun( char *, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void fun( char *, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void B::fun( char *f, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, f );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( *f ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; va_arg( args, char ) &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void D::fun( char *f, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, f );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( *f ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; va_arg( args, int ) &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The previous example can be changed to the following code with corresponding changes to the contents of the virtual
functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fun( char *f, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, f );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fun( f, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void _fun( char *, va_list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ~b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this can be removed since using B::fun</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will result in the same behaviour</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // since _fun is a virtual function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fun( char *f, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, f );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fun( f, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void _fun( char *, va_list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ~b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void B::_fun( char *f, va_list args )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( *f ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; va_arg( args, char ) &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ~b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void D::_fun( char *f, va_list args )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( *f ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; va_arg( args, int ) &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ~b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // no changes are required for users of the class</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void dump( B *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;fun( &quot;1234&quot;, 'a', 'b', 'c', 'd' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;fun( &quot;12&quot;, 'a', 'b' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ~b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dump( &amp;x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dump( &amp;y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="506_conversion_of___basedL_void_R_pointer_to_virtual_base_class"> 506 conversion of __based( void ) pointer to virtual base class </H2>
<BR>An __based(void) pointer to a class object cannot be converted to a pointer to virtual base class, since this conversion
applies only to specific objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : virtual Base {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived __based( void ) *p_derived;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Base __based( void ) *p_base = p_derived; // error</TT>
<BR><BR>The conversion would be allowed if the base class were not virtual.
<H2 ID="507_class_for_target_operand_is_not_derived_from_class_for_source_operand"> 507 class for target operand is not derived from class for source operand </H2>
<BR>A member pointer conversion can only be performed safely when converting a base class member pointer to a derived class
member pointer.
<H2 ID="508_conversion_ambiguity__Upointer_to_class_memberV_to_Uassignment_objectV"> 508 conversion ambiguity:&nbsp; [pointer to class member] to [assignment object] </H2>
<BR>The base class in the original member pointer is not a unique base class of the derived class.
<H2 ID="509_conversion_of_pointer_to_class_member_involves_a_private_base_class"> 509 conversion of pointer to class member involves a private base class </H2>
<BR>The member pointer conversion required access to a private base class.&nbsp; The access check did not succeed so the conversion
is not allowed.
<H2 ID="510_conversion_of_pointer_to_class_member_involves_a_protected_base_class"> 510 conversion of pointer to class member involves a protected base class </H2>
<BR>The member pointer conversion required access to a protected base class.&nbsp; The access check did not succeed so the
conversion is not allowed.
<H2 ID="511_item_is_neither_a_nonMstatic_member_function_nor_data_member"> 511 item is neither a non-static member function nor data member </H2>
<BR>A member pointer can only be created for non-static member functions and non-static data members.&nbsp; Static members
can have their address taken just like their file scope counterparts.
<H2 ID="512_function_address_cannot_be_converted_to_pointer_to_class_member"> 512 function address cannot be converted to pointer to class member </H2>
<BR>The indicated function address cannot be converted to pointer to class member.
<H2 ID="513_conversion_ambiguity__Uaddress_of_functionV_to_Upointer_to_class_memberV"> 513 conversion ambiguity:&nbsp; [address of function] to [pointer to class member] </H2>
<BR>The indicated conversion is ambiguous.
<H2 ID="514_addressed_function_is_in_a_private_base_class"> 514 addressed function is in a private base class </H2>
<BR>The addressed function is in a private base class.
<H2 ID="515_addressed_function_is_in_a_protected_base_class"> 515 addressed function is in a protected base class </H2>
<BR>The addressed function is in a protected base class.
<H2 ID="516_class_for_object_is_not_defined"> 516 class for object is not defined </H2>
<BR>The left hand operand for the &quot;.&quot; or &quot;.*&quot; operator must be of a class type that is completely defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fun( C&amp; x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x.y;&nbsp;&nbsp;&nbsp;&nbsp; // class C not defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="517_left_expression_is_not_a_class_object"> 517 left expression is not a class object </H2>
<BR>The left hand operand for the &quot;.*&quot; operator must be of a class type since member pointers can only be used with
classes.
<H2 ID="518_right_expression_is_not_a_pointer_to_class_member"> 518 right expression is not a pointer to class member </H2>
<BR>The right hand operand for the &quot;.*&quot; operator must be a member pointer type.
<H2 ID="519_cannot_convert_pointer_to_class_of_member_pointer"> 519 cannot convert pointer to class of member pointer </H2>
<BR>The class of the left hand operand cannot be converted to the class of the member pointer because it is not a derived
class.
<H2 ID="520_conversion_ambiguity__UpointerV_to_Uclass_of_pointer_to_class_memberV"> 520 conversion ambiguity:&nbsp; [pointer] to [class of pointer to class member] </H2>
<BR>The class of the pointer to member is an ambiguous base class of the left hand operand.
<H2 ID="521_conversion_of_pointer_to_class_of_member_pointer_involves_a_private_base_class"> 521 conversion of pointer to class of member pointer involves a private base class </H2>
<BR>The class of the pointer to member is a private base class of the left hand operand.
<H2 ID="522_conversion_of_pointer_to_class_of_member_pointer_involves_a_protected_base_class"> 522 conversion of pointer to class of member pointer involves a protected base class </H2>
<BR>The class of the pointer to member is a protected base class of the left hand operand.
<H2 ID="523_cannot_convert_object_to_class_of_member_pointer"> 523 cannot convert object to class of member pointer </H2>
<BR>The class of the left hand operand cannot be converted to the class of the member pointer because it is not a derived
class.
<H2 ID="524_conversion_ambiguity__UobjectV_to_Uclass_object_of_pointer_to_class_memberV"> 524 conversion ambiguity:&nbsp; [object] to [class object of pointer to class member] </H2>
<BR>The class of the pointer to member is an ambiguous base class of the left hand operand.
<H2 ID="525_conversion_of_object_to_class_of_member_pointer_involves_a_private_base_class"> 525 conversion of object to class of member pointer involves a private base class </H2>
<BR>The class of the pointer to member is a private base class of the left hand operand.
<H2 ID="526_conversion_of_object_to_class_of_member_pointer_involves_a_protected_base_class"> 526 conversion of object to class of member pointer involves a protected base class </H2>
<BR>The class of the pointer to member is a protected base class of the left hand operand.
<H2 ID="527_conversion_of_pointer_to_class_member_from_a_derived_to_a_base_class"> 527 conversion of pointer to class member from a derived to a base class </H2>
<BR>A member pointer can only be converted from a base class to a derived class.&nbsp; This is the opposite of the conversion
rule for pointers.
<H2 ID="528_form_is___pragma_inline_recursion_en__where__en__is__on__or__off_"> 528 form is '#pragma inline_recursion en' where 'en' is 'on' or 'off' </H2>
<BR>This<B><I> pragma</I></B> indicates whether inline expansion will occur for an inline function which is called (possibly
indirectly) a subsequent time during an inline expansion.&nbsp; Either 'on' or 'off' must be specified.
<H2 ID="529_expression_for_number_of_array_elements_must_be_integral"> 529 expression for number of array elements must be integral </H2>
<BR>The expression for the number of elements in a<B><I> new</I></B> expression must be integral because it is used to calculate
the size of the allocation (which is an integral quantity).&nbsp; The compiler will not automatically convert to an integer
because of rounding and truncation issues with floating-point values.
<H2 ID="530_function_accessed_with___T__or__MYT__can_only_be_called"> 530 function accessed with '.*' or '-&gt;*' can only be called </H2>
<BR>The result of the &quot;.*&quot; and &quot;-&gt;*&quot; operators can only be called because it is often specific to the
instance used for the left hand operand.
<H2 ID="531_left_operand_must_be_a_pointer__pointer_to_class_member__or_arithmetic"> 531 left operand must be a pointer, pointer to class member, or arithmetic </H2>
<BR>The left operand must be a pointer, pointer to class member, or arithmetic.
<H2 ID="532_right_operand_must_be_a_pointer__pointer_to_class_member__or_arithmetic"> 532 right operand must be a pointer, pointer to class member, or arithmetic </H2>
<BR>The right operand must be a pointer, pointer to class member, or arithmetic.
<H2 ID="533_neither_pointer_to_class_member_can_be_converted_to_the_other"> 533 neither pointer to class member can be converted to the other </H2>
<BR>The two member pointers being compared are from two unrelated classes.&nbsp; They cannot be compared since their members
can never be related.
<H2 ID="534_left_operand_is_not_a_valid_pointer_to_class_member"> 534 left operand is not a valid pointer to class member </H2>
<BR>The specified operator requires a pointer to member as the left operand.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int S::* mp, int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == mp )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[0] = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="535_right_operand_is_not_a_valid_pointer_to_class_member"> 535 right operand is not a valid pointer to class member </H2>
<BR>The specified operator requires a pointer to member as the right operand.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int S::* mp, int *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( mp == p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[0] = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="536_cannot_use___T__nor__MYT__with_pointer_to_class_member_with_zero_value"> 536 cannot use '.*' nor '-&gt;*' with pointer to class member with zero value </H2>
<BR>The compiler has detected a NULL pointer use with a member pointer dereference.
<H2 ID="537_operand_is_not_a_valid_pointer_to_class_member"> 537 operand is not a valid pointer to class member </H2>
<BR>The operand cannot be converted to a valid pointer to class member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="538_destructor_can_be_invoked_only_with_____or__MY_"> 538 destructor can be invoked only with '.' or '-&gt;' </H2>
<BR>This is a restriction in the C++ language.&nbsp; An explicit invocation of a destructor is not recommended for objects
that have their destructor called automatically.
<H2 ID="539_class_of_destructor_must_be_class_of_object_being_destructed"> 539 class of destructor must be class of object being destructed </H2>
<BR>Destructors can only be called for the exact static type of the object being destroyed.
<H2 ID="540_destructor_is_not_properly_qualified"> 540 destructor is not properly qualified </H2>
<BR>An explicit destructor invocation can only be qualified with its own class.
<H2 ID="541_pointers_to_class_members_reference_different_object_types"> 541 pointers to class members reference different object types </H2>
<BR>Conversion of member pointers can only occur if the object types are identical.&nbsp; This is necessary to ensure type
safety.
<H2 ID="542_operand_must_be_pointer_to_class_or_struct"> 542 operand must be pointer to class or struct </H2>
<BR>The left hand operand of a '-&gt;*' operator must be a pointer to a class.&nbsp; This is a restriction in the C++ language.
<H2 ID="543_expression_must_have_void_type"> 543 expression must have void type </H2>
<BR>If one operand of the ':' operator has<B><I> void</I></B> type, then the other operand must also have<B><I> void</I></B>
type.
<H2 ID="544_expression_types_do_not_match_for_____operator"> 544 expression types do not match for ':' operator </H2>
<BR>The compiler could not bring both operands to a common type.&nbsp; This is necessary because the result of the conditional
operator must be a unique type.
<H2 ID="545_cannot_create_an_undefined_type_with__operator_new_"> 545 cannot create an undefined type with 'operator new' </H2>
<BR>A<B><I> new</I></B> expression cannot allocate an undefined type because it must know how large an allocation is required
and it must also know whether there are any constructors to execute.
<H2 ID="546_delete_of_a_pointer_to_an_undefined_type"> 546 delete of a pointer to an undefined type </H2>
<BR>A<B><I> delete</I></B> expression cannot safely deallocate an undefined type because it must know whether there are any
destructors to execute.&nbsp; In spite of this, the ISO/ANSI C++ Working Paper requires that an implementation support this
usage.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct U;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( U *p, U *q ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="547_cannot_access___S__through_a_private_base_class"> 547 cannot access '%S' through a private base class </H2>
<BR>The indicated symbol cannot be accessed because it requires access to a private base class.
<H2 ID="548_cannot_access___S__through_a_protected_base_class"> 548 cannot access '%S' through a protected base class </H2>
<BR>The indicated symbol cannot be accessed because it requires access to a protected base class.
<H2 ID="549__sizeof__operand_contains_compiler_generated_information"> 549 'sizeof' operand contains compiler generated information </H2>
<BR>The type used in the 'sizeof' operand contains compiler generated information.&nbsp; Clearing a struct with a call to
memset() would invalidate all of this information.
<H2 ID="550_cannot_convert_____operands_to_a_common_reference_type"> 550 cannot convert ':' operands to a common reference type </H2>
<BR>The two reference types cannot be converted to a common reference type.&nbsp; This can happen when the types are not related
through base class inheritance.
<H2 ID="551_conversion_ambiguity__Ureference_to_objectV_to_Utype_of_opposite_____operandV"> 551 conversion ambiguity:&nbsp; [reference to object] to [type of opposite ':' operand] </H2>
<BR>One of the reference types is an ambiguous base class of the other.&nbsp; This prevents the compiler from converting the
operand to a unique common type.
<H2 ID="552_conversion_of_reference_to_____object_involves_a_private_base_class"> 552 conversion of reference to ':' object involves a private base class </H2>
<BR>The conversion of the reference operands requires a conversion through a private base class.
<H2 ID="553_conversion_of_reference_to_____object_involves_a_protected_base_class"> 553 conversion of reference to ':' object involves a protected base class </H2>
<BR>The conversion of the reference operands requires a conversion through a protected base class.
<H2 ID="554_expression_must_have_type_arithmetic__pointer__or_pointer_to_class_member"> 554 expression must have type arithmetic, pointer, or pointer to class member </H2>
<BR>This message means that the type cannot be converted to any of these types, also.&nbsp; All of the mentioned types can
be compared against zero ('0') to produce a true or false value.
<H2 ID="555_expression_for__while__is_always_false"> 555 expression for 'while' is always false </H2>
<BR>The compiler has detected that the expression will always be false.&nbsp; If this is not the expected behaviour, the code
may contain a comparison of an unsigned value against zero (e.g., unsigned integers are always greater than or equal to zero).
&nbsp;Comparisons against zero for addresses can also result in trivially false expressions.
<H2 ID="556_testing_expression_for__for__is_always_false"> 556 testing expression for 'for' is always false </H2>
<BR>The compiler has detected that the expression will always be false.&nbsp; If this is not the expected behaviour, the code
may contain a comparison of an unsigned value against zero (e.g., unsigned integers are always greater than or equal to zero).
&nbsp;Comparisons against zero for addresses can also result in trivially false expressions.
<H2 ID="557_message_number___d__is_invalid"> 557 message number '%d' is invalid </H2>
<BR>The message number used in the #pragma does not match the message number for any warning message.&nbsp; This message can
also indicate that a number or '*' (meaning all warnings) was not found when it was expected.
<H2 ID="558_warning_level_must_be_an_integer_in_range_0_to_9"> 558 warning level must be an integer in range 0 to 9 </H2>
<BR>The new warning level that can be used for the warning can be in the range 0 to 9.&nbsp; The level 0 means that the warning
will be treated as an error (compilation will not succeed).&nbsp; Levels 1 up to 9 are used to classify warnings.&nbsp; The
-w option sets an upper limit on the level for warnings.&nbsp; By setting the level above the command line limit, you effectively
ignore all cases where the warning shows up.
<H2 ID="559_function___S__cannot_be_defined_because_it_is_generated_by_the_compiler"> 559 function '%S' cannot be defined because it is generated by the compiler </H2>
<BR>The indicated function cannot be defined because it is generated by the compiler.&nbsp; The compiler will automatically
generate default constructors, copy constructors, assignment operators, and destructors according to the rules of the C++
language.&nbsp; This message indicates that you did not declare the function in the class definition.
<H2 ID="560_neither_environment_variable_nor_file_found_for__A__name"> 560 neither environment variable nor file found for '@' name </H2>
<BR>The indirection operator for the command line will first check for an environment variable of the name and use the contents
for the command line.&nbsp; If an environment variable is not found, a check for a file with the same name will occur.
<H2 ID="561_more_than_5_indirections_during_command_line_processing"> 561 more than 5 indirections during command line processing </H2>
<BR>The Open Watcom C++ compiler only allows a fixed number nested indirections using files or environment variables, to prevent
runaway chains of indirections.
<H2 ID="562_cannot_take_address_of_nonMstatic_member_function"> 562 cannot take address of non-static member function </H2>
<BR>The only way to create a value that described the non-static member function is to use a member pointer.
<H2 ID="563_cannot_generate_default___S__because_class_contains_either_a_constant_or_a_reference_member"> 563 cannot generate default '%S' because class contains either a constant or a reference member </H2>
<BR>An assignment operator cannot be generated because the class contains members that cannot be assigned into.
<H2 ID="564_cannot_convert_pointer_to_nonMconstant_or_volatile_objects_to_pointer_to_const_void"> 564 cannot convert pointer to non-constant or volatile objects to pointer to const void </H2>
<BR>A pointer to non-constant or volatile objects cannot be converted to 'const void*'.
<H2 ID="565_cannot_convert_pointer_to_nonMconstant_or_nonMvolatile_objects_to_pointer_to_const_volatile_void"> 565 cannot convert pointer to non-constant or non-volatile objects to pointer to const volatile void </H2>
<BR>A pointer to non-constant or non-volatile objects cannot be converted to 'const volatile void*'.
<H2 ID="566_cannot_initialize_pointer_to_nonMvolatile_with_a_pointer_to_volatile"> 566 cannot initialize pointer to non-volatile with a pointer to volatile </H2>
<BR>A pointer to a non-volatile type cannot be initialized with a pointer to a volatile type because this would allow volatile
data to be modified without volatile semantics via the non-volatile pointer to it.
<H2 ID="567_cannot_pass_a_pointer_or_reference_to_a_volatile_object"> 567 cannot pass a pointer or reference to a volatile object </H2>
<BR>A pointer or reference to a volatile object cannot be passed in this context.
<H2 ID="568_cannot_return_a_pointer_or_reference_to_a_volatile_object"> 568 cannot return a pointer or reference to a volatile object </H2>
<BR>A pointer or reference to a volatile object cannot be returned.
<H2 ID="569_left_expression_is_not_a_pointer_to_a_volatile_object"> 569 left expression is not a pointer to a volatile object </H2>
<BR>One cannot assign a pointer to a volatile type to a pointer to a non-volatile type.&nbsp; This would allow a volatile
object to be modified via the non-volatile pointer.&nbsp; Use a cast if this is absolutely necessary.
<H2 ID="570_virtual_function_override_for___S__is_ambiguous"> 570 virtual function override for '%S' is ambiguous </H2>
<BR>This message indicates that there are at least two overrides for the function in the base class.&nbsp; The compiler cannot
arbitrarily choose one so it is up to the programmer to make sure there is an unambiguous choice.&nbsp; Two of the overriding
functions are listed as informational messages.
<H2 ID="571_initialization_priority_must_be_number_0M255___library___or__program_"> 571 initialization priority must be number 0-255, 'library', or 'program' </H2>
<BR>An incorrect module initialization priority has been provided.&nbsp; Check the User's Guide for the correct format of
the priority directive.
<H2 ID="572_previous_case_label_defined__L"> 572 previous case label defined %L </H2>
<BR>This informational message indicates where a preceding<B><I> case</I></B> label is defined.
<H2 ID="573_previous_default_label_defined__L"> 573 previous default label defined %L </H2>
<BR>This informational message indicates where a preceding<B><I> default</I></B> label is defined.
<H2 ID="574_label_defined__L"> 574 label defined %L </H2>
<BR>This informational message indicates where a label is defined.
<H2 ID="575_label_referenced__L"> 575 label referenced %L </H2>
<BR>This informational message indicates where a label is referenced.
<H2 ID="576_object_thrown_has_type___T"> 576 object thrown has type:&nbsp; %T </H2>
<BR>This informational message indicates the type of the object being thrown.
<H2 ID="577_object_thrown_has_an_ambiguous_base_class__T"> 577 object thrown has an ambiguous base class %T </H2>
<BR>It is illegal to throw an object with a base class to which a conversion would be ambiguous.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct ambiguous{ };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct base1 : public ambiguous { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct base2 : public ambiguous { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct derived : public base1, public base2 { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; foo( derived &amp;object )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw object;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The<B><I> throw</I></B> will cause an error to be displayed because an object of type &quot;derived&quot; cannot be
converted to an object of type &quot;ambiguous&quot;.
<H2 ID="578_form_is___pragma_inline_depth_level__where__level__is_0_to_255"> 578 form is '#pragma inline_depth level' where 'level' is 0 to 255 </H2>
<BR>This<B><I> pragma</I></B> sets the number of times inline expansion will occur for an inline function which contains calls
to inline functions.&nbsp; The level must be a number from zero to 255.&nbsp; When the level is zero, no inline expansion
occurs.
<H2 ID="579_pointer_or_reference_truncated_by_cast"> 579 pointer or reference truncated by cast </H2>
<BR>The cast expression causes a conversion of a pointer value to another pointer value of smaller size.&nbsp; This can be
caused by<B><I> __near</I></B> or<B><I> __far</I></B> qualifiers (i.e., casting a<B><I> far</I></B> pointer to a<B><I> near</I></B>
pointer).&nbsp; Function pointers can also have a different size than data pointers in certain memory models.&nbsp; Because
this message indicates that some information is being lost, check the code carefully.
<H2 ID="580_cannot_find_a_constructor_for_given_initializer_argument_list"> 580 cannot find a constructor for given initializer argument list </H2>
<BR>The initializer list provided for the<B><I> new</I></B> expression does not uniquely identify a single constructor.
<H2 ID="581_variable___N__can_only_be_based_on_a_string_in_this_context"> 581 variable '%N' can only be based on a string in this context </H2>
<BR>All of the based modifiers can only be applied to pointer types.&nbsp; The only based modifier that can be applied to
non-pointer types is the '__based(__segname(&quot;WATCOM&quot;))' style.
<H2 ID="582_memory_model_modifiers_are_not_allowed_for_class_members"> 582 memory model modifiers are not allowed for class members </H2>
<BR>Class members describe the arrangement and interpretation of memory and, as such, assume the memory model of the address
used to access the member.
<H2 ID="583_redefinition_of_the_typedef_name___S__ignored"> 583 redefinition of the typedef name '%S' ignored </H2>
<BR>The compiler has detected that a slightly different type has been assigned to a typedef name.&nbsp; The type is functionally
equivalent but typedef redefinitions should be precisely identical.
<H2 ID="584_constructor_for_variable___S__cannot_be_bypassed"> 584 constructor for variable '%S' cannot be bypassed </H2>
<BR>The variable may not be constructed when code is executing at the position the message indicated.&nbsp; The C++ language
places these restrictions to prevent the use of unconstructed variables.
<H2 ID="585_syntax_errorS_missing_start_of_function_body_after_constructor_initializer"> 585 syntax error; missing start of function body after constructor initializer </H2>
<BR>Member initializers can only be used in a constructor's definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int x = 1 ) : a(x)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="586_conversion_ambiguity__UexpressionV_to_Utype_of_default_argumentV"> 586 conversion ambiguity:&nbsp; [expression] to [type of default argument] </H2>
<BR>A conversion to an ambiguous base class was detected in the default argument expression.
<H2 ID="587_conversion_of_expression_for_default_argument_is_impossible"> 587 conversion of expression for default argument is impossible </H2>
<BR>A conversion to a unrelated class was detected in the default argument expression.
<H2 ID="588_syntax_error_before_template_name___s_"> 588 syntax error before template name '%s' </H2>
<BR>The identifier in the error message has been declared as a template name at this point in the code.&nbsp; This may be
the cause of the syntax error.
<H2 ID="589_private_base_class_accessed_to_convert_default_argument"> 589 private base class accessed to convert default argument </H2>
<BR>A conversion to a private base class was detected in the default argument expression.
<H2 ID="590_protected_base_class_accessed_to_convert_default_argument"> 590 protected base class accessed to convert default argument </H2>
<BR>A conversion to a protected base class was detected in the default argument expression.
<H2 ID="591_operand_must_be_an_lvalue_Lcast_produces_rvalueR"> 591 operand must be an lvalue (cast produces rvalue) </H2>
<BR>The compiler is expecting a value which can be assigned into.&nbsp; The result of a cast cannot be assigned into because
a brand new value is always created.&nbsp; Assigning a new value to a temporary is a meaningless operation.
<H2 ID="592_left_operand_must_be_an_lvalue_Lcast_produces_rvalueR"> 592 left operand must be an lvalue (cast produces rvalue) </H2>
<BR>The compiler is expecting a value which can be assigned into.&nbsp; The result of a cast cannot be assigned into because
a brand new value is always created.&nbsp; Assigning a new value to a temporary is a meaningless operation.
<H2 ID="593_right_operand_must_be_an_lvalue_Lcast_produces_rvalueR"> 593 right operand must be an lvalue (cast produces rvalue) </H2>
<BR>The compiler is expecting a value which can be assigned into.&nbsp; The result of a cast cannot be assigned into because
a brand new value is always created.&nbsp; Assigning a new value to a temporary is a meaningless operation.
<H2 ID="594_construct_resolved_as_a_declarationDtype"> 594 construct resolved as a declaration/type </H2>
<BR>The C++ language contains language ambiguities that force compilers to rely on extra information in order to understand
certain language constructs.&nbsp; The extra information required to disambiguate the language can be deduced by looking ahead
in the source file.&nbsp; Once a single interpretation has been found, the compiler can continue analysing source code.&nbsp;
See the ARM p.93 for more details.&nbsp; This warning is intended to inform the programmer that an ambiguous construct has
been resolved in a certain direction.&nbsp; In this case, the construct has been determined to be part of a type.&nbsp; The
final resolution varies between compilers so it is wise to change the source code so that the construct is not ambiguous.
&nbsp;This is especially important in cases where the resolution is more than three tokens away from the start of the ambiguity.
<H2 ID="595_construct_resolved_as_an_expression"> 595 construct resolved as an expression </H2>
<BR>The C++ language contains language ambiguities that force compilers to rely on extra information in order to understand
certain language constructs.&nbsp; The extra information required to disambiguate the language can be deduced by looking ahead
in the source file.&nbsp; Once a single interpretation has been found, the compiler can continue analysing source code.&nbsp;
See the ARM p.93 for more details.&nbsp; This warning is intended to inform the programmer that an ambiguous construct has
been resolved in a certain direction.&nbsp; In this case, the construct has been determined to be part of an expression (a
function-like cast).&nbsp; The final resolution varies between compilers so it is wise to change the source code so that the
construct is not ambiguous.&nbsp; This is especially important in cases where the resolution is more than three tokens away
from the start of the ambiguity.
<H2 ID="596_construct_cannot_be_resolved"> 596 construct cannot be resolved </H2>
<BR>The C++ language contains language ambiguities that force compilers to rely on extra information in order to understand
certain language constructs.&nbsp; The extra information required to disambiguate the language can be deduced by looking ahead
in the source file.&nbsp; Once a single interpretation has been found, the compiler can continue analysing source code.&nbsp;
See the ARM p.93 for more details.&nbsp; This warning is intended to inform the programmer that an ambiguous construct could
not be resolved by the compiler.&nbsp; Please report this to the Open Watcom developement team so that the problem can be
analysed.&nbsp; See http://www.openwatcom.org/.
<H2 ID="597_encountered_another_ambiguous_construct_during_disambiguation"> 597 encountered another ambiguous construct during disambiguation </H2>
<BR>The C++ language contains language ambiguities that force compilers to rely on extra information in order to understand
certain language constructs.&nbsp; The extra information required to disambiguate the language can be deduced by looking ahead
in the source file.&nbsp; Once a single interpretation has been found, the compiler can continue analysing source code.&nbsp;
See the ARM p.93 for more details.&nbsp; This warning is intended to inform the programmer that another ambiguous construct
was found inside an ambiguous construct.&nbsp; The compiler will correctly disambiguate the construct.&nbsp; The programmer
is advised to change code that exhibits this warning because this is definitely uncharted territory in the C++ language.
<H2 ID="598_ellipsis_L___R_argument_contains_compiler_generated_information"> 598 ellipsis (...) argument contains compiler generated information </H2>
<BR>A class with virtual functions or virtual bases is being passed to a function that will not know the type of the argument.
&nbsp;Since this information can be encoded in a variety of ways, the code may not be portable to another environment.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; virtual int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static S sv;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int bar( S, ... );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int test = bar( sv, 14, 64 );</TT>
<BR><BR>The call to &quot;bar&quot; causes a warning, since the structure S contains information associated with the virtual
function for that class.
<H2 ID="599_cannot_convert_argument_for_ellipsis_L___R_argument"> 599 cannot convert argument for ellipsis (...) argument </H2>
<BR>This argument cannot be used as an ellipsis (...) argument to a function.
<H2 ID="600_conversion_ambiguity__UargumentV_to_Uellipsis_L___R_argumentV"> 600 conversion ambiguity:&nbsp; [argument] to [ellipsis (...) argument] </H2>
<BR>A conversion ambiguity was detected while converting an argument to an ellipsis (...) argument.
<H2 ID="601_converted_function_type_has_different__pragma_from_original_function_type"> 601 converted function type has different #pragma from original function type </H2>
<BR>Since a #pragma can affect calling conventions, one must be very careful performing casts involving different calling
conventions.
<H2 ID="602_class_value_used_as_return_value_or_argument_in_converted_function_type"> 602 class value used as return value or argument in converted function type </H2>
<BR>The compiler has detected a cast between &quot;C&quot; and &quot;C++&quot; linkage function types.&nbsp; The calling conventions
are different because of the different language rules for copying structures.
<H2 ID="603_class_value_used_as_return_value_or_argument_in_original_function_type"> 603 class value used as return value or argument in original function type </H2>
<BR>The compiler has detected a cast between &quot;C&quot; and &quot;C++&quot; linkage function types.&nbsp; The calling conventions
are different because of the different language rules for copying structures.
<H2 ID="604_must_look_ahead_to_determine_whether_construct_is_a_declarationDtype_or_an_expression"> 604 must look ahead to determine whether construct is a declaration/type or an expression </H2>
<BR>The C++ language contains language ambiguities that force compilers to rely on extra information in order to understand
certain language constructs.&nbsp; The extra information required to disambiguate the language can be deduced by looking ahead
in the source file.&nbsp; Once a single interpretation has been found, the compiler can continue analysing source code.&nbsp;
See the ARM p.93 for more details.&nbsp; This warning is intended to inform the programmer that an ambiguous construct has
been used.&nbsp; The final resolution varies between compilers so it is wise to change the source code so that the construct
is not ambiguous.
<H2 ID="605_assembler____s_"> 605 assembler:&nbsp; '%s' </H2>
<BR>An error has been detected by the #pragma inline assembler.
<H2 ID="606_default_argument_expression_cannot_reference__this_"> 606 default argument expression cannot reference 'this' </H2>
<BR>The order of evaluation for function arguments is unspecified in the C++ language document.&nbsp; Thus, a default argument
must be able to be evaluated before the 'this' argument (or any other argument) is evaluated.
<H2 ID="607__pragma_aux_must_reference_a__C__linkage_function___S_"> 607 #pragma aux must reference a &quot;C&quot; linkage function '%S' </H2>
<BR>The method of assigning pragma information via the #pragma syntax is provided for compatibility with Open Watcom C.&nbsp;
Because C only allows one function per name, this was adequate for the C language.&nbsp; Since C++ allows functions to be
overloaded, a new method of referencing pragmas has been introduced.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux this_in_SI parm caller [si] [ax];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __pragma(&quot;this_in_SI&quot;) foo( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __pragma(&quot;this_in_SI&quot;) foo( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="608_assignment_is_ambiguous_for_operands_used"> 608 assignment is ambiguous for operands used </H2>
<BR>An ambiguity was detected while attempting to convert the right operand to the type of the left operand.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S2 : S1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S3 : S2, S1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S1* fn( S3 *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example,<B><I> class</I></B> <TT> S1</TT> occurs ambiguously for an object or pointer to an object of type<TT>
S3.</TT>&nbsp; A pointer to an<TT> S3</TT> object cannot be converted to a pointer to an<TT> S1</TT> object.
<H2 ID="609_pragma_name___s__is_not_defined"> 609 pragma name '%s' is not defined </H2>
<BR>Pragmas are defined with the #pragma aux syntax.&nbsp; See the User's Guide for the details of defining a pragma name.
&nbsp;If the pragma has been defined then check the spelling between the definition and the reference of the pragma name.
<H2 ID="610___S__could_not_be_generated_by_the_compiler"> 610 '%S' could not be generated by the compiler </H2>
<BR>An error occurred while the compiler tried to generate the specified function.&nbsp; The error prevented the compiler
from generating the function properly so the compilation cannot continue.
<H2 ID="611__catch__does_not_immediately_follow_a__try__or__catch_"> 611 'catch' does not immediately follow a 'try' or 'catch' </H2>
<BR>The catch handler syntax must be used in conjunction with a try block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void f()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code that may throw an exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( int x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle 'int' exceptions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( ... ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // handle all other exceptions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="612_preceding_catch_specified______"> 612 preceding catch specified '...' </H2>
<BR>Since an ellipsis &quot;...&quot; catch handler will handle any type of exception, no further catch handlers can exist
afterwards because they will never execute.&nbsp; Reorder the catch handlers so that the &quot;...&quot; catch handler is
the last handler.
<H2 ID="613_argument_to_extern__C__function_contains_compiler_generated_information"> 613 argument to extern &quot;C&quot; function contains compiler generated information </H2>
<BR>A class with virtual functions or virtual bases is being passed to a function that will not know the type of the argument.
&nbsp;Since this information can be encoded in a variety of ways, the code may not be portable to another environment.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; virtual int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static S sv;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern &quot;C&quot; int bar( S );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int test = bar( sv );</TT>
<BR><BR>The call to &quot;bar&quot; causes a warning, since the structure S contains information associated with the virtual
function for that class.
<H2 ID="614_previous_try_block_defined__L"> 614 previous try block defined %L </H2>
<BR>This informational message indicates where a preceding<B><I> try</I></B> block is defined.
<H2 ID="615_previous_catch_block_defined__L"> 615 previous catch block defined %L </H2>
<BR>This informational message indicates where a preceding<B><I> catch</I></B> block is defined.
<H2 ID="616_catch_handler_can_never_be_invoked"> 616 catch handler can never be invoked </H2>
<BR>Because the handlers for a<B><I> try</I></B> block are tried in order of appearance, the type specified in a preceding<B><I>
catch</I></B> can ensure that the current handler will never be invoked.&nbsp; This occurs when a base class (or reference)
precedes a derived class (or reference); when a pointer to a base class (or reference to the pointer) precedes a pointer to
a derived class (or reference to the pointer); or, when &quot;void*&quot; or &quot;void*&amp;&quot; precedes a pointer or
a reference to the pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct BASE {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DERIVED : public BASE {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code for try</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( BASE b ) {&nbsp;&nbsp;&nbsp;&nbsp; // [1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( DERIVED ) {&nbsp;&nbsp;&nbsp; // warning: [1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( BASE* pb ) {&nbsp;&nbsp; // [2]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( DERIVED* pd ) {// warning: [2]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( void* pv ) {&nbsp;&nbsp; // [3]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( int* pi ) {&nbsp;&nbsp;&nbsp; // warning: [3]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( BASE&amp; br ) {&nbsp;&nbsp; // warning: [1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( float*&amp; pfr ) {// warning: [3]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Each erroneous catch specification indicates the preceding catch block which caused the error.
<H2 ID="617_cannot_overload_extern__C__functions_Lthe_other_function_is___S_R"> 617 cannot overload extern &quot;C&quot; functions (the other function is '%S') </H2>
<BR>The C++ language only allows you to overload functions that are strictly C++ functions.&nbsp; The compiler will automatically
generate the correct code to distinguish each particular function based on its argument types.&nbsp; The extern &quot;C&quot;
linkage mechanism only allows you to define one &quot;C&quot; function of a particular name because the C language does not
support function overloading.
<H2 ID="618_function_will_be_overload_ambiguous_with___S__using_default_arguments"> 618 function will be overload ambiguous with '%S' using default arguments </H2>
<BR>The declaration declares a function that is indistinguishable from another function of the same name with default arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int, int = 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int );</TT>
<BR><BR>Calling the function 'fn' with one argument is ambiguous because it could match either the first 'fn' with a default
argument applied or the second 'fn' without any default arguments.
<H2 ID="619_linkage_specification_is_different_than_previous_declaration___S_"> 619 linkage specification is different than previous declaration '%S' </H2>
<BR>The linkage specification affects the binding of names throughout a program.&nbsp; It is important to maintain consistency
because subtle problems could arise when the incorrect function is called.&nbsp; Usually this error prevents an unresolved
symbol error during linking because the name of a declaration is affected by its linkage specification.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern &quot;C&quot; void fn( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="620_not_enough_segment_registers_available_to_generate___s_"> 620 not enough segment registers available to generate '%s' </H2>
<BR>Through a combination of options, the number of available segment registers is too small.&nbsp; This can occur when too
many segment registers are pegged.&nbsp; This can be fixed by changing the command line options to only peg the segment registers
that must absolutely be pegged.
<H2 ID="621_pure_virtual_destructors_must_have_a_definition"> 621 pure virtual destructors must have a definition </H2>
<BR>This is an anomaly for pure virtual functions.&nbsp; A destructor is the only special function that is inherited and allowed
to be virtual.&nbsp; A derived class must be able to call the base class destructor so a pure virtual destructor must be defined
in a C++ program.
<H2 ID="622_jump_into_try_block"> 622 jump into try block </H2>
<BR>Jumps cannot enter<B><I> try</I></B> blocks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a) goto tr_lab;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tr_lab:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw 1234;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( int ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a) goto tr_lab;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a) goto tr_lab;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>All the preceding goto's are illegal.&nbsp; The error is detected at the label for forward jumps and at the goto's
for backward jumps.
<H2 ID="623_jump_into_catch_handler"> 623 jump into catch handler </H2>
<BR>Jumps cannot enter<B><I> catch</I></B> handlers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; foo( int a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a)goto ca_lab;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a)goto ca_lab;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( int ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ca_lab:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(a)goto ca_lab;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>All the preceding goto's are illegal.&nbsp; The error is detected at the label for forward jumps and at the goto's
for backward jumps.
<H2 ID="624_catch_block_does_not_immediately_follow_try_block"> 624 catch block does not immediately follow try block </H2>
<BR>At least one<B><I> catch</I></B> handler must immediately follow the &quot;}&quot; of a<B><I> try</I></B> block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a catch block should follow!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, there were no catch blocks after the<B><I> try</I></B> block.
<H2 ID="625_exceptions_must_be_enabled_to_use_feature_Luse__xs__optionR"> 625 exceptions must be enabled to use feature (use 'xs' option) </H2>
<BR>Exceptions are enabled by specifying the 'xs' option when the compiler is invoked.&nbsp; The error message indicates that
a feature such as<B><I> try,</I></B> <B><I> catch,</I></B> <B><I> throw,</I></B> or function exception specification has been
used without enabling exceptions.
<H2 ID="626_IDO_error_reading___s____s_"> 626 I/O error reading '%s':&nbsp; %s&quot; </H2>
<BR>When attempting to read data from a source or header file, the indicated system error occurred.&nbsp; Likely there is
a hardware problem, or the file system has become corrupt.
<H2 ID="627_text_following_preMprocessor_directive"> 627 text following pre-processor directive </H2>
<BR>A<B><I> #else</I></B> or<B><I> #endif</I></B> directive was found which had tokens following it rather than an end of
line.&nbsp; Some UNIX style preprocessors allowed this, but it is not legal under standard C or C++.&nbsp; Make the tokens
into a comment.
<H2 ID="628_expression_is_not_meaningful"> 628 expression is not meaningful </H2>
<BR>This message indicates that the indicated expression is not meaningful.&nbsp; An expression is meaningful when a function
is invoked, when an assignment or initialization is performed, or when the expression is casted to void.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int i, int j )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i + j;&nbsp; // not meaningful</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="629_expression_has_no_side_effect"> 629 expression has no side effect </H2>
<BR>The indicated expression does not cause a side effect.&nbsp; A side effect is caused by invoking a function, by an assignment
or an initialization, or by reading a<B><I> volatile</I></B> variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( int i, int j )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i + j,&nbsp; // no side effect (note comma)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="630_source_conversion_type_is___T_"> 630 source conversion type is '%T' </H2>
<BR>This informational message indicates the type of the source operand, for the preceding conversion diagnostic.
<H2 ID="631_target_conversion_type_is___T_"> 631 target conversion type is '%T' </H2>
<BR>This informational message indicates the target type of the conversion, for the preceding conversion diagnostic.
<H2 ID="632_redeclaration_of___S__has_different_attributes"> 632 redeclaration of '%S' has different attributes </H2>
<BR>A function cannot be made<B><I> virtual</I></B> or pure<B><I> virtual</I></B> in a subsequent declaration.&nbsp; All properties
of a function should be described in the first declaration of a function.&nbsp; This is especially important for member functions
because the properties of a class are affected by its member functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtual void S::fun()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="633_template_class_instantiation_for___T__was__L"> 633 template class instantiation for '%T' was %L </H2>
<BR>This informational message indicates that the error or warning was detected during the instantiation of a class template.
&nbsp;The final type of the template class is shown as well as the location in the source where the instantiation was initiated.
<H2 ID="634_template_function_instantiation_for___S__was__L"> 634 template function instantiation for '%S' was %L </H2>
<BR>This informational message indicates that the error or warning was detected during the instantiation of a function template.
&nbsp;The final type of the template function is shown as well as the location in the source where the instantiation was initiated.
<H2 ID="635_template_class_member_instantiation_was__L"> 635 template class member instantiation was %L </H2>
<BR>This informational message indicates that the error or warning was detected during the instantiation of a member of a
class template.&nbsp; The location in the source where the instantiation was initiated is shown.
<H2 ID="636_function_template_binding_for___S__was__L"> 636 function template binding for '%S' was %L </H2>
<BR>This informational message indicates that the error or warning was detected during the binding process of a function template.
&nbsp;The binding process occurs at the point where arguments are analysed in order to infer what types should be used in
a function template instantiation.&nbsp; The function template in question is shown along with the location in the source
code that initiated the binding process.
<H2 ID="637_function_template_binding_of___S__was__L"> 637 function template binding of '%S' was %L </H2>
<BR>This informational message indicates that the error or warning was detected during the binding process of a function template.
&nbsp;The binding process occurs at the point where a function prototype is analysed in order to see if the prototype matches
any function template of the same name.&nbsp; The function template in question is shown along with the location in the source
code that initiated the binding process.
<H2 ID="638___s__defined__L"> 638 '%s' defined %L </H2>
<BR>This informational message indicates where the class in question was defined.&nbsp; The message is displayed following
an error or warning diagnostic for the class in question.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo( S*p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p-&gt;x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The variable<TT> p</TT> is a pointer to an undefined class and so will cause an error to be generated.&nbsp; Following
the error, the informational message indicates the line at which the class S was declared.
<H2 ID="639_form_is___pragma_template_depth_level__where__level__is_a_nonMzero_number"> 639 form is '#pragma template_depth level' where 'level' is a non-zero number </H2>
<BR>This<B><I> pragma</I></B> sets the number of times templates will be instantiated for nested instantiations.&nbsp; The
depth check prevents infinite compile times for incorrect programs.
<H2 ID="640_possible_nonMterminating_template_instantiation_Luse___pragma_template_depth__d__to_increase_depthR"> 640 possible non-terminating template instantiation (use &quot;#pragma template_depth %d&quot; to increase depth) </H2>
<BR>This message indicates that a large number of expansions were required to complete a template class or template function
instantiation.&nbsp; This may indicate that there is an erroneous use of a template.&nbsp; If the program will complete given
more depth, try using the suggested #pragma in the error message to increase the depth.&nbsp; The number provided is double
the previous value.
<H2 ID="641_cannot_inherit_a_partially_defined_base_class___T_"> 641 cannot inherit a partially defined base class '%T' </H2>
<BR>This message indicates that the base class was in the midst of being defined when it was inherited.&nbsp; The storage
requirements for a<B><I> class</I></B> type must be known when inheritance is involved because the layout of the final class
depends on knowing the complete contents of all base classes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Partial {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Nested : Partial {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="642_ambiguous_function___F_defined__L"> 642 ambiguous function:&nbsp; %F defined %L </H2>
<BR>This informational message shows the functions that were detected to be ambiguous.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int amb( char );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will be ambiguous</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int amb( unsigned char );&nbsp;&nbsp; // will be ambiguous</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int amb( char, char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = amb( 14 );</TT>
<BR><BR>The constant value 14 has an<B><I> int</I></B> type and so the attempt to invoke the function<TT> amb</TT> is ambiguous.
&nbsp;The first two functions are ambiguous (and will be displayed); the third is not considered (nor displayed) since it
is declared to have a different number of arguments.
<H2 ID="643_cannot_convert_argument__d_defined__L"> 643 cannot convert argument %d defined %L </H2>
<BR>This informational message indicates the first argument which could not be converted to the corresponding type for the
declared function.&nbsp; It is displayed when there is exactly one function declared with the indicated name.
<H2 ID="644__this__cannot_be_converted"> 644 'this' cannot be converted </H2>
<BR>This informational message indicates the<B><I> this</I></B> pointer for the function which could not be converted to the
type of the<B><I> this</I></B> pointer for the declared function.&nbsp; It is displayed when there is exactly one function
declared with the indicated name.
<H2 ID="645_rejected_function___F_defined__L"> 645 rejected function:&nbsp; %F defined %L </H2>
<BR>This informational message shows the overloaded functions which were rejected from consideration during function-overload
resolution.&nbsp; These functions are displayed when there is more than one function with the indicated name.
<H2 ID="646___T__operator_can_be_used"> 646 '%T' operator can be used </H2>
<BR>Following a diagnosis of operator ambiguity, this information message indicates that the operator can be applied with
operands of the type indicated in the message.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator int();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S operator+( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S s(15);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = s + 123;&nbsp;&nbsp;&nbsp; // &quot;+&quot; is ambiguous</TT>
<BR><BR>In the example, the &quot;+&quot; operation is ambiguous because it can implemented as by the addition of two integers
(with<TT> S::operator int</TT> applied to the second operand) or by a call to<TT> S::operator+.</TT>&nbsp; This informational
message indicates that the first is possible.
<H2 ID="647_cannot__undef___s_"> 647 cannot #undef '%s' </H2>
<BR>The predefined macros<TT> __cplusplus, __DATE__, __FILE__, __LINE__, __STDC__, __TIME__, __FUNCTION__</TT> and<TT> __func__</TT>
cannot be undefined using the<B><I> #undef</I></B> directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __cplusplus</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __DATE__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __FILE__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __LINE__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __STDC__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __TIME__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __FUNCTION__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef __func__</TT>
<BR><BR>All of the preceding directives are not permitted.
<H2 ID="648_cannot__define___s_"> 648 cannot #define '%s' </H2>
<BR>The predefined macros<TT> __cplusplus, __DATE__, __FILE__, __LINE__, __STDC__,</TT> and<TT> __TIME__</TT> cannot be defined
using the<B><I> #define</I></B> directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __cplusplus&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __DATE__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __FILE__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __LINE__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __STDC__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define __TIME__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6</TT>
<BR><BR>All of the preceding directives are not permitted.
<H2 ID="649_template_function___F__defined__L"> 649 template function '%F' defined %L </H2>
<BR>This informational message indicates where the function template in question was defined.&nbsp; The message is displayed
following an error or warning diagnostic for the function template in question.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo( T, T * )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bar()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(1);&nbsp;&nbsp;&nbsp;&nbsp; // could not instantiate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The function template for<TT> foo</TT> cannot be instantiated for a single argument causing an error to be generated.
&nbsp;Following the error, the informational message indicates the line at which<TT> foo</TT> was declared.
<H2 ID="650_ambiguous_function_template___F_defined__L"> 650 ambiguous function template:&nbsp; %F defined %L </H2>
<BR>This informational message shows the function templates that were detected to be ambiguous for the arguments at the call
point.
<H2 ID="651_cannot_instantiate__S"> 651 cannot instantiate %S </H2>
<BR>This message indicates that the function template could not be instantiated for the arguments supplied.&nbsp; It is displayed
when there is exactly one function template declared with the indicated name.
<H2 ID="652_rejected_function_template___F_defined__L"> 652 rejected function template:&nbsp; %F defined %L </H2>
<BR>This informational message shows the overloaded function template which was rejected from consideration during function-overload
resolution.&nbsp; These functions are displayed when there is more than one function or function template with the indicated
name.
<H2 ID="653_operand_cannot_be_a_function"> 653 operand cannot be a function </H2>
<BR>The indicated operation cannot be applied to a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int j = ++Fun;&nbsp; // illegal</TT>
<BR><BR>In the example, the attempt to increment a function is illegal.
<H2 ID="654_left_operand_cannot_be_a_function"> 654 left operand cannot be a function </H2>
<BR>The indicated operation cannot be applied to the left operand which is a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int Fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun = 0;&nbsp;&nbsp;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, the attempt to assign zero to a function is illegal.
<H2 ID="655_right_operand_cannot_be_a_function"> 655 right operand cannot be a function </H2>
<BR>The indicated operation cannot be applied to the right operand which is a function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int Fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void* p = 3[Fun];&nbsp;&nbsp; // illegal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, the attempt to subscript a function is illegal.
<H2 ID="656_define_this_function_inside_its_class_definition_Lmay_improve_code_qualityR"> 656 define this function inside its class definition (may improve code quality) </H2>
<BR>The Open Watcom C++ compiler has found a constructor or destructor with an empty function body.&nbsp; An empty function
body can usually provide optimization opportunities so the compiler is indicating that by defining the function inside its
class definition, the compiler may be able to perform some important optimizations.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::~S() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="657_define_this_function_inside_its_class_definition_Lcould_have_improved_code_qualityR"> 657 define this function inside its class definition (could have improved code quality) </H2>
<BR>The Open Watcom C++ compiler has found a constructor or destructor with an empty function body.&nbsp; An empty function
body can usually provide optimization opportunities so the compiler is indicating that by defining the function inside its
class definition, the compiler may be able to perform some important optimizations.&nbsp; This particular warning indicates
that the compiler has already found an opportunity in previous code but it found out too late that the constructor or destructor
had an empty function body.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T : S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~T() {}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::~S() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="658_cannot_convert_address_of_overloaded_function___S_"> 658 cannot convert address of overloaded function '%S' </H2>
<BR>This information message indicates that an address of an overloaded function cannot be converted to the indicated type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ovload( char );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ovload( float );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int routine( int (*)( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = routine( ovload );</TT>
<BR><BR>The first argument for the function<TT> routine</TT> cannot be converted, resulting in the informational message.
<H2 ID="659_expression_cannot_have_void_type"> 659 expression cannot have void type </H2>
<BR>The indicated expression cannot have a<B><I> void</I></B> type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main( int argc, char* argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (void)argc ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 9;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Conditional expressions, such as the one illustrated in the<B><I> if</I></B> statement cannot have a<B><I> void</I></B>
type.
<H2 ID="660_cannot_reference_a_bit_field"> 660 cannot reference a bit field </H2>
<BR>The smallest addressable unit is a byte.&nbsp; You cannot reference a bit field.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; int bits :6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bitfield :10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S var;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&amp; ref = var.bitfield;&nbsp;&nbsp;&nbsp; // illegal</TT>
<H2 ID="661_cannot_assign_to_object_having_an_undefined_class"> 661 cannot assign to object having an undefined class </H2>
<BR>An assignment cannot be be made to an object whose class has not been defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // declared, but not defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern X&amp; foo();&nbsp;&nbsp;&nbsp; // returns reference (ok)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern X obj;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = foo();&nbsp;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="662_cannot_create_member_pointer_to_constructor"> 662 cannot create member pointer to constructor </H2>
<BR>A member pointer value cannot reference a constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 == &amp;C::C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="663_cannot_create_member_pointer_to_destructor"> 663 cannot create member pointer to destructor </H2>
<BR>A member pointer value cannot reference a destructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 == &amp;C::~C;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="664_attempt_to_initialize_a_nonMconstant_reference_with_a_temporary_object"> 664 attempt to initialize a non-constant reference with a temporary object </H2>
<BR>A temporary value cannot be converted to a non-constant reference type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( C&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C &amp; c1 = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C c2 = 2;</TT>
<BR><BR>The initializations of<TT> c1</TT> and<TT> c2</TT> are erroneous, since temporaries are being bound to non-const references.
&nbsp;In the case of<TT> c1,</TT> an implicit constructor call is required to convert the integer to the correct object type.
&nbsp;This results in a temporary object being created to initialize the reference.&nbsp; Subsequent code can modify this
temporary's state.&nbsp; The initialization of<TT> c2,</TT> is erroneous for a similar reason.&nbsp; In this case, the temporary
is being bound to the non-const reference argument of the copy constructor.
<H2 ID="665_temporary_object_used_to_initialize_a_nonMconstant_reference"> 665 temporary object used to initialize a non-constant reference </H2>
<BR>Ordinarily, a temporary value cannot be bound to a non-constant reference.&nbsp; There is enough legacy code present that
the Open Watcom C++ compiler issues a warning in cases that should be errors.&nbsp; This may change in the future so it is
advisable to correct the code as soon as possible.
<H2 ID="666_assuming_unary__operator____not_overloaded_for_type___T_"> 666 assuming unary 'operator &amp;' not overloaded for type '%T' </H2>
<BR>An explicit address operator can be applied to a reference to an undefined class.&nbsp; The Open Watcom C++ compiler will
assume that the address is required but it does not know whether this was the programmer's intention because the class definition
has not been seen.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S * fn( S &amp;y ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // assuming no operator '&amp;' defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="667__va_start__macro_will_not_work_without_an_argument_before______"> 667 'va_start' macro will not work without an argument before '...' </H2>
<BR>The warning indicates that it is impossible to access the arguments passed to the function without declaring an argument
before the &quot;...&quot; argument.&nbsp; The &quot;...&quot; style of argument list (without any other arguments) is only
useful as a prototype or if the function is designed to ignore all of its arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="668__va_start__macro_will_not_work_with_a_reference_argument_before______"> 668 'va_start' macro will not work with a reference argument before '...' </H2>
<BR>The warning indicates that taking the address of the argument before the &quot;...&quot; argument, which 'va_start' does
in order to access the variable list of arguments, will not give the expected result.&nbsp; The arguments will have to be
rearranged so that an acceptable argument is declared before the &quot;...&quot; argument or a dummy<B><I> int</I></B> argument
can be inserted after the reference argument with the corresponding adjustments made to the callers of the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int &amp;r, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // address of 'r' is address of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object 'r' references so</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 'va_start' will not work properly</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, r );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="669__va_start__macro_will_not_work_with_a_class_argument_before______"> 669 'va_start' macro will not work with a class argument before '...' </H2>
<BR>This warning is specific to C++ compilers that quietly convert class arguments to class reference arguments.&nbsp; The
warning indicates that taking the address of the argument before the &quot;...&quot; argument, which 'va_start' does in order
to access the variable list of arguments, will not give the expected result.&nbsp; The arguments will have to be rearranged
so that an acceptable argument is declared before the &quot;...&quot; argument or a dummy<B><I> int</I></B> argument can be
inserted after the class argument with the corresponding adjustments made to the callers of the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( S c, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list args;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Open Watcom C++ passes a pointer to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the temporary created for passing</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 'c' rather than pushing 'c' on the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stack so 'va_start' will not work</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // properly</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( args, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="670_function_modifier_conflicts_with_previous_declaration___S_"> 670 function modifier conflicts with previous declaration '%S' </H2>
<BR>The symbol declaration conflicts with a previous declaration with regard to function modifiers.&nbsp; Either the previous
declaration did not have a function modifier or it had a different one.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux never_returns aborts;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __pragma(&quot;never_returns&quot;) fn( int, int );</TT>
<H2 ID="671_function_modifier_cannot_be_used_on_a_variable"> 671 function modifier cannot be used on a variable </H2>
<BR>The symbol declaration has a function modifier being applied to a variable or non-function.&nbsp; The cause of this may
be a declaration with a missing function argument list.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (* __pascal ok)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (* __pascal not_ok);</TT>
<H2 ID="672___T__contains_the_following_pure_virtual_functions"> 672 '%T' contains the following pure virtual functions </H2>
<BR>This informational message indicates that the class contains pure virtual function declarations.&nbsp; The class is definitely
abstract as a result and cannot be used to declare variables.&nbsp; The pure virtual functions declared in the class are displayed
immediately following this message.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void virtual fn( int ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A x;</TT>
<H2 ID="673___T__has_no_implementation_for_the_following_pure_virtual_functions"> 673 '%T' has no implementation for the following pure virtual functions </H2>
<BR>This informational message indicates that the class is derived from an abstract class but the class did not override enough
virtual function declarations.&nbsp; The pure virtual functions declared in the class are displayed immediately following
this message.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void virtual fn( int ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D x;</TT>
<H2 ID="674_pure_virtual_function___F__defined__L"> 674 pure virtual function '%F' defined %L </H2>
<BR>This informational message indicates that the pure virtual function has not been overridden.&nbsp; This means that the
class is abstract.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void virtual fn( int ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D x;</TT>
<H2 ID="675_restriction__standard_calling_convention_required_for___S_"> 675 restriction:&nbsp; standard calling convention required for '%S' </H2>
<BR>The indicated function may be called by the C++ run-time system using the standard calling convention.&nbsp; The calling
convention specified for the function is incompatible with the standard convention.&nbsp; This message may result when<TT>
__pascal</TT> is specified for a default constructor, a copy constructor, or a destructor.&nbsp; It may also result when<TT>
parm reverse</TT> is specified in a<B><I> #pragma</I></B> for the function.
<H2 ID="676_number_of_arguments_in_function_call_is_incorrect"> 676 number of arguments in function call is incorrect </H2>
<BR>The number of arguments in the function call does not match the number declared for the function type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int (*pfn)( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int k = pfn( 1, 2, 3 );</TT>
<BR><BR>In the example, the function pointer was declared to have two arguments.&nbsp; Three arguments were used in the call.
<H2 ID="677_function_has_type___T_"> 677 function has type '%T' </H2>
<BR>This informational message indicates the type of the function being called.
<H2 ID="678_invalid_octal_constant"> 678 invalid octal constant </H2>
<BR>The constant started with a '0' digit which makes it look like an octal constant but the constant contained the digits
'8' and '9'.&nbsp; The problem could be an incorrect octal constant or a missing '.' for a floating constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = 0123456789; // invalid octal constant</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double d = 0123456789;&nbsp; // missing '.'?</TT>
<H2 ID="679_class_template_definition_started__L"> 679 class template definition started %L </H2>
<BR>This informational message indicates where the class template definition started so that any problems with missing braces
can be fixed quickly and easily.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f1() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error missing '}'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f2() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="680_constructor_initializer_started__L"> 680 constructor initializer started %L </H2>
<BR>This informational message indicates where the constructor initializer started so that any problems with missing parenthesis
can be fixed quickly and easily.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int x ) : a(x), b(x // missing parenthesis</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="681_zero_size_array_must_be_the_last_data_member"> 681 zero size array must be the last data member </H2>
<BR>The language extension that allows a zero size array to be declared in a class definition requires that the array be the
last data member in the class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="682_cannot_inherit_a_class_that_contains_a_zero_size_array"> 682 cannot inherit a class that contains a zero size array </H2>
<BR>The language extension that allows a zero size array to be declared in a class definition disallows the use of the class
as a base class.&nbsp; This prevents the programmer from corrupting storage in derived classes through the use of the zero
size array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="683_zero_size_array___S__cannot_be_used_in_a_class_with_base_classes"> 683 zero size array '%S' cannot be used in a class with base classes </H2>
<BR>The language extension that allows a zero size array to be declared in a class definition requires that the class not
have any base classes.&nbsp; This is required because the C++ compiler must be free to organize base classes in any manner
for optimization purposes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="684_cannot_catch_abstract_class_object"> 684 cannot catch abstract class object </H2>
<BR>C++ does not allow abstract classes to be instantiated and so an abstract class object cannot be specified in a<B><I>
catch</I></B> clause.&nbsp; It is permissible to catch a reference to an abstract class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Abstract {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int foo() = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Derived : Abstract {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int xyz;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func( void ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw Derived();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( Abstract abstract ) {&nbsp;&nbsp; // object</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xyz = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The catch clause in the preceding example would be diagnosed as improper, since an abstract class is specified.&nbsp;
The example could be coded as follows.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Abstract {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int foo() = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class Derived : Abstract {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int xyz;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func( void ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw Derived();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch( Abstract &amp; abstract ) {&nbsp; // reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xyz = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="685_nonMstatic_member_function___S__cannot_be_specified"> 685 non-static member function '%S' cannot be specified </H2>
<BR>The indicated non-static member function cannot be used in this context.&nbsp; For example, such a function cannot be
used as the second or third operand of the conditional operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::fun( int i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (i ? foo : bar)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Neither<TT> foo</TT> nor<TT> bar</TT> can be specified as shown in the example.&nbsp; The example can be properly
coded as follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fun();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::fun( int i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i ? foo() : bar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="686_attempt_to_convert_pointer_or_reference_from_a_base_to_a_derived_class"> 686 attempt to convert pointer or reference from a base to a derived class </H2>
<BR>A pointer or reference to a base class cannot be converted to a pointer or reference, respectively, of a derived class,
unless there is an explicit cast.&nbsp; The<TT> return</TT> statements in the following example will be diagnosed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : Base {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Base b;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived* ReturnPtr() { return &amp;b; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived&amp; ReturnRef() { return b; }</TT>
<BR><BR>The following program would be acceptable:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : Base {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Base b;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived* ReturnPtr() { return (Derived*)&amp;b; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived&amp; ReturnRef() { return (Derived&amp;)b; }</TT>
<H2 ID="687_expression_for__while__is_always_true"> 687 expression for 'while' is always true </H2>
<BR>The compiler has detected that the expression will always be true.&nbsp; Consequently, the loop will execute infinitely
unless there is a<B><I> break</I></B> statement within the loop or a<B><I> throw</I></B> statement is executed while executing
within the loop.&nbsp; If such an infinite loop is required, it can be coded as<TT> for(</TT> ; ) without causing warnings.
<H2 ID="688_testing_expression_for__for__is_always_true"> 688 testing expression for 'for' is always true </H2>
<BR>The compiler has detected that the expression will always be true.&nbsp; Consequently, the loop will execute infinitely
unless there is a<B><I> break</I></B> statement within the loop or a<B><I> throw</I></B> statement is executed while executing
within the loop.&nbsp; If such an infinite loop is required, it can be coded as<TT> for(</TT> ; ) without causing warnings.
<H2 ID="689_conditional_expression_is_always_true_LnonMzeroR"> 689 conditional expression is always true (non-zero) </H2>
<BR>The indicated expression is a non-zero constant and so will always be true.
<H2 ID="690_conditional_expression_is_always_false_LzeroR"> 690 conditional expression is always false (zero) </H2>
<BR>The indicated expression is a zero constant and so will always be false.
<H2 ID="691_expecting_a_member_of___T__to_be_defined_in_this_context"> 691 expecting a member of '%T' to be defined in this context </H2>
<BR>A class template member definition must define a member of the associated class template.&nbsp; The complexity of the
C++ declaration syntax can make this error hard to identify visually.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef int X;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static X fn( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static X qq;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S&lt;T&gt;::X fn( int ) {// should be 'S&lt;T&gt;::fn'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fn( 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S&lt;T&gt;::X qq = 1; // should be 'S&lt;T&gt;::q'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&lt;int&gt; x;</TT>
<H2 ID="692_cannot_throw_an_abstract_class"> 692 cannot throw an abstract class </H2>
<BR>An abstract class cannot be thrown since copies of that object may have to be made (which is impossible );
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct abstract_class {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract_class( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int foo() = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void goop()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw abstract_class( 17 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The<B><I> throw</I></B> expression is illegal since it specifies an abstract class.
<H2 ID="693_cannot_create_preMcompiled_header_file___s_"> 693 cannot create pre-compiled header file '%s' </H2>
<BR>The compiler has detected a problem while trying to open the pre-compiled header file for write access.
<H2 ID="694_error_occurred_while_writing_preMcompiled_header_file"> 694 error occurred while writing pre-compiled header file </H2>
<BR>The compiler has detected a problem while trying to write some data to the pre-compiled header file.
<H2 ID="695_error_occurred_while_reading_preMcompiled_header_file"> 695 error occurred while reading pre-compiled header file </H2>
<BR>The compiler has detected a problem while trying to read some data from the pre-compiled header file.
<H2 ID="696_preMcompiled_header_file_being_recreated"> 696 pre-compiled header file being recreated </H2>
<BR>The existing pre-compiled header file may either be corrupted or is a version that the compiler cannot use due to updates
to the compiler.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="697_preMcompiled_header_file_being_recreated_Ldifferent_compile_optionsR"> 697 pre-compiled header file being recreated (different compile options) </H2>
<BR>The compiler has detected that the command line options have changed enough so the contents of the pre-compiled header
file cannot be used.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="698_preMcompiled_header_file_being_recreated_Ldifferent__include_fileR"> 698 pre-compiled header file being recreated (different #include file) </H2>
<BR>The compiler has detected that the first<B><I> #include</I></B> file name is different so the contents of the pre-compiled
header file cannot be used.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="699_preMcompiled_header_file_being_recreated_Ldifferent_current_directoryR"> 699 pre-compiled header file being recreated (different current directory) </H2>
<BR>The compiler has detected that the working directory is different so the contents of the pre-compiled header file cannot
be used.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="700_preMcompiled_header_file_being_recreated_Ldifferent_INCLUDE_pathR"> 700 pre-compiled header file being recreated (different INCLUDE path) </H2>
<BR>The compiler has detected that the INCLUDE path is different so the contents of the pre-compiled header file cannot be
used.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="701_preMcompiled_header_file_being_recreated_L__s__has_been_modifiedR"> 701 pre-compiled header file being recreated ('%s' has been modified) </H2>
<BR>The compiler has detected that an include file has changed so the contents of the pre-compiled header file cannot be used.
&nbsp;A new version of the pre-compiled header file will be created.
<H2 ID="702_preMcompiled_header_file_being_recreated_Lmacro___s__is_differentR"> 702 pre-compiled header file being recreated (macro '%s' is different) </H2>
<BR>The compiler has detected that a macro definition is different so the contents of the pre-compiled header file cannot
be used.&nbsp; The macro was referenced during processing of the header file that created the pre-compiled header file so
the contents of the pre-compiled header may be affected.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="703_preMcompiled_header_file_being_recreated_Lmacro___s__is_not_definedR"> 703 pre-compiled header file being recreated (macro '%s' is not defined) </H2>
<BR>The compiler has detected that a macro has not been defined so the contents of the pre-compiled header file cannot be
used.&nbsp; The macro was referenced during processing of the header file that created the pre-compiled header file so the
contents of the pre-compiled header may be affected.&nbsp; A new version of the pre-compiled header file will be created.
<H2 ID="704_command_line_specifies_smart_windows_callbacks_and_DS_not_equal_to_SS"> 704 command line specifies smart windows callbacks and DS not equal to SS </H2>
<BR>An illegal combination of switches has been detected.&nbsp; The windows smart callbacks option cannot be combined with
either of the build DLL or DS not equal to SS options.
<H2 ID="705_class___N__cannot_be_used_with__pragma_dump_object_model"> 705 class '%N' cannot be used with #pragma dump_object_model </H2>
<BR>The indicated name has not yet been declared or has been declared but not yet been defined as a class.&nbsp; Consequently,
the object model cannot be dumped.
<H2 ID="706_repeated_modifier_is___s_"> 706 repeated modifier is '%s' </H2>
<BR>This informational message indicates what modifier was repeated in the declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int __far FARINT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FARINT __far *p;&nbsp;&nbsp;&nbsp; // repeated __far modifier</TT>
<H2 ID="707_semicolon_L_S_R_may_be_missing_after_classDenum_definition"> 707 semicolon (';') may be missing after class/enum definition </H2>
<BR>This informational message indicates that a missing semicolon (';') may be the cause of the error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } // missing semicolon ';'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::S( int x, int y ) : x(x), y(y) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="708_cannot_return_a_type_of_unknown_size"> 708 cannot return a type of unknown size </H2>
<BR>A value of an unknown type cannot be returned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S foo();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int goo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, foo cannot be invoked because the class which it returns has not been defined.
<H2 ID="709_cannot_initialize_array_member___S_"> 709 cannot initialize array member '%S' </H2>
<BR>An array class member cannot be specified as a constructor initializer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int arr[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::S() : arr( 1, 2, 3 ) {}</TT>
<BR><BR>In the example,<TT> arr</TT> cannot be specified as a constructor initializer.&nbsp; Instead, the array may be initialized
within the body of the constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int arr[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S::S()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[0] = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[1] = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[2] = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="710_file___s__will__include_itself_forever"> 710 file '%s' will #include itself forever </H2>
<BR>The compiler has detected that the file in the message has been<B><I> #include</I></B> from within itself without protecting
against infinite inclusion.&nbsp; This can happen if<B><I> #ifndef</I></B> and<B><I> #define</I></B> header file protection
has not been used properly.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include __FILE__</TT>
<H2 ID="711__mutable__may_only_be_used_for_nonMstatic_class_members"> 711 'mutable' may only be used for non-static class members </H2>
<BR>A declaration in file scope or block scope cannot have a storage class of<B><I> mutable.</I></B>&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mutable int a;</TT>
<H2 ID="712__mutable__member_cannot_also_be_const"> 712 'mutable' member cannot also be const </H2>
<BR>A<B><I> mutable</I></B> member can be modified even if its class object is<B><I> const.</I></B>&nbsp; Due to the semantics
of<B><I> mutable,</I></B> the programmer must decide whether a member will be<B><I> const</I></B> or<B><I> mutable</I></B>
because it cannot be both at the same time.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutable const int * p;&nbsp; // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutable int * const q;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="713_left_operand_cannot_be_of_type_bool"> 713 left operand cannot be of type bool </H2>
<BR>The left hand side of an assignment operator cannot be of type<B><I> bool</I></B> except for simple assignment.&nbsp;
This is a restriction required in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bool q;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q += 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="714_operand_cannot_be_of_type_bool"> 714 operand cannot be of type bool </H2>
<BR>The operand of both postfix and prefix &quot;--&quot; operators cannot be of type<B><I> bool.</I></B>&nbsp; This is a
restriction required in the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bool q;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --q;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q--;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="715_member___N__has_not_been_declared_in___T_"> 715 member '%N' has not been declared in '%T' </H2>
<BR>The compiler has found a member which has not been previously declared.&nbsp; The symbol may be spelled differently than
the declaration, or the declaration may simply not be present.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct X { int m; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( X *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;x = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="716_integral_value_may_be_truncated"> 716 integral value may be truncated </H2>
<BR>This message indicates that the compiler knows that all values will not be preserved after the assignment or initialization.
&nbsp;If this is acceptable, cast the value to the appropriate type in the assignment or initialization.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char inc( char c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="717_left_operand_type_is___T_"> 717 left operand type is '%T' </H2>
<BR>This informational message indicates the type of the left hand side of the expression.
<H2 ID="718_right_operand_type_is___T_"> 718 right operand type is '%T' </H2>
<BR>This informational message indicates the type of the right hand side of the expression.
<H2 ID="719_operand_type_is___T_"> 719 operand type is '%T' </H2>
<BR>This informational message indicates the type of the operand.
<H2 ID="720_expression_type_is___T_"> 720 expression type is '%T' </H2>
<BR>This informational message indicates the type of the expression.
<H2 ID="721_virtual_function___S__cannot_have_its_return_type_changed"> 721 virtual function '%S' cannot have its return type changed </H2>
<BR>This restriction is due to the relatively new feature in the C++ language that allows return values to be changed when
a virtual function has been overridden.&nbsp; It is not possible to support both features because in order to support changing
the return value of a function, the compiler must construct a &quot;wrapper&quot; function that will call the virtual function
first and then change the return value and return.&nbsp; It is not possible to do this with &quot;...&quot; style functions
because the number of parameters is not known.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : virtual B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual B *fn( int, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Y : X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual D *fn( int, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="722___declspecL___N__R_is_not_supported"> 722 __declspec( '%N' ) is not supported </H2>
<BR>The identifier used in the<B><I> __declspec</I></B> declaration modifier is not supported by Open Watcom C++.
<H2 ID="723_attempt_to_construct_a_far_object_when_the_data_model_is_near"> 723 attempt to construct a far object when the data model is near </H2>
<BR>Constructors cannot be applied to objects which are stored in far memory when the default memory model for data is near.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Obj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Obj();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Obj far obj;</TT>
<BR><BR>The last line causes this error to be displayed when the memory model is small (switch -ms), since the memory model
for data is near.
<H2 ID="724_Mzo_is_an_obsolete_switch_Lhas_no_effectR"> 724 -zo is an obsolete switch (has no effect) </H2>
<BR>The<B><I> -zo</I></B> option was required in an earlier version of the compiler but is no longer used.
<H2 ID="725___s_"> 725 &quot;%s&quot; </H2>
<BR>This is a user message generated with the<B><I> #pragma</I></B> <B><I> message</I></B> preprocessing directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma message( &quot;my very own warning&quot; );</TT>
<H2 ID="726_no_reference_to_formal_parameter___S_"> 726 no reference to formal parameter '%S' </H2>
<BR>There are no references to the declared formal parameter.&nbsp; The simplest way to remove this warning in C++ is to remove
the name from the argument declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn1( int a, int b, int c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 'b' not referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int fn2( int a, int /* b */, int c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="727_cannot_dereference_a_pointer_to_void"> 727 cannot dereference a pointer to void </H2>
<BR>A pointer to<B><I> void</I></B> is used as a generic pointer but it cannot be dereferenced.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="728_class_modifiers_for___T__conflict_with_class_modifiers_for___T_"> 728 class modifiers for '%T' conflict with class modifiers for '%T' </H2>
<BR>A conflict between class modifiers for classes related through inheritance has been detected.&nbsp; A conflict will occur
if two base classes have class modifiers that are different.&nbsp; The conflict can be resolved by ensuring that all classes
related through inheritance have the same class modifiers.&nbsp; The default resolution is to have no class modifier for the
derived base.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct __cdecl B1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fn( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct __stdcall B2 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void fn( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B1, B2 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="729_invalid_hexadecimal_constant"> 729 invalid hexadecimal constant </H2>
<BR>The constant started with a '0x' prefix which makes it look like a hexadecimal constant but the constant was not followed
by any hexadecimal digits.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned i = 0x;&nbsp;&nbsp;&nbsp;&nbsp; // invalid hex constant</TT>
<H2 ID="730_return_type_of__operator_MY__will_not_allow__MY__to_be_applied"> 730 return type of 'operator -&gt;' will not allow '-&gt;' to be applied </H2>
<BR>This restriction is a result of the transformation that the compiler performs when the<B><I> operator -&gt;</I></B> is
overloaded.&nbsp; The transformation involves transforming the expression to invoke the operator with &quot;-&gt;&quot; applied
to the result of<B><I> operator -&gt;.</I></B>&nbsp; This warning indicates that the<B><I> operator -&gt;</I></B> can never
be used as an overloaded operator.&nbsp; The only way the operator can be used is to explicitly call it by name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *operator -&gt;();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void *fn( S &amp;q )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q.operator -&gt;();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="731_class_should_have_a_name_since_it_needs_a_constructor_or_a_destructor"> 731 class should have a name since it needs a constructor or a destructor </H2>
<BR>The class definition does not have a class name but it includes members that have constructors or destructors.&nbsp; Since
the class has C++ semantics, it should be have a name in case the constructor or destructor needs to be referenced.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct P {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int v;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } T;</TT>
<H2 ID="732_class_should_have_a_name_since_it_inherits_a_class"> 732 class should have a name since it inherits a class </H2>
<BR>The class definition does not have a class name but it inherits a class.&nbsp; Since the class has C++ semantics, it should
be have a name in case the constructor or destructor needs to be referenced.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct P {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x,y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct : P {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int v;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } T;</TT>
<H2 ID="733_cannot_open_preMcompiled_header_file___s_"> 733 cannot open pre-compiled header file '%s' </H2>
<BR>The compiler has detected a problem while trying to open the pre-compiled header file for read/write access.
<H2 ID="734_invalid_second_argument_to_va_start"> 734 invalid second argument to va_start </H2>
<BR>The second argument to the va_start macro should be the name of the argument just before the &quot;...&quot; in the argument
list.
<H2 ID="735__DD__style_comment_continues_on_next_line"> 735 '//' style comment continues on next line </H2>
<BR>The compiler has detected a line continuation during the processing of a C++ style comment (&quot;//&quot;).&nbsp; The
warning can be removed by switching to a C style comment (&quot;/**/&quot;).&nbsp; If you require the comment to be terminated
at the end of the line, make sure that the backslash character is not the last character in the line.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define XX 23 // comment start \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; comment \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x = XX; // comment start ...\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; comment end</TT>
<H2 ID="736_cannot_open_file___s__for_write_access"> 736 cannot open file '%s' for write access </H2>
<BR>The compiler has detected a problem while trying to open the indicated file for write access.
<H2 ID="737_implicit_conversion_of_pointers_to_integral_types_of_same_size"> 737 implicit conversion of pointers to integral types of same size </H2>
<BR>According to the ISO/ANSI Draft Working Paper, a string literal is an array of<B><I> char.</I></B>&nbsp; Consequently,
it is illegal to initialize or assign the pointer resulting from that literal to a pointer of either<B><I> unsigned char</I></B>
or<B><I> signed char,</I></B> since these pointers point at objects of a different type.
<H2 ID="738_option_requires_a_number"> 738 option requires a number </H2>
<BR>The specified option is not recognized by the compiler since there was no number after it (i.e., &quot;-w=1&quot;).&nbsp;
Numbers must be non-negative decimal numbers.
<H2 ID="739_option_Mfc_specified_more_than_once"> 739 option -fc specified more than once </H2>
<BR>The -fc option can be specified at most once on a command line.
<H2 ID="740_option_Mfc_specified_in_batch_file_of_commands"> 740 option -fc specified in batch file of commands </H2>
<BR>The -fc option cannot be specified on a line in the batch file of command lines specified by the -fc option on the command
line used to invoke the compiler.
<H2 ID="741_file_specified_by_Mfc_is_empty_or_cannot_be_read"> 741 file specified by -fc is empty or cannot be read </H2>
<BR>The file specified using the -fc option is either empty or an input/output error was diagnosed for the file.
<H2 ID="742_cannot_open_file_specified_by_Mfc_option"> 742 cannot open file specified by -fc option </H2>
<BR>The compiler was unable to open the indicated file.&nbsp; Most likely, the file does not exist.&nbsp; An input/output
error is also possible.
<H2 ID="743_inputDoutput_error_reading_the_file_specified_by_Mfc_option"> 743 input/output error reading the file specified by -fc option </H2>
<BR>The compiler was unable to open the indicated file.&nbsp; Most likely, the file does not exist.&nbsp; An input/output
error is also possible.
<H2 ID="744___N__does_not_have_a_return_type_specified_Lint_assumedR"> 744 '%N' does not have a return type specified (int assumed) </H2>
<BR>In C++, operator functions should have an explicit return type specified.&nbsp; In future revisions of the ISO/ANSI C++
standard, the use of default int type specifiers may be prohibited so removing any dependencies on default int early will
prevent problems in the future.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator = ( S const &amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator += ( S const &amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="745_cannot_initialize_reference_to_nonMconstant_with_a_constant_object"> 745 cannot initialize reference to non-constant with a constant object </H2>
<BR>A reference to a non-constant object cannot be initialized with a reference to a constant type because this would allow
constant data to be modified via the non-constant pointer to it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int *pic;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int &amp; ref = pic;</TT>
<H2 ID="746_processing__s"> 746 processing %s </H2>
<BR>This informational message indicates where an error or warning was detected while processing the switches specified on
the command line, in environment variables, in command files (using the '@' notation), or in the batch command file (specified
using the -fc option).
<H2 ID="747_class___T__has_not_been_defined"> 747 class '%T' has not been defined </H2>
<BR>This informational message indicates a class which was not defined.&nbsp; This is noted following an error or warning
message because it often helps to a user to determine the cause of that diagnostic.
<H2 ID="748_cannot_catch_undefined_class_object"> 748 cannot catch undefined class object </H2>
<BR>C++ does not allow abstract classes to be copied and so an undefined class object cannot be specified in a<B><I> catch</I></B>
clause.&nbsp; It is permissible to catch a reference to an undefined class.
<H2 ID="749_class___T__cannot_be_used_since_its_definition_has_errors"> 749 class '%T' cannot be used since its definition has errors </H2>
<BR>The analysis of the expression could not continue due to previous errors diagnosed in the class definition.
<H2 ID="750_function_prototype_in_block_scope_missing__extern_"> 750 function prototype in block scope missing 'extern' </H2>
<BR>This warning can be triggered when the intent is to define a variable with a constructor.&nbsp; Due to the complexities
of parsing C++, statements that appear to be variable definitions may actually parse as a function prototype.&nbsp; A work-around
for this problem is contained in the example.&nbsp; If a prototype is desired, add the<B><I> extern</I></B> storage class
to remove this warning.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S( C );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S a( C() ); // function prototype!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S b( (C()) );// variable definition</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bar( int );// warning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern int sam( int ); // no warning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="751_function_prototype_is___T_"> 751 function prototype is '%T' </H2>
<BR>This informational message indicates what the type of the function prototype is for the message in question.
<H2 ID="752_class___T__contains_a_zero_size_array"> 752 class '%T' contains a zero size array </H2>
<BR>This warning is triggered when a class with a zero sized array is used in an array or as a class member.&nbsp; This is
a questionable practice since a zero sized array at the end of a class often indicates a class that is dynamically sized when
it is constructed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C a[10];</TT>
<H2 ID="753_invalid__new__modifier"> 753 invalid 'new' modifier </H2>
<BR>The Open Watcom C++ compiler does not support new expression modifiers but allows them to match the ambient memory model
for compatibility.&nbsp; Invalid memory model modifiers are also rejected by the compiler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *fn( unsigned x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new __interrupt int[x];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="754____declspecLthreadR__data___S__must_be_linkMtime_initialized"> 754 '__declspec(thread)' data '%S' must be link-time initialized </H2>
<BR>This error message indicates that the data item in question either requires a constructor, destructor, or run-time initialization.
&nbsp;This cannot be supported for thread-specific data at this time.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~D();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C __declspec(thread) c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D __declspec(thread) d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __declspec(thread) e = rand();</TT>
<H2 ID="755_code_may_not_work_properly_if_this_module_is_split_across_a_code_segment"> 755 code may not work properly if this module is split across a code segment </H2>
<BR>The &quot;zm&quot; option allows the compiler to generate functions into separate segments that have different names so
that more than 64k of code can be generated in one object file.&nbsp; Unfortunately, if an explicit near function is coded
in a large code model, the possibility exists that the linker can place the near function in a separate code segment than
a function that calls it.&nbsp; This would cause a linker error followed by an execution error if the executable is executed.
&nbsp;The &quot;zmf&quot; option can be used if you require explicit near functions in your code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // These functions may not end up in the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // same code segment if the -zm option</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // is used. If this is the case, the near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // call will not work since near functions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // must be in the same code segment to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // execute properly.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int near near_fn( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int far_fn( int y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return near_fn( y * 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="756__pragma_extref__symbol___N__not_declared"> 756 #pragma extref:&nbsp; symbol '%N' not declared </H2>
<BR>This error message indicates that the symbol referenced by<B><I> #pragma extref</I></B> has not been declared in the context
where the pragma was encountered.
<H2 ID="757__pragma_extref__overloaded_function___S__cannot_be_used"> 757 #pragma extref:&nbsp; overloaded function '%S' cannot be used </H2>
<BR>An external reference can be emitted only for external functions which are not overloaded.
<H2 ID="758__pragma_extref____N__is_not_a_function_or_data"> 758 #pragma extref:&nbsp; '%N' is not a function or data </H2>
<BR>This error message indicates that the symbol referenced by<B><I> #pragma extref</I></B> cannot have an external reference
emitted for it because the referenced symbol is neither a function nor a data item.&nbsp; An external reference can be emitted
only for external functions which are not overloaded and for external data items.
<H2 ID="759__pragma_extref____S__is_not_external"> 759 #pragma extref:&nbsp; '%S' is not external </H2>
<BR>This error message indicates that the symbol referenced by<B><I> #pragma extref</I></B> cannot have an external reference
emitted for it because the symbol is not external.&nbsp; An external reference can be emitted only for external functions
which are not overloaded and for external data items.
<H2 ID="760_preMcompiled_header_file_being_recreated_Ldebugging_info_may_changeR"> 760 pre-compiled header file being recreated (debugging info may change) </H2>
<BR>The compiler has detected that the module being compiled was used to create debugging information for use by other modules.
&nbsp;In order to maintain correctness, the pre-compiled header file must be recreated along with the object file.
<H2 ID="761_octal_escape_sequence_out_of_rangeS_truncated"> 761 octal escape sequence out of range; truncated </H2>
<BR>This message indicates that the octal escape sequence produces an integer that cannot fit into the required character
type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *p = &quot;\406&quot;;</TT>
<H2 ID="762_binary_operator___s__missing_right_operand"> 762 binary operator '%s' missing right operand </H2>
<BR>There is no expression to the right of the indicated binary operator.
<H2 ID="763_binary_operator___s__missing_left_operand"> 763 binary operator '%s' missing left operand </H2>
<BR>There is no expression to the left of the indicated binary operator.
<H2 ID="764_expression_contains_extra_operandLsR"> 764 expression contains extra operand(s) </H2>
<BR>The expression contains operand(s) without an operator
<H2 ID="765_expression_contains_consecutive_operandLsR"> 765 expression contains consecutive operand(s) </H2>
<BR>More than one operand found in a row.
<H2 ID="766_unmatched_right_parenthesis__R_"> 766 unmatched right parenthesis ')' </H2>
<BR>The expression contains a right parenthesis &quot;)&quot; without a matching left parenthesis.
<H2 ID="767_unmatched_left_parenthesis__L_"> 767 unmatched left parenthesis '(' </H2>
<BR>The expression contains a left parenthesis &quot;(&quot; without a matching right parenthesis.
<H2 ID="768_no_expression_between_parentheses__L_R_"> 768 no expression between parentheses '( )' </H2>
<BR>There is a matching set of parenthesis &quot;()&quot; which do not contain an expression.
<H2 ID="769_expecting_____operator_in_conditional_expression"> 769 expecting ':' operator in conditional expression </H2>
<BR>A conditional expression exists without the ':' operator.
<H2 ID="770_expecting_____operator_in_conditional_expression"> 770 expecting '?' operator in conditional expression </H2>
<BR>A conditional expression exists without the '?' operator.
<H2 ID="771_expecting_first_operand_in_conditional_expression"> 771 expecting first operand in conditional expression </H2>
<BR>A conditional expression exists without the first operand.
<H2 ID="772_expecting_second_operand_in_conditional_expression"> 772 expecting second operand in conditional expression </H2>
<BR>A conditional expression exists without the second operand.
<H2 ID="773_expecting_third_operand_in_conditional_expression"> 773 expecting third operand in conditional expression </H2>
<BR>A conditional expression exists without the third operand.
<H2 ID="774_expecting_operand_after_unary_operator___s_"> 774 expecting operand after unary operator '%s' </H2>
<BR>A unary operator without being followed by an operand.
<H2 ID="775___s__unexpected_in_constant_expression"> 775 '%s' unexpected in constant expression </H2>
<BR>'%s' not allowed in constant expression
<H2 ID="776_assembler____s_"> 776 assembler:&nbsp; '%s' </H2>
<BR>A warning has been issued by the #pragma inline assembler.
<H2 ID="777_expecting__id__after______but_found___s_"> 777 expecting 'id' after '::' but found '%s' </H2>
<BR>The '::' operator has an invalid token following it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define fn( x ) ((x)+1)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inc( int y ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::fn( y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="778_only_constructors_can_be_declared_explicit"> 778 only constructors can be declared explicit </H2>
<BR>Currently, only constructors can be declared with the<B><I> explicit</I></B> keyword.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int explicit fn( int x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="779_const_cast_type_must_be_pointer__member_pointer__or_reference"> 779 const_cast type must be pointer, member pointer, or reference </H2>
<BR>The type specified in a<B><I> const_cast</I></B> operator must be a pointer, a pointer to a member of a class, or a reference.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long lp = const_cast&lt;long&gt;( p );</TT>
<H2 ID="780_const_cast_expression_must_be_pointer_to_same_kind_of_object"> 780 const_cast expression must be pointer to same kind of object </H2>
<BR>Ignoring<B><I> const</I></B> and<B><I> volatile</I></B> qualification, the expression must be a pointer to the same type
of object as that specified in the<B><I> const_cast</I></B> operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const * ip;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long* lp = const_cast&lt;long*&gt;( ip );</TT>
<H2 ID="781_const_cast_expression_must_be_lvalue_of_the_same_kind_of_object"> 781 const_cast expression must be lvalue of the same kind of object </H2>
<BR>Ignoring<B><I> const</I></B> and<B><I> volatile</I></B> qualification, the expression must be an lvalue or reference to
the same type of object as that specified in the<B><I> const_cast</I></B> operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&amp; lr = const_cast&lt;long&amp;&gt;( i );</TT>
<H2 ID="782_expression_must_be_pointer_to_member_from_same_class_in_const_cast"> 782 expression must be pointer to member from same class in const_cast </H2>
<BR>The expression must be a pointer to member from the same class as that specified in the<B><I> const_cast</I></B> operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : public B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const B::* imb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int D::* imd const_cast&lt;int D::*&gt;( imb );</TT>
<H2 ID="783_expression_must_be_member_pointer_to_same_type_as_specified_in_const_cast"> 783 expression must be member pointer to same type as specified in const_cast </H2>
<BR>Ignoring<B><I> const</I></B> and<B><I> volatile</I></B> qualification, the expression must be a pointer to member of the
same type as that specified in the<B><I> const_cast</I></B> operator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long lb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int D::* imd const_cast&lt;int D::*&gt;( &amp;B::lb );</TT>
<H2 ID="784_reinterpret_cast_expression_must_be_pointer_or_integral_object"> 784 reinterpret_cast expression must be pointer or integral object </H2>
<BR>When a pointer type is specified in the<B><I> reinterpret_cast</I></B> operator, the expression must be a pointer or an
integer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern float fval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long* lp = const_cast&lt;long*&gt;( fval );</TT>
<BR><BR>The expression has<B><I> float</I></B> type and so is illegal.
<H2 ID="785_reinterpret_cast_expression_cannot_be_casted_to_reference_type"> 785 reinterpret_cast expression cannot be casted to reference type </H2>
<BR>When a reference type is specified in the<B><I> reinterpret_cast</I></B> operator, the expression must be an lvalue (or
have reference type).&nbsp; Additionally, constness cannot be casted away.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern long f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const long f2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&amp; lr1 = const_cast&lt;long&amp;&gt;( f + 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&amp; lr2 = const_cast&lt;long&amp;&gt;( f2 );</TT>
<BR><BR>Both initializations are illegal.&nbsp; The first cast expression is not an lvalue.&nbsp; The second cast expression
attempts to cast away constness.
<H2 ID="786_reinterpret_cast_expression_cannot_be_casted_to_pointer_to_member"> 786 reinterpret_cast expression cannot be casted to pointer to member </H2>
<BR>When a pointer to member type is specified in the<B><I> reinterpret_cast</I></B> operator, the expression must be a pointer
to member.&nbsp; Additionally, constness cannot be casted away.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern long f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const long f2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long S::* mp1 = const_cast&lt;long S:: *&gt;( f );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long S::* mp2 = const_cast&lt;long S:: *&gt;( &amp;S::f2 );</TT>
<BR><BR>Both initializations are illegal.&nbsp; The first cast expression does not involve a member pointer.&nbsp; The second
cast expression attempts to cast away constness.
<H2 ID="787_only_integral_arithmetic_types_can_be_used_with_reinterpret_cast"> 787 only integral arithmetic types can be used with reinterpret_cast </H2>
<BR>Pointers can only be casted to sufficiently large integral types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = reinterpret_cast&lt;float&gt;( p );</TT>
<BR><BR>The cast is illegal because<B><I> float</I></B> type is specified.
<H2 ID="788_only_integral_arithmetic_types_can_be_used_with_reinterpret_cast"> 788 only integral arithmetic types can be used with reinterpret_cast </H2>
<BR>Only integral arithmetic types can be casted to pointer types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float flt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p = reinterpret_cast&lt;void*&gt;( flt );</TT>
<BR><BR>The cast is illegal because<TT> flt</TT> has<B><I> float</I></B> type which is not integral.
<H2 ID="789_cannot_cast_away_constness"> 789 cannot cast away constness </H2>
<BR>A cast or implicit conversion is illegal because a conversion to the target type would remove constness from a pointer,
reference, or pointer to member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern S const * ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const S::* mps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S* ps1 = ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&amp; rs1 = *ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* mp1 = mps;</TT>
<BR><BR>The three initializations are illegal since they are attempts to remove constness.
<H2 ID="790_size_of_integral_type_in_cast_less_than_size_of_pointer"> 790 size of integral type in cast less than size of pointer </H2>
<BR>An object of the indicated integral type is too small to contain the value of the indicated pointer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char p = reinterpret_cast&lt;char&gt;( &amp;x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char q = (char)( &amp;x );</TT>
<BR><BR>Both casts are illegal since a<B><I> char</I></B> is smaller than a pointer.
<H2 ID="791_type_cannot_be_used_in_reinterpret_cast"> 791 type cannot be used in reinterpret_cast </H2>
<BR>The type specified with reinterpret_cast must be an integral type, a pointer type, a pointer to a member of a class, or
a reference type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = reinterpret_cast&lt;float&gt;( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* q = ( reinterpret_cast&lt;void&gt;( p ), p );</TT>
<BR><BR>The casts specify illegal types.
<H2 ID="792_only_pointers_can_be_casted_to_integral_types_with_reinterpret_cast"> 792 only pointers can be casted to integral types with reinterpret_cast </H2>
<BR>The expression must be a pointer type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float f = reinterpret_cast&lt;float&gt;( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* q = ( reinterpret_cast&lt;void&gt;( p ), p );</TT>
<BR><BR>The casts specify illegal types.
<H2 ID="793_only_integers_and_pointers_can_be_casted_to_pointer_types_with_reinterpret_cast"> 793 only integers and pointers can be casted to pointer types with reinterpret_cast </H2>
<BR>The expression must be a pointer or integral type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p = reinterpret_cast&lt;void*&gt;( 16 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* q = ( reinterpret_cast&lt;void*&gt;( x ), p );</TT>
<BR><BR>The casts specify illegal types.
<H2 ID="794_static_cast_cannot_convert_the_expression"> 794 static_cast cannot convert the expression </H2>
<BR>The indicated expression cannot be converted to the type specified with the<B><I> static_cast</I></B> operator.&nbsp;
Perhaps reinterpret_cast or dynamic_cast should be used instead;
<H2 ID="795_static_cast_cannot_be_used_with_the_type_specified"> 795 static_cast cannot be used with the type specified </H2>
<BR>A static cast cannot be used with a function type or array type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int fun( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int poo( long );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = ( static_cast&lt;fun)( poo ) )( 22 );</TT>
<BR><BR>Perhaps reinterpret_cast or dynamic_cast should be used instead;
<H2 ID="796_static_cast_cannot_be_used_with_the_reference_type_specified"> 796 static_cast cannot be used with the reference type specified </H2>
<BR>The expression could not be converted to the specified type using static_cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long lng;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&amp; ref = static_cast&lt;int&amp;&gt;( lng );</TT>
<BR><BR>Perhaps reinterpret_cast or dynamic_cast should be used instead;
<H2 ID="797_static_cast_cannot_be_used_with_the_pointer_type_specified"> 797 static_cast cannot be used with the pointer type specified </H2>
<BR>The expression could not be converted to the specified type using static_cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long lng;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int* ref = static_cast&lt;int*&gt;( lng );</TT>
<BR><BR>Perhaps reinterpret_cast or dynamic_cast should be used instead;
<H2 ID="798_static_cast_cannot_be_used_with_the_member_pointer_type_specified"> 798 static_cast cannot be used with the member pointer type specified </H2>
<BR>The expression could not be converted to the specified type using static_cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long lng;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* mp = static_cast&lt;int S::*&gt;( &amp;S::lng );</TT>
<BR><BR>Perhaps reinterpret_cast or dynamic_cast should be used instead;
<H2 ID="799_static_cast_type_is_ambiguous"> 799 static_cast type is ambiguous </H2>
<BR>More than one constructor and/or used-defined conversion function can be used to convert the expression to the indicated
type.
<H2 ID="800_cannot_cast_from_ambiguous_base_class"> 800 cannot cast from ambiguous base class </H2>
<BR>When more than one base class of a given type exists, with respect to a derived class, it is impossible to cast from the
base class to the derived class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base { int b1; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DerA public Base { int da; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DerB public Base { int db; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived public DerA, public DerB { int d; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived* foo( Base* p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return static_cast&lt;Derived*&gt;( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The cast fails since<TT> Base</TT> is an ambiguous base class for<TT> Derived.</TT>
<H2 ID="801_cannot_cast_to_ambiguous_base_class"> 801 cannot cast to ambiguous base class </H2>
<BR>When more than one base class of a given type exists, with respect to a derived class, it is impossible to cast from the
derived class to the base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Base { int b1; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DerA public Base { int da; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DerB public Base { int db; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived public DerA, public DerB { int d; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Base* foo( Derived* p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (Base*)p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The cast fails since<TT> Base</TT> is an ambiguous base class for<TT> Derived.</TT>
<H2 ID="802_can_only_static_cast_integers_to_enumeration_type"> 802 can only static_cast integers to enumeration type </H2>
<BR>When an enumeration type is specified with<B><I> static_cast,</I></B> the expression must be an integer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum sex { male, female };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sex father = static_cast&lt;sex&gt;( 1.0 );</TT>
<BR><BR>The cast is illegal because the expression is not an integer.
<H2 ID="803_dynamic_cast_cannot_be_used_with_the_type_specified"> 803 dynamic_cast cannot be used with the type specified </H2>
<BR>A dynamic cast can only specify a reference to a class or a pointer to a class or<B><I> void.</I></B>&nbsp; When a class
is referenced, it must have virtual functions defined within that class or a base class of that class.
<H2 ID="804_dynamic_cast_cannot_convert_the_expression"> 804 dynamic_cast cannot convert the expression </H2>
<BR>The indicated expression cannot be converted to the type specified with the<B><I> dynamic_cast</I></B> operator.&nbsp;
Only a pointer or reference to a class object can be converted.&nbsp; When a class object is referenced, it must have virtual
functions defined within that class or a base class of that class.
<H2 ID="805_dynamic_cast_requires_class___T__to_have_virtual_functions"> 805 dynamic_cast requires class '%T' to have virtual functions </H2>
<BR>The indicated class must have virtual functions defined within that class or a base class of that class.
<H2 ID="806_base_class_for_type_in_dynamic_cast_is_ambiguous_Lwill_failR"> 806 base class for type in dynamic_cast is ambiguous (will fail) </H2>
<BR>The type in the<B><I> dynamic_cast</I></B> is a pointer or reference to an ambiguous base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { virtual void f(){}; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D1 : A { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D2 : A { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : D1, D2 { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A *foo( D *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will always return NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( dynamic_cast&lt; A* &gt;( p ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="807_base_class_for_type_in_dynamic_cast_is_private_Lmay_failR"> 807 base class for type in dynamic_cast is private (may fail) </H2>
<BR>The type in the<B><I> dynamic_cast</I></B> is a pointer or reference to a private base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct V { virtual void f(){}; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A : private virtual V { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : public virtual V, A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; V *foo( A *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns NULL if 'p' points to an 'A'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns non-NULL if 'p' points to a 'D'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( dynamic_cast&lt; V* &gt;( p ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="808_base_class_for_type_in_dynamic_cast_is_protected_Lmay_failR"> 808 base class for type in dynamic_cast is protected (may fail) </H2>
<BR>The type in the<B><I> dynamic_cast</I></B> is a pointer or reference to a protected base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct V { virtual void f(){}; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A : protected virtual V { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : public virtual V, A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; V *foo( A *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns NULL if 'p' points to an 'A'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns non-NULL if 'p' points to a 'D'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( dynamic_cast&lt; V* &gt;( p ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="809_type_cannot_be_used_with_an_explicit_cast"> 809 type cannot be used with an explicit cast </H2>
<BR>The indicated type cannot be specified as the type of an explicit cast.&nbsp; For example, it is illegal to cast to an
array or function type.
<H2 ID="810_cannot_cast_to_an_array_type"> 810 cannot cast to an array type </H2>
<BR>It is not permitted to cast to an array type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int array_type[5];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array[5];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int* p = (array_type)array;</TT>
<H2 ID="811_cannot_cast_to_a_function_type"> 811 cannot cast to a function type </H2>
<BR>It is not permitted to cast to a function type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int fun_type( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void* p = (fun_type)0;</TT>
<H2 ID="812_implementation_restriction__cannot_generate_RTTI_info_for___T__L_d_classesR"> 812 implementation restriction:&nbsp; cannot generate RTTI info for '%T' (%d classes) </H2>
<BR>The information for one class must fit into one segment.&nbsp; If the segment size is restricted to 64k, the compiler
may not be able to emit the correct information properly if it requires more than 64k of memory to represent the class hierarchy.
<H2 ID="813_more_than_one_default_constructor_for___T_"> 813 more than one default constructor for '%T' </H2>
<BR>The compiler found more than one default constructor signature in the class definition.&nbsp; There must be only one constructor
declared that accepts no arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C( int = 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C cv;</TT>
<H2 ID="814_userMdefined_conversion_is_ambiguous"> 814 user-defined conversion is ambiguous </H2>
<BR>The compiler found more than one user-defined conversion which could be performed.&nbsp; The indicated functions that
could be used are shown.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T( S const&amp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator T const&amp; ();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern S sv;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; T const &amp; tref = sv;</TT>
<BR><BR>Either the constructor or the conversion function could be used; consequently, the conversion is ambiguous.
<H2 ID="815_range_of_possible_values_for_type___T__is__s_to__s"> 815 range of possible values for type '%T' is %s to %s </H2>
<BR>This informational message indicates the range of values possible for the indicated unsigned type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char uc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( uc &gt;= 0 );</TT>
<BR><BR>Being unsigned, the char is always &gt;= 0, so a warning will be issued.&nbsp; Following the warning, this informational
message indicates the possible range of values for the unsigned type involved.
<H2 ID="816_range_of_possible_values_for_type___T__is__s_to__s"> 816 range of possible values for type '%T' is %s to %s </H2>
<BR>This informational message indicates the range of values possible for the indicated signed type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed char c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( c &lt;= 127 );</TT>
<BR><BR>Because the value of signed char is always &lt;= 127, a warning will be issued.&nbsp; Following the warning, this
informational message indicates the possible range of values for the signed type involved.
<H2 ID="817_constant_expression_in_comparison_has_value__s"> 817 constant expression in comparison has value %s </H2>
<BR>This informational message indicates the value of the constant expression involved in a comparison which caused a warning
to be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char uc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( uc &gt;= 0 );</TT>
<BR><BR>Being unsigned, the char is always &gt;= 0, so a warning will be issued.&nbsp; Following the warning, this informational
message indicates the constant value (0 in this case) involved in the comparison.
<H2 ID="818_constant_expression_in_comparison_has_value__s"> 818 constant expression in comparison has value %s </H2>
<BR>This informational message indicates the value of the constant expression involved in a comparison which caused a warning
to be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed char c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( c &lt;= 127 );</TT>
<BR><BR>Because the value of char is always &lt;= 127, a warning will be issued.&nbsp; Following the warning, this informational
message indicates the constant value (127 in this case) involved in the comparison.
<H2 ID="819_conversion_of_const_reference_to_nonMconst_reference"> 819 conversion of const reference to non-const reference </H2>
<BR>A reference to a constant object is being converted to a reference to a non-constant object.&nbsp; This can only be accomplished
by using an explicit or<TT> const_cast</TT> cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const &amp; const_ref;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp; non_const_ref = const_ref;</TT>
<H2 ID="820_conversion_of_volatile_reference_to_nonMvolatile_reference"> 820 conversion of volatile reference to non-volatile reference </H2>
<BR>A reference to a volatile object is being converted to a reference to a non-volatile object.&nbsp; This can only be accomplished
by using an explicit or<TT> const_cast</TT> cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int volatile &amp; volatile_ref;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp; non_volatile_ref = volatile_ref;</TT>
<H2 ID="821_conversion_of_const_volatile_reference_to_plain_reference"> 821 conversion of const volatile reference to plain reference </H2>
<BR>A reference to a constant and volatile object is being converted to a reference to a non-volatile and non-constant object.
&nbsp;This can only be accomplished by using an explicit or<TT> const_cast</TT> cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const volatile &amp; const_volatile_ref;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int &amp; non_const_volatile_ref = const_volatile_ref;</TT>
<H2 ID="822_current_declaration_has_type___T_"> 822 current declaration has type '%T' </H2>
<BR>This informational message indicates the type of the current declaration that caused the message to be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __near foo( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __far foo( int );</TT>
<H2 ID="823_only_a_nonMvolatile_const_reference_can_be_bound_to_temporary"> 823 only a non-volatile const reference can be bound to temporary </H2>
<BR>The expression being bound to a reference will need to be converted to a temporary of the type referenced.&nbsp; This
means that the reference will be bound to that temporary and so the reference must be a non-volatile const reference.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int * pi;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * &amp; r1 = pi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * const &amp; r2 = pi;&nbsp;&nbsp;&nbsp;&nbsp; // ok</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * volatile &amp; r3 = pi;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * const volatile &amp; r4 = pi;// error</TT>
<H2 ID="824_conversion_of_pointer_to_member_across_a_virtual_base"> 824 conversion of pointer to member across a virtual base </H2>
<BR>In November 1995, the Draft Working Paper was amended to disallow pointer to member conversions when the source class
is a virtual base of the target class.&nbsp; This situation is treated as a warning (unless -za is specified to require strict
conformance), as a temporary measure.&nbsp; In the future, an error will be diagnosed for this situation.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : virtual B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int B::* mp_b = &amp;B::b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int D::* mp_d = mp_b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // conversion across a virtual
base</TT>
<H2 ID="825_declaration_cannot_be_in_the_same_scope_as_namespace___S_"> 825 declaration cannot be in the same scope as namespace '%S' </H2>
<BR>A namespace name must be unique across the entire C++ program.&nbsp; Any other use of a name cannot be in the same scope
as the namespace.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace x {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<H2 ID="826___S__cannot_be_in_the_same_scope_as_a_namespace"> 826 '%S' cannot be in the same scope as a namespace </H2>
<BR>A namespace name must be unique across the entire C++ program.&nbsp; Any other use of a name cannot be in the same scope
as the namespace.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace x {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="827_File___s"> 827 File:&nbsp; %s </H2>
<BR>This informative message is written when the -ew switch is specified on a command line.&nbsp; It indicates the name of
the file in which an error or warning was detected.&nbsp; The message precedes a group of one or more messages written for
the file in question.&nbsp; Within each group, references within the file have the format<TT> (line[,column]).</TT>
<H2 ID="828__s"> 828 %s </H2>
<BR>This informative message is written when the -ew switch is specified on a command line.&nbsp; It indicates the location
of an error when the error was detected either before or after the source file was read during the compilation process.
<H2 ID="829__s___s"> 829 %s:&nbsp; %s </H2>
<BR>This informative message is written when the -ew switch is specified on a command line.&nbsp; It indicates the location
of an error when the error was detected while processing the switches specified in a command file or by the contents of an
environment variable.&nbsp; The switch that was being processed is displayed following the name of the file or the environment
variable.
<H2 ID="830__s___S"> 830 %s:&nbsp; %S </H2>
<BR>This informative message is written when the -ew switch is specified on a command line.&nbsp; It indicates the location
of an error when the error was detected while generating a function, such as a constructor, destructor, or assignment operator
or while generating the machine instructions for a function which has been analysed.&nbsp; The name of the function is given
following text indicating the context from which the message originated.
<H2 ID="831_possible_override_is___S_"> 831 possible override is '%S' </H2>
<BR>The indicated function is ambiguous since that name was defined in more than one base class and one or more of these functions
is virtual.&nbsp; Consequently, it cannot be decided which is the virtual function to be used in a class derived from these
base classes.
<H2 ID="832_function_being_overridden_is___S_"> 832 function being overridden is '%S' </H2>
<BR>This informational message indicates a function which cannot be overridden by a virtual function which has ellipsis parameters.
<H2 ID="833_name_does_not_reference_a_namespace"> 833 name does not reference a namespace </H2>
<BR>A<B><I> namespace</I></B> alias definition must reference a<B><I> namespace</I></B> definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace a = T;</TT>
<H2 ID="834_namespace_alias_cannot_be_changed"> 834 namespace alias cannot be changed </H2>
<BR>A<B><I> namespace</I></B> alias definition cannot change which<B><I> namespace</I></B> it is referencing.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace ns1 { int x; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace ns2 { int x; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace a = ns1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace a = ns2;</TT>
<H2 ID="835_cannot_throw_undefined_class_object"> 835 cannot throw undefined class object </H2>
<BR>C++ does not allow undefined classes to be copied and so an undefined class object cannot be specified in a<B><I> throw</I></B>
expression.
<H2 ID="836_symbol_has_different_type_than_previous_symbol_in_same_declaration"> 836 symbol has different type than previous symbol in same declaration </H2>
<BR>This warning indicates that two symbols in the same declaration have different types.&nbsp; This may be intended but it
is often due to a misunderstanding of the C++ declaration syntax.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // change to:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; char q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // or:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; char *p, *q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char* p, q;</TT>
<H2 ID="837_companion_definition_is___S_"> 837 companion definition is '%S' </H2>
<BR>This informational message indicates the other symbol that shares a common base type in the same declaration.
<H2 ID="838_syntax_errorS_default_argument_cannot_be_processed"> 838 syntax error; default argument cannot be processed </H2>
<BR>The default argument contains unbalanced braces or parenthesis.&nbsp; The default argument cannot be processed in this
form.
<H2 ID="839_default_argument_started__L"> 839 default argument started %L </H2>
<BR>This informational message indicates where the default argument started so that any problems with missing braces or parenthesis
can be fixed quickly and easily.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f( int t= (4+(3-7), // missing parenthesis</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="840___N__cannot_be_declared_in_a_namespace"> 840 '%N' cannot be declared in a namespace </H2>
<BR>A<B><I> namespace</I></B> cannot contain declarations or definitions of<B><I> operator new</I></B> or<B><I> operator delete</I></B>
since they will never be called implicitly in a<B><I> new</I></B> or<B><I> delete</I></B> expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace N {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *operator new( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void operator delete( void * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="841_namespace_cannot_be_defined_in_a_nonMnamespace_scope"> 841 namespace cannot be defined in a non-namespace scope </H2>
<BR>A<B><I> namespace</I></B> can only be defined in either the global namespace scope (file scope) or a namespace scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namespace N {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="842_namespace______qualifier_cannot_be_used_in_this_context"> 842 namespace '::' qualifier cannot be used in this context </H2>
<BR>Qualified identifiers in a class context are allowed for declaring<B><I> friend</I></B> functions.&nbsp; A<B><I> namespace</I></B>
qualified name can only be declared in a namespace scope that encloses the qualified name's namespace.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace M {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namespace N {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void g();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namespace O {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void N::f() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void N::g() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="843_cannot_cast_away_volatility"> 843 cannot cast away volatility </H2>
<BR>A cast or implicit conversion is illegal because a conversion to the target type would remove volatility from a pointer,
reference, or pointer to member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern S volatile * ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int volatile S::* mps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S* ps1 = ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&amp; rs1 = *ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* mp1 = mps;</TT>
<BR><BR>The three initializations are illegal since they are attempts to remove volatility.
<H2 ID="844_cannot_cast_away_constness_and_volatility"> 844 cannot cast away constness and volatility </H2>
<BR>A cast or implicit conversion is illegal because a conversion to the target type would remove constness and volatility
from a pointer, reference, or pointer to member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern S const volatile * ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int const volatile S::* mps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S* ps1 = ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&amp; rs1 = *ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* mp1 = mps;</TT>
<BR><BR>The three initializations are illegal since they are attempts to remove constness and volatility.
<H2 ID="845_cannot_cast_away_unaligned"> 845 cannot cast away unaligned </H2>
<BR>A cast or implicit conversion is illegal because a conversion to the target type would add alignment to a pointer, reference,
or pointer to member.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern S _unaligned * ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int _unaligned S::* mps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S* ps1 = ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&amp; rs1 = *ps;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int S::* mp1 = mps;</TT>
<BR><BR>The three initializations are illegal since they are attempts to add alignment.
<H2 ID="846_subscript_expression_must_be_integral"> 846 subscript expression must be integral </H2>
<BR>Both of the operands of the indicated index expression are pointers.&nbsp; There may be a missing indirection or function
call.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int g() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p[f];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="847_extension__nonMstandard_userMdefined_conversion"> 847 extension:&nbsp; non-standard user-defined conversion </H2>
<BR>An extended conversion was allowed.&nbsp; The latest draft of the C++ working paper does not allow a user-defined conversion
to be used in this context.&nbsp; As an extension, the WATCOM compiler supports the conversion since substantial legacy code
would not compile without the extension.
<H2 ID="848_useless_using_directive_ignored"> 848 useless using directive ignored </H2>
<BR>This warning indicates that for most purposes, the<B><I> using namespace</I></B> directive can be removed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using namespace A;&nbsp; // useless</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="849_base_class_virtual_function_has_not_been_overridden"> 849 base class virtual function has not been overridden </H2>
<BR>This warning indicates that a virtual function name has been overridden but in an incomplete manner, namely, a virtual
function signature has been omitted in the overriding class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f() const;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="850_virtual_function_is___S_"> 850 virtual function is '%S' </H2>
<BR>This message indicates which virtual function has not been overridden.
<H2 ID="851_macro___s__defined__L"> 851 macro '%s' defined %L </H2>
<BR>This informational message indicates where the macro in question was defined.&nbsp; The message is displayed following
an error or warning diagnostic for the macro in question.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define mac(a,b,c) a+b+c</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = mac(6,7,8,9,10);</TT>
<BR><BR>The expansion of macro<TT> mac</TT> is erroneous because it contains too many arguments.&nbsp; The informational message
will indicate where the macro was defined.
<H2 ID="852_expanding_macro___s__defined__L"> 852 expanding macro '%s' defined %L </H2>
<BR>These informational messages indicate the macros that are currently being expanded, along with the location at which they
were defined.&nbsp; The message(s) are displayed following a diagnostic which is issued during macro expansion.
<H2 ID="853_conversion_to_common_class_type_is_impossible"> 853 conversion to common class type is impossible </H2>
<BR>The conversion to a common class is impossible.&nbsp; One or more of the left and right operands are class types.&nbsp;
The informational messages indicate these types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class A { A(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class B { B(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern A a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern B b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = ( a == b );</TT>
<BR><BR>The last statement is erroneous since a conversion to a common class type is impossible.
<H2 ID="854_conversion_to_common_class_type_is_ambiguous"> 854 conversion to common class type is ambiguous </H2>
<BR>The conversion to a common class is ambiguous.&nbsp; One or more of the left and right operands are class types.&nbsp;
The informational messages indicate these types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class A { A(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class B : public A { B(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C : public A { C(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class D : public B, public C { D(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern A a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern D d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = ( a == d );</TT>
<BR><BR>The last statement is erroneous since a conversion to a common class type is ambiguous.
<H2 ID="855_conversion_to_common_class_type_requires_private_access"> 855 conversion to common class type requires private access </H2>
<BR>The conversion to a common class violates the access permission which was private.&nbsp; One or more of the left and right
operands are class types.&nbsp; The informational messages indicate these types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class A { A(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class B : private A { B(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern A a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern B b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = ( a == b );</TT>
<BR><BR>The last statement is erroneous since a conversion to a common class type violates the (private) access permission.
<H2 ID="856_conversion_to_common_class_type_requires_protected_access"> 856 conversion to common class type requires protected access </H2>
<BR>The conversion to a common class violates the access permission which was protected.&nbsp; One or more of the left and
right operands are class types.&nbsp; The informational messages indicate these types.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class A { A(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class B : protected A { B(); };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern A a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern B b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = ( a == b );</TT>
<BR><BR>The last statement is erroneous since a conversion to a common class type violates the (protected) access permission.
<H2 ID="857_namespace_lookup_is_ambiguous"> 857 namespace lookup is ambiguous </H2>
<BR>A lookup for a name resulted in two or more non-function names being found.&nbsp; This is not allowed according to the
C++ working paper.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace M {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace N {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using namespace M;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void f() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using namespace N;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7;&nbsp; // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="858_ambiguous_namespace_symbol_is___S_"> 858 ambiguous namespace symbol is '%S' </H2>
<BR>This informational message shows a symbol that conflicted with another symbol during a lookup.
<H2 ID="859_attempt_to_static_cast_from_a_private_base_class"> 859 attempt to static_cast from a private base class </H2>
<BR>An attempt was made to static_cast a pointer or reference to a private base class to a derived class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct PrivateBase {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : private PrivateBase {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern PrivateBase* pb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern PrivateBase&amp; rb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived* pd = static_cast&lt;Derived*&gt;( pb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived&amp; rd = static_cast&lt;Derived&amp;&gt;( rb );</TT>
<BR><BR>The last two statements are erroneous since they would involve a<B><I> static_cast</I></B> from a private base class.
<H2 ID="860_attempt_to_static_cast_from_a_protected_base_class"> 860 attempt to static_cast from a protected base class </H2>
<BR>An attempt was made to static_cast a pointer or reference to a protected base class to a derived class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct ProtectedBase {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct Derived : protected ProtectedBase {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern ProtectedBase* pb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern ProtectedBase&amp; rb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived* pd = static_cast&lt;Derived*&gt;( pb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Derived&amp; rd = static_cast&lt;Derived&amp;&gt;( rb );</TT>
<BR><BR>The last two statements are erroneous since they would involve a<B><I> static_cast</I></B> from a protected base class.
<H2 ID="861_qualified_symbol_cannot_be_defined_in_this_scope"> 861 qualified symbol cannot be defined in this scope </H2>
<BR>This message indicates that the scope of the symbol is not nested in the current scope.&nbsp; This is a restriction in
the C++ language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void ok();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void bad();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void ok();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void bad();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void A::S::ok() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void A::ok() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void A::S::bad() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void A::bad() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="862_using_declaration_references_nonMmember"> 862 using declaration references non-member </H2>
<BR>This message indicates that the entity referenced by the<B><I> using</I></B> declaration is not a class member even though
the<B><I> using</I></B> declaration is in class scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using B::x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="863_using_declaration_references_class_member"> 863 using declaration references class member </H2>
<BR>This message indicates that the entity referenced by the<B><I> using</I></B> declaration is a class member even though
the<B><I> using</I></B> declaration is not in class scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; using B::m;</TT>
<H2 ID="864_invalid_suffix_for_a_constant"> 864 invalid suffix for a constant </H2>
<BR>An invalid suffix was coded for a constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __int64 a[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i7, // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i8,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i15, // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i16,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i31, // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i32,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i63, // error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0i64,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="865_class_in_using_declaration_L__T_R_must_be_a_base_class"> 865 class in using declaration ('%T') must be a base class </H2>
<BR>A<B><I> using</I></B> declaration declared in a class scope can only reference entities in a base class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int g;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : private C {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B::f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="866_name_in_using_declaration_is_already_in_scope"> 866 name in using declaration is already in scope </H2>
<BR>A<B><I> using</I></B> declaration can only reference entities in other scopes.&nbsp; It cannot reference entities within
its own scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using B::f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="867_conflict_with_a_previous_usingMdecl___S_"> 867 conflict with a previous using-decl '%S' </H2>
<BR>A<B><I> using</I></B> declaration can only reference entities in other scopes.&nbsp; It cannot reference entities within
its own scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using B::f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="868_conflict_with_current_usingMdecl___S_"> 868 conflict with current using-decl '%S' </H2>
<BR>A<B><I> using</I></B> declaration can only reference entities in other scopes.&nbsp; It cannot reference entities within
its own scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using B::f;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="869_use_of___N__requires_build_target_to_be_multiMthreaded"> 869 use of '%N' requires build target to be multi-threaded </H2>
<BR>The compiler has detected a use of a run-time function that will create a new thread but the current build target indicates
only single-threaded C++ source code is expected.&nbsp; Depending on the user's environment, enabling multi-threaded applications
can involve using the &quot;-bm&quot; option or selecting multi-threaded applications through a dialogue.
<H2 ID="870_implementation_restriction__cannot_use_64Mbit_value_in_switch_statement"> 870 implementation restriction:&nbsp; cannot use 64-bit value in switch statement </H2>
<BR>The use of 64-bit values in switch statements has not been implemented.
<H2 ID="871_implementation_restriction__cannot_use_64Mbit_value_in_case_statement"> 871 implementation restriction:&nbsp; cannot use 64-bit value in case statement </H2>
<BR>The use of 64-bit values in case statements has not been implemented.
<H2 ID="872_implementation_restriction__cannot_use___int64_as_bitMfield_base_type"> 872 implementation restriction:&nbsp; cannot use __int64 as bit-field base type </H2>
<BR>The use of<B><I> __int64</I></B> for the base type of a bit-field has not been implemented.
<H2 ID="873_based_function_object_cannot_be_placed_in_nonMcode_segment___s__"> 873 based function object cannot be placed in non-code segment &quot;%s&quot;. </H2>
<BR>Use<B><I> __segname</I></B> with the default code segment &quot;_CODE&quot;, or a code segment with the appropriate suffix
(indicated by informational message).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based(__segname(&quot;foo&quot;)) f() {return 1;}</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based(__segname(&quot;_CODE&quot;)) f() {return 1;}</TT>
<H2 ID="874_Use_a_segment_name_ending_in___s___or_the_default_code_segment___CODE__"> 874 Use a segment name ending in &quot;%s&quot;, or the default code segment &quot;_CODE&quot;. </H2>
<BR>This informational message explains how to use<B><I> __segname</I></B> to name a code segment.
<H2 ID="875_RTTI_must_be_enabled_to_use_feature_Luse__xr__optionR"> 875 RTTI must be enabled to use feature (use 'xr' option) </H2>
<BR>RTTI must be enabled by specifying the 'xr' option when the compiler is invoked.&nbsp; The error message indicates that
a feature such as<B><I> dynamic_cast,</I></B> or<B><I> typeid</I></B> has been used without enabling RTTI.
<H2 ID="876__typeid__class_type_must_be_defined"> 876 'typeid' class type must be defined </H2>
<BR>The compile-time type of the expression or type must be completely defined if it is a class type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( S *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeid( *p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeid( S );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="877_cast_involves_unrelated_member_pointers"> 877 cast involves unrelated member pointers </H2>
<BR>This warning is issued to indicate that a dangerous cast of a member pointer has been used.&nbsp; This occurs when there
is an explicit cast between sufficiently unrelated types of member pointers that the cast must be implemented using a reinterpret_cast.
&nbsp;These casts were illegal, but became legal when the new-style casts were added to the draft working paper.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int poo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int (C1::* C1mp )();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C1mp fmp = (C1mp)&amp;D1::poo;</TT>
<BR><BR>The cast on the last line of the example would be diagnosed.
<H2 ID="878_unexpected_type_modifier_found"> 878 unexpected type modifier found </H2>
<BR>A<B><I> __declspec</I></B> modifier was found that could not be applied to an object or could not be used in this context.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __declspec(thread) struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="879_invalid_bitMfield_name___N_"> 879 invalid bit-field name '%N' </H2>
<BR>A bit-field can only have a simple identifier as its name.&nbsp; A qualified name is also not allowed for a bit-field.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator + : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="880__u_padding_byteLsR_added"> 880 %u padding byte(s) added </H2>
<BR>This warning indicates that some extra bytes have been added to a class in order to align member data to its natural alignment.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack(push,8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack(pop);</TT>
<H2 ID="881_cannot_be_called_with_a___T_T_"> 881 cannot be called with a '%T *' </H2>
<BR>This message indicates that the virtual function cannot be called with a pointer or reference to the current class.
<H2 ID="882_cast_involves_an_undefined_member_pointer"> 882 cast involves an undefined member pointer </H2>
<BR>This warning is issued to indicate that a dangerous cast of a member pointer has been used.&nbsp; This occurs when there
is an explicit cast between sufficiently unrelated types of member pointers that the cast must be implemented using a reinterpret_cast.
&nbsp;In this case, the host class of at least one member pointer was not a fully defined class and, as such, it is unknown
whether the host classes are related through derivation.&nbsp; These casts were illegal, but became legal when the new-style
casts were added to the draft working paper.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D1;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int (C1::* C1mp )();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int (D1::* D1mp )();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C1mp fn( D1mp x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (C1mp) x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // D1 may derive from C1</TT>
<BR><BR>The cast on the last line of the example would be diagnosed.
<H2 ID="883_cast_changes_both_member_pointer_object_and_class_type"> 883 cast changes both member pointer object and class type </H2>
<BR>This warning is issued to indicate that a dangerous cast of a member pointer has been used.&nbsp; This occurs when there
is an explicit cast between sufficiently unrelated types of member pointers that the cast must be implemented using a reinterpret_cast.
&nbsp;In this case, the host classes of the member pointers are related through derivation and the object type is also being
changed.&nbsp; The cast can be broken up into two casts, one that changes the host class without changing the object type,
and another that changes the object type without changing the host class.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct C1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fn1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D1 : C1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fn2();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int (C1::* C1mp )();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (D1::* D1mp )();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C1mp fn( D1mp x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (C1mp) x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The cast on the last line of the example would be diagnosed.
<H2 ID="884_virtual_function___S__has_a_different_calling_convention"> 884 virtual function '%S' has a different calling convention </H2>
<BR>This error indicates that the calling conventions specified in the virtual function prototypes are different.&nbsp; This
means that virtual function calls will not function properly since the caller and callee may not agree on how parameters should
be passed.&nbsp; Correct the problem by deciding on one calling convention and change the erroneous declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void __cdecl foo( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void foo( int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="885__endif_matches__if_in_different_source_file"> 885 #endif matches #if in different source file </H2>
<BR>This warning may indicate a<B><I> #endif</I></B> nesting problem since the traditional usage of<B><I> #if</I></B> directives
is confined to the same source file.&nbsp; This warning may often come before an error and it is hoped will provide information
to solve a preprocessing directive problem.
<H2 ID="886_preprocessing_directive_found__L"> 886 preprocessing directive found %L </H2>
<BR>This informational message indicates the location of a preprocessing directive associated with the error or warning message.
<H2 ID="887_unary__M__of_unsigned_operand_produces_unsigned_result"> 887 unary '-' of unsigned operand produces unsigned result </H2>
<BR>When a unary minus ('-') operator is applied to an unsigned operand, the result has an unsigned type rather than a signed
type.&nbsp; This warning often occurs because of the misconception that '-' is part of a numeric token rather than as a unary
operator.&nbsp; The work-around for the warning is to cast the unary minus operand to the appropriate signed type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void u( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void u( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( unsigned x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u( -x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u( -2147483648 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="888_trigraph_expansion_produced___c_"> 888 trigraph expansion produced '%c' </H2>
<BR>Trigraph expansion occurs at a very low-level so it can affect string literals that contain question marks.&nbsp; This
warning can be disabled via the command line or<B><I> #pragma warning</I></B> directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // string expands to &quot;(?]?~????&quot;!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *e = &quot;(???)???-????&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // possible work-arounds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *f = &quot;(&quot; &quot;???&quot; &quot;)&quot; &quot;???&quot; &quot;-&quot; &quot;????&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *g = &quot;(\?\?\?)\?\?\?-\?\?\?\?&quot;;</TT>
<H2 ID="889_hexadecimal_escape_sequence_out_of_rangeS_truncated"> 889 hexadecimal escape sequence out of range; truncated </H2>
<BR>This message indicates that the hexadecimal escape sequence produces an integer that cannot fit into the required character
type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *p = &quot;\x0aCache Timings\x0a&quot;;</TT>
<H2 ID="890_undefined_macro___s__evaluates_to_0"> 890 undefined macro '%s' evaluates to 0 </H2>
<BR>The ISO C/C++ standard requires that undefined macros evaluate to zero during preprocessor expression evaluation.&nbsp;
This default behaviour can often mask incorrectly spelled macro references.&nbsp; The warning is useful when used in critical
environments where all macros will be defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if _PRODUCTI0N // should be _PRODUCTION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H2 ID="891_char_constant_has_value__u_Lmore_than_8_bitsR"> 891 char constant has value %u (more than 8 bits) </H2>
<BR>The ISO C/C++ standard requires that multi-char character constants be accepted with an implementation defined value.
&nbsp;This default behaviour can often mask incorrectly specified character constants.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x = '\0x1a'; // warning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int y = '\x1a';</TT>
<H2 ID="892_promotion_of_unadorned_char_type_to_int"> 892 promotion of unadorned char type to int </H2>
<BR>This message is enabled by the hidden -jw option.&nbsp; The warning may be used to locate all places where an unadorned
char type (i.e., a type that is specified as<B><I> char</I></B> and neither<B><I> signed char</I></B> nor<B><I> unsigned char</I></B>
).&nbsp; This may cause portability problems since compilers have freedom to specify whether the unadorned char type is to
be signed or unsigned.&nbsp; The promotion to<B><I> int</I></B> will have different values, depending on the choice being
made.
<H2 ID="893_switch_statement_has_no_case_labels"> 893 switch statement has no case labels </H2>
<BR>The switch statement referenced in the warning did not have any case labels.&nbsp; Without case labels, a switch statement
will always jump to the default case code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="894_unexpected_character_L_uR_in_source_file"> 894 unexpected character (%u) in source file </H2>
<BR>The compiler has encountered a character in the source file that is not in the allowable set of input characters.&nbsp;
The decimal representation of the character byte is output for diagnostic purposes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // invalid char '\0'</TT>
<H2 ID="895_ignoring_whitespace_after_line_splice"> 895 ignoring whitespace after line splice </H2>
<BR>The compiler is ignoring some whitespace characters that occur after the line splice.&nbsp; This warning is useful when
the source code must be compiled with other compilers that do not allow this extension.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define XXXX int \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; XXXX</TT>
<H2 ID="896_empty_member_declaration"> 896 empty member declaration </H2>
<BR>The compiler is warning about an extra semicolon found in a class definition.&nbsp; The extra semicolon is valid C++ but
some C++ compilers do not accept this as valid syntax.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S { ; };</TT>
<H2 ID="897___S__makes_use_of_a_nonMportable_feature_LzeroMsized_arrayR"> 897 '%S' makes use of a non-portable feature (zero-sized array) </H2>
<BR>The compiler is warning about the use of a non-portable feature in a declaration or definition.&nbsp; This warning is
available for environments where diagnosing the use of non-portable features is useful in improving the portability of the
code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="898_inMclass_initialization_is_only_allowed_for_const_static_integral_members"> 898 in-class initialization is only allowed for const static integral members </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int i = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="899_cannot_convert_expression_to_target_type"> 899 cannot convert expression to target type </H2>
<BR>The implicit cast is trying to convert an expression to a completely unrelated type.&nbsp; There is no way the compiler
can provide any meaning for the intended cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool b = T;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="900_unknown_template_specialization_of___S_"> 900 unknown template specialization of '%S' </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void A&lt;T *&gt;::f() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="901_wrong_number_of_template_arguments_for___S_"> 901 wrong number of template arguments for '%S' </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T, class U&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A&lt;T, U&gt; { };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="902_cannot_explicitly_specialize_member_of___S_"> 902 cannot explicitly specialize member of '%S' </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A&lt;int&gt; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void A&lt;int&gt;::f() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="903_specialization_arguments_for___S__match_primary_template"> 903 specialization arguments for '%S' match primary template </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A&lt;T&gt; { };</TT>
<H2 ID="904_partial_template_specialization_for___S__ambiguous"> 904 partial template specialization for '%S' ambiguous </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T, class U&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T, class U&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A&lt;T *, U&gt; { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt;class T, class U&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A&lt;T, U *&gt; { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&lt;int *, int *&gt; a;</TT>
<H2 ID="905_static_assertion_failed___s_"> 905 static assertion failed '%s' </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static_assert( false, &quot;false&quot; );</TT>
<H2 ID="906_Exported_templates_are_not_supported_by_Open_Watcom_CPP"> 906 Exported templates are not supported by Open Watcom C++ </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; export template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="907_redeclaration_of_member_function___S__not_allowed"> 907 redeclaration of member function '%S' not allowed </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="908_candidate_defined__L"> 908 candidate defined %L </H2>
<H2 ID="909_Invalid_register_name___s__in__pragma"> 909 Invalid register name '%s' in #pragma </H2>
<BR>The register name is invalid/unknown.
<H2 ID="910_Archaic_syntax__classDstruct_missing_in_explicit_template_instantiation"> 910 Archaic syntax:&nbsp; class/struct missing in explicit template instantiation </H2>
<BR>Archaic syntax has been used.&nbsp; The standard requires a<B><I> class</I></B> or<B><I> struct</I></B> keyword to be
used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class MyTemplate { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template MyTemplate&lt; int &gt;;</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template class MyTemplate&lt; int &gt;;</TT>
<H2 ID="911_destructor_for_type_void_cannot_be_called"> 911 destructor for type void cannot be called </H2>
<BR>Since the<B><I> void</I></B> type has no size and there are no values of<B><I> void</I></B> type, one cannot destruct
an instance of<B><I> void.</I></B>&nbsp; 
<H2 ID="912__typename__keyword_used_outside_template"> 912 'typename' keyword used outside template </H2>
<BR>The<B><I> typename</I></B> keyword is only allowed inside templates.
<H2 ID="913___N__does_not_have_a_return_type_specified"> 913 '%N' does not have a return type specified </H2>
<BR>In C++, functions must have an explicit return type specified, default int type is no longer assumed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f ();</TT>
<H2 ID="914__main__must_return__int_"> 914 'main' must return 'int' </H2>
<BR>The &quot;main&quot; function shall have a return type of type int.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; { }</TT>
<H2 ID="915_explicit_may_only_be_used_within_class_definition"> 915 explicit may only be used within class definition </H2>
<BR>The explicit specifier shall be used only in the declaration of a constructor within its class definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explicit A();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; explicit A::A()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; { }</TT>
<H2 ID="916_virtual_may_only_be_used_within_class_definition"> 916 virtual may only be used within class definition </H2>
<BR>The virtual specifier shall be used only in the initial declaration of a class member function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void f();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; virtual void A::f()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; { }</TT>
<H2 ID="917_cannot_redefine_default_template_argument___N_"> 917 cannot redefine default template argument '%N' </H2>
<BR>A template-parameter shall not be given default arguments by two different declarations in the same scope.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T = int &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T = int &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="918_cannot_have_default_template_arguments_in_partial_specializations"> 918 cannot have default template arguments in partial specializations </H2>
<BR>A partial specialization cannot have default template arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T = int &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class X&lt; T * &gt; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="919_delete_of_a_pointer_to_void"> 919 delete of a pointer to void </H2>
<BR>If the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.&nbsp; This implies
that an object cannot be deleted using a pointer of type void* because there are no objects of type void.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void *p, void *q ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] q;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="920__long_char__is_deprecated__use_wchar_t_instead"> 920 'long char' is deprecated, use wchar_t instead </H2>
<BR>The standard C++ 'wchar_t' type specifier should be used instead of the Open Watcom specific 'long char' type specifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long char c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="921_namespace___I__not_allowed_in_usingMdeclaration"> 921 namespace '%I' not allowed in using-declaration </H2>
<BR>Specifying a namespace-name is not allowed in a using-declaration, a using-directive must be used instead.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace ns { }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; using ns;</TT>
<H2 ID="922_candidate__C_defined__L"> 922 candidate %C defined %L </H2>
<H2 ID="923_qualified_name___I__does_not_name_a_class"> 923 qualified name '%I' does not name a class </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; namespace ns {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct ns::A {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="924_expected_class_type__but_got___T_"> 924 expected class type, but got '%T' </H2>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A : public T {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&lt; int &gt; a;</TT>
<H2 ID="925_syntax_error_near___s_S_probable_cause__incorrectly_spelled_type_name"> 925 syntax error near '%s'; probable cause:&nbsp; incorrectly spelled type name </H2>
<BR>The identifier in the error message has not been declared as a type name in any scope at this point in the code.&nbsp;
This may be the cause of the syntax error.
<H2 ID="926_syntax_error____s__has_not_been_declared_as_a_member"> 926 syntax error:&nbsp; '%s' has not been declared as a member </H2>
<BR>The identifier in the error message has not been declared as member.&nbsp; This may be the cause of the syntax error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A { };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A::undeclared = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="927_syntax_error____s__has_not_been_declared"> 927 syntax error:&nbsp; '%s' has not been declared </H2>
<BR>The identifier in the error message has not been declared.&nbsp; This may be the cause of the syntax error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::undeclared = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="928_syntax_error__identifier___s___but_expected____s_"> 928 syntax error:&nbsp; identifier '%s', but expected:&nbsp; '%s' </H2>
<H2 ID="929_syntax_error__token___s___but_expected____s_"> 929 syntax error:&nbsp; token '%s', but expected:&nbsp; '%s' </H2>
<H2 ID="930_member___S__cannot_be_declared_in_this_class"> 930 member '%S' cannot be declared in this class </H2>
<BR>A member cannot be declared with the same name as its containing class if the class has a user-declared constructor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S() { }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int S;&nbsp;&nbsp; // Error!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="931_cvMqualifier_in_cast_to___T__is_meaningless"> 931 cv-qualifier in cast to '%T' is meaningless </H2>
<BR>A top-level cv-qualifier for a non-class rvalue is meaningless.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int i = (const int) 0;</TT>
<H2 ID="932_cvMqualifier_in_return_type___T__is_meaningless"> 932 cv-qualifier in return type '%T' is meaningless </H2>
<BR>A top-level cv-qualifier for a non-class rvalue is meaningless.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int f() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="933_use_of_CMstyle_cast_to___T__is_discouraged"> 933 use of C-style cast to '%T' is discouraged </H2>
<BR>Use of C-style casts &quot;(type) (expr)&quot; is discouraged in favour of explicit C++ casts like static_cast, const_cast,
dynamic_cast and reinterpret_cast.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const signed int *f( unsigned int *psi ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ( signed int * ) psi;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="934_unable_to_match_function_template_definition___S_"> 934 unable to match function template definition '%S' </H2>
<BR>The function template definition cannot be matched to an earlier declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A( );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template&lt; class T &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&lt; int &gt;::A( )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; { }</TT>
<H2 ID="935_form_is___pragma_enable_messageL_msgnum_R_"> 935 form is '#pragma enable_message( msgnum )' </H2>
<BR>This<B><I> pragma</I></B> enables the specified warning message.
<H2 ID="936_form_is___pragma_disable_messageL_msgnum_R_"> 936 form is '#pragma disable_message( msgnum )' </H2>
<BR>This<B><I> pragma</I></B> disables the specified warning message.
<H2 ID="937_option_requires_a_character"> 937 option requires a character </H2>
<BR>The specified option is not recognized by the compiler since there was no character after it (i.e., &quot;-p#@&quot; ).
<H2 ID="938__auto__is_no_longer_a_storage_specifier_in_CPP11_mode"> 938 'auto' is no longer a storage specifier in C++11 mode </H2>
<BR>When C++11 is enabled, the<B><I> auto</I></B> can no longer appear as a storage specifier.
<H2 ID="939_Implicit_conversion_from__decltypeLnullptrR__to__bool__"> 939 Implicit conversion from 'decltype(nullptr)' to 'bool'. </H2>
<BR>When C++11 is enabled, an implicit conversion from std::nullptr_t to bool is suspicious.
</BODY>
